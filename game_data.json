{"name": "Modern Mathematics with Lean", "version": "0.4", "languages": ["en"], "translated_name": "0", "devmode": false, "library_zip_fn": "Modern Mathematics with Lean-0.4-library.zip", "introData": {"name": "", "problemIndex": -1, "objects": [{"type": "text", "content": "1"}]}, "worlds": [{"name": "2", "levels": [{"name": "", "problemIndex": 10, "objects": [{"type": "lean", "content": "3", "hidden": true}, {"type": "text", "content": "4"}, {"type": "text", "content": "5"}, {"type": "tactic", "content": "6", "name": "from", "sideBar": true}, {"type": "tactic", "content": "7", "name": "exact", "sideBar": true}, {"type": "axiom", "content": "8", "name": "rfl {a : \u03b1} :", "sideBar": true}, {"type": "lean", "content": "9", "hidden": true}, {"type": "lean", "content": "10", "hidden": true}, {"type": "lean", "content": "11", "hidden": true}, {"type": "lean", "content": "12", "hidden": false}, {"type": "theorem", "text": "13", "lean": "theorem x_plus_y_eq_x_plus_y : x + y = x + y :=\n", "sideBar": false, "firstProofLineNumber": 75, "lastProofLineNumber": 78, "textBefore": "import mynat.basic -- hide\n\n/-\n# Equations\n\n## Level 1: Proving equations through reflexivity\n\nThe `rfl` principle (short for reflexivity) can be used to prove any statement of the form\n`?X = ?X`. Here, I use `?X` to stand in for any expression of any type.\nIt could be `8 + 9` or `a * b` or `\"adele\"` or whatever.\n\nBelow, you are asked to prove `x + y = x + y`, where `x` and `y` are natural numbers.\nThe word `sorry` between the `begin` and `end` lines below asks Lean not to give an error message if a\nproof isn't complete. You'll see a <span style=\"color:orange\">warning</span> message in the\nbottom-right hand pane. This indicates you shouldn't trust the proof just yet, as it uses `sorry`!\n\nDelete `sorry` (using the backspace key on your keyboard). In the right-hand pane you'll see:\n```\nx y : \u2115\n\u22a2 x + y = x + y\n```\n\nHere, `x y : \u2115` is the *context*, the set of things you know. In this case, you know `x` and `y`\nare natural numbers.\n\nThe *target* is `\u22a2 x + y = x + y`. The `\u22a2` symbol can be read 'to prove'. So your target is\nto prove `x + y = x + y`.\n\nThe bottom part of the right-hand pane shows an <span style=\"color:red\">error</span>  message:\ntactic failed, there are unsolved goals. Don't panic! It's just telling you that you haven't yet\nproved the result.\n\nYour task is to replace `sorry` with `from rfl,`. Note the comma at the end of the line!\nIf you're successful, Lean will respond with the message `no goals` or `Proof complete!`\n\nIn `from rfl`, the word `from` is a *tactic*. This tactic takes a proof term and closes a goal\nif the provided proof term exactly matches the target. The list of tactics you've seen so far\nis presented in the left-hand pane.\n-/\n\n/-\n## Translation to a hand-written proof\n\nIn words, the `from rfl` says, \"The result holds from reflexivity\".\n\n-/\n\n/- Tactic : from\nIf `h` is a hypothesis or proof term that matches the target, then `from h` will close the goal.\n\n`from` is a synonym for the tactic `exact`.\n-/\n\n/- Tactic : exact\nIf `h` is a hypothesis or proof term that matches the target, then `exact h` will close the goal.\n-/\n\n/- Axiom : rfl {a : \u03b1} :\na = a\n-/\n\nnamespace exlean -- hide\n\nopen mynat -- hide\n\nopen_locale mynum -- hide\n\nvariables (x y : \u2115) -- Declare `x` and `y` to be natural numbers.\n\n/- Theorem : no-side-bar\n$x + y = x + y$, for all natural numbers $x$ and $y$.\n-/\ntheorem x_plus_y_eq_x_plus_y : x + y = x + y :=\nbegin\n", "proof": "  from rfl,\n\n\n", "proof_hint": "sorry", "textAfter": "\nend\n\nend exlean -- hide\n", "height": 4, "editorText": "sorry", "lineOffset": 74, "name": "x_plus_y_eq_x_plus_y", "statement": "x + y = x + y"}, {"type": "lean", "content": "14", "hidden": true}]}, {"name": "", "problemIndex": 8, "objects": [{"type": "lean", "content": "15", "hidden": true}, {"type": "text", "content": "16"}, {"type": "tactic", "content": "17", "name": "apply", "sideBar": true}, {"type": "lean", "content": "18", "hidden": true}, {"type": "lean", "content": "19", "hidden": true}, {"type": "lean", "content": "20", "hidden": true}, {"type": "axiom", "content": "21", "name": "add_comm (a b : \u2115) :", "sideBar": true}, {"type": "lean", "content": "22", "hidden": true}, {"type": "theorem", "text": "23", "lean": "theorem add_3_eq_3_add : x + 3 = 3 + x :=\n", "sideBar": false, "firstProofLineNumber": 59, "lastProofLineNumber": 61, "textBefore": "import mynat.add_mul_lemmas  -- hide\n\n/-\n# Equations\n\n## Level 2: Commutativity of addition\n\nNow we'll prove something (slighlty) more interesting, than `x + 3 = 3 + x`.\nTry `from rfl,` below (remember to put a comma after `rfl`) and see what happens.\n\nYou'll get an error message:\n```\ninvalid apply tactic, failed to unify\n  x + 3 = 3 + x\nwith\n  ?m_2 = ?m_2\n```\n\nLean tells you that you're trying to use `rfl` to prove `x + 3 = 3 + x`, but it expects a target\nof the form `?m_2 = ?m_2`.\n\nThe problem: even though we 'know' the left and right sides are equal, they are not\n*identically equal*.\nFortunately, Lean comes with a *theorem* of just the right kind. It's called `add_comm`, which is\nshort for additive commutativity.\nThe result `add_comm a b` states that `a + b = b + a`, where `a` and `b` are natural numbers.\n\nTo apply this theorem, we'll use the `from` tactic.\n\nReplace the `sorry` below with `from add_comm x 3` (followed by a comma\u2014I won't mention this from now\non).\n\nAlternatively, write `apply add_comm`. The `apply` tactic automatically fills in the missing\narguments to `add_comm`.\n-/\n\n/- Tactic : apply\n`apply`, provided with a theorem name and any number of conditions of the theorem,\nopens as many new goals are necessary to fill in proofs of the remaining conditions\nof the theorem.\n-/\n\nnamespace exlean -- hide\n\nopen_locale mynum -- hide\n\nvariables (x y : \u2115) -- hide\n\n/- Axiom : add_comm (a b : \u2115) :\na + b = b + a\n-/\ntheorem add_comm (a b : \u2115) : a + b = b + a := mynat.add_comm' a b -- hide\n\n/- Theorem : no-side-bar\n$x + 3 = 3 + x$, for all natural numbers $x$.\n-/\ntheorem add_3_eq_3_add : x + 3 = 3 + x :=\nbegin\n", "proof": "  apply add_comm,\n\n", "proof_hint": "sorry", "textAfter": "\nend\n\nend exlean -- hide\n\n/-\n## Translation to a hand-written proof\n\nIn words, `from add_comm x 3` says, \"The result follows from additive commutativity applied\nto $x$ and $3$.\"\n\nLikewise, `apply add_comm` says, \"The result follows by applying additive commutativity\".\n-/\n\n/-\n## Anatomy of a level\n\nEach level contains three vertical panes. The left-hand pane contains a list of the tactics and\ntheorem statements you've seen so far. Click on the arrows to dig deeper.\n\nThe middle pane is the one you're reading now! It contains text and interactive exercises.\nThe right-hand pane contains the Lean Infoview window, showing the 'tactic state' and error messages.\n\nYou can navigate through the book using the buttons in the top horizonal pane. The circular arrow\nresets your progress.\n-/", "height": 3, "editorText": "sorry", "lineOffset": 58, "name": "add_3_eq_3_add", "statement": "x + 3 = 3 + x"}, {"type": "lean", "content": "24", "hidden": true}, {"type": "text", "content": "25"}, {"type": "text", "content": "26"}]}, {"name": "", "problemIndex": 14, "objects": [{"type": "lean", "content": "27", "hidden": true}, {"type": "text", "content": "28"}, {"type": "tactic", "content": "29", "name": "have", "sideBar": true}, {"type": "lean", "content": "30", "hidden": true}, {"type": "lean", "content": "31", "hidden": true}, {"type": "lean", "content": "32", "hidden": true}, {"type": "text", "content": "33"}, {"type": "lean", "content": "34", "hidden": false}, {"type": "text", "content": "35"}, {"type": "text", "content": "36"}, {"type": "tactic", "content": "37", "name": "show", "sideBar": true}, {"type": "lean", "content": "38", "hidden": false}, {"type": "text", "content": "39"}, {"type": "text", "content": "40"}, {"type": "theorem", "text": "41", "lean": "theorem bc_add_comm : b + c = c + b :=\n", "sideBar": false, "firstProofLineNumber": 86, "firstProofHintLineNumber": 89, "lastProofHintLineNumber": 90, "lastProofLineNumber": 93, "textBefore": "import equations.add_comm -- hide\n\n/-\n# Equations\n\n## Level 3: `have` and `show`\n\nThe `have` tactic enables you to structure your proofs by adding intermediate results into the\ncontext. The `show` tactic helps your reader understand what you are proving.\n\n-/\n\n/- Tactic : have\n`have` is used to introduce a hypothesis into the context. For example,\n`have h : x + y = x + y, from rfl,` introduces the hypothesis `h : x + y = x + y` into the context.\n`have` requires a tactic proof of the claimed result. Here, `from rfl` is a tactic proof of `x + y = x + y`.\n\nMore generally, `have h : \u03b1, T` introduces `h : \u03b1` into the context if `T` is a tactic proof of `\u03b1`.\n-/\n\nnamespace exlean -- hide\n\nopen_locale mynum -- hide\n\nvariables (a b c : \u2115) -- hide\n\n/-\nIn the example below, the first line adds `h : a + b = b + a` into the context. Here,\n`apply add_comm` gives a proof of `a + b = b + a`. The second lines uses this intermediate result\nto close the goal. In this simple example `have` is not necessary as the proof can be done in one\nline with `apply add_comm`.\n-/\n\n\nexample : a + b = b + a :=\nbegin\n  have h : a + b = b + a, apply add_comm,\n  from h,\nend\n\n/-\n## Translation to a hand-written proof\n\nIn words, the above proof says:\n> We have $h : a + b = b + a$, by additive commutativity.\n> The result follows from $h$.\n-/\n\n\n/-\nChanging the last line of the Lean proof above, we indicate what is being proved with the `show` tactic.\n-/\n\n/- Tactic : show\n`show` is used to state what is being proved. If, for example, the target is to prove `x + y = x + y`,\nyou can indicate and prove this using `show x + y = x + y, from rfl`.\n\nMore generally, if the target is to prove `\u03b1`, you can close the goal using `show \u03b1, T` where `T` is a tactic proof of `\u03b1`.\n-/\n\n\nexample : a + b = b + a :=\nbegin\n  have h : a + b = b + a, apply add_comm,\n  show a + b = b + a, from h,\nend\n\n/-\nIn words, the above proof says:\n> We have $h : a + b = b + a$, by additive commutativity.\n> We show $a + b = b + a$ from $h$.\n-/\n\n\n/-\n## Task\nReplace the underscores `_` below with statements and the `sorry` with a proof.\n-/\n\n\n/- Theorem : no-side-bar\n$b + c = c + b$, for all natural numbers $b$ and $c$.\n-/\ntheorem bc_add_comm : b + c = c + b :=\nbegin\n", "proof": "  have h : b + c = c + b, apply add_comm,\n  show b + c = c + b, from h,\n/- hint\nhave h : _, sorry,\nshow _, from h,\n-/\n\n", "proof_hint": "have h : _, sorry,\nshow _, from h,", "textAfter": "\nend\n\nend exlean -- hide\n", "height": 8, "editorText": "have h : _, sorry,\nshow _, from h,", "lineOffset": 85, "name": "bc_add_comm", "statement": "b + c = c + b"}, {"type": "lean", "content": "42", "hidden": true}]}, {"name": "", "problemIndex": 16, "objects": [{"type": "lean", "content": "43", "hidden": true}, {"type": "text", "content": "44"}, {"type": "lean", "content": "45", "hidden": true}, {"type": "lean", "content": "46", "hidden": true}, {"type": "lean", "content": "47", "hidden": true}, {"type": "axiom", "content": "48", "name": "eq.sub (P : T \u2192 Prop) (h : a = b) (ha : P a) :", "sideBar": true}, {"type": "lean", "content": "49", "hidden": true}, {"type": "text", "content": "50"}, {"type": "axiom", "content": "51", "name": "add_comm_congr_left (s t u : \u2115) :", "sideBar": true}, {"type": "lean", "content": "52", "hidden": false}, {"type": "text", "content": "53"}, {"type": "lean", "content": "54", "hidden": false}, {"type": "text", "content": "55"}, {"type": "lean", "content": "56", "hidden": false}, {"type": "text", "content": "57"}, {"type": "hint", "content": "58", "title": "59"}, {"type": "theorem", "text": "60", "lean": "theorem add_comm_congr_right : (s + t) + u  = (t + s) + u :=\n", "sideBar": true, "firstProofLineNumber": 96, "firstProofHintLineNumber": 101, "lastProofHintLineNumber": 104, "lastProofLineNumber": 107, "textBefore": "import equations.add_comm -- hide\n\n/-\n# Equations\n\n## Level 4: Substitution\n-/\n\n\nnamespace exlean -- hide\n\nopen_locale mynum -- hide\n\nvariables (s t u : \u2115) -- hide\n\n\n/- Axiom : eq.sub (P : T \u2192 Prop) (h : a = b) (ha : P a) :\nP b\n-/\n-- begin hide\n@[elab_as_eliminator]\ndef eq.sub {T} {a b : T} (P : T -> Prop) (h : a = b) (ha : P a) := @eq.rec T a P ha b h\n-- end hide\n\n\n/-\nIf you know `h\u2081 : a = b` and you know `h\u2082 : P(a)`, where `P(a)` is some statement involving `a`,\nthen you know `P(b)`. This principle is called *substitution*. In Lean, `eq.sub P h\u2081 h\u2082` is a\nproof of `P(b)`.\n\nA statement that depends on a variable (or on zero or more variables) is called a *predicate*. Thus,\n`P` above is a predicate.\n\nWe use the substitution principle to prove $s + (t + u) = s + (u + t)$. Let $P(x)$ be the statement\n$s + (t + u) = s + x$. We have $h_1 : t + u = u + t$, by commutativity of addition.\nWe have $h_2 : P (t + u)$ (that is $s + (t + u) = s + (t + u)$), from reflexivity.\n\nThus, the result (which is $P(u + t)$) follows by substituting $h_1$ into $h_2$.\n\nThis proof is written in Lean as follows.\n-/\n\n/- Axiom : add_comm_congr_left (s t u : \u2115) :\ns + (t + u) = s + (u + t)\n-/\n\ntheorem add_comm_congr_left : s + (t + u) = s + (u + t) :=\nbegin\n  let P : \u2115 \u2192 Prop := \u03bb x, s + (t + u) = s + x,\n  have h\u2081 : t + u = u + t, apply add_comm,\n  have h\u2082 : P(t + u), from rfl,\n  show P(u + t), from eq.sub P h\u2081 h\u2082,\nend\n\n/-\nIn the proof below, we don't give $P$ explicitly. By using the underscore `_` as an argument to\n`eq.sub`, we ask Lean to infer the correct predicate `P`.\n-/\n\nexample : s + (t + u) = s + (u + t) :=\nbegin\n  have h\u2081 : t + u = u + t, from add_comm t u,\n  have h\u2082 : s + (t + u) = s + (t + u), from rfl,\n  show s + (t + u) = s + (u + t) , from eq.sub _ h\u2081 h\u2082,\nend\n\n/-\nFinally, we can give a very terse proof of the result.\n-/\n\nexample : s + (t + u) = s + (u + t) :=\nbegin\n  from eq.sub _ (add_comm t u) rfl,\nend\n\n/-\n## Task \n\nComplete the proof below, adapting the proof above. Replace each underscore `_` with a statement\nand each `sorry` with a proof.\n\nHere, `\u2115`, the type of natural numbers, is written `\\N` while `\u03bb` is typed `\\lam`.\n-/\n\n/- Hint : Avoiding the predicate\nIf you're struggling to determine the predicate `P`, delete the `let` line, replace `h\u2082 : P(s + t)`\nwith `h\u2082 : (s + t) + u = (s + t) + u`, and replace `eq.sub P h\u2081 h\u2082` with `eq.sub _ h\u2081 h\u2082`.\n-/\n\n\n/- Theorem : \n$(s + t) + u = (t + s) + u$, for all natural numbers $s$, $t$, $u$.\n-/\ntheorem add_comm_congr_right : (s + t) + u  = (t + s) + u :=\nbegin\n", "proof": "  let P : \u2115 \u2192 Prop := \u03bb x, (s + t) + u = x + u,\n  have h\u2081 : s + t = t + s, from add_comm s t,\n  have h\u2082 : P(s + t), from rfl,\n  show (s + t) + u  = (t + s) + u, from eq.sub P h\u2081 h\u2082,\n/- hint\nlet P : \u2115 \u2192 Prop := \u03bb x, _,\nhave h\u2081 : _, from add_comm s t,\nhave h\u2082 : P(s + t), from sorry,\nshow (s + t) + u  = (t + s) + u, from eq.sub P h\u2081 h\u2082,\n-/\n\n", "proof_hint": "let P : \u2115 \u2192 Prop := \u03bb x, _,\nhave h\u2081 : _, from add_comm s t,\nhave h\u2082 : P(s + t), from sorry,\nshow (s + t) + u  = (t + s) + u, from eq.sub P h\u2081 h\u2082,", "textAfter": "\nend\n\nend exlean -- hide\n\n\n", "height": 12, "editorText": "let P : \u2115 \u2192 Prop := \u03bb x, _,\nhave h\u2081 : _, from add_comm s t,\nhave h\u2082 : P(s + t), from sorry,\nshow (s + t) + u  = (t + s) + u, from eq.sub P h\u2081 h\u2082,", "lineOffset": 95, "name": "add_comm_congr_right", "statement": "(s + t) + u  = (t + s) + u"}, {"type": "lean", "content": "61", "hidden": true}]}, {"name": "", "problemIndex": 8, "objects": [{"type": "lean", "content": "62", "hidden": true}, {"type": "text", "content": "63"}, {"type": "lean", "content": "64", "hidden": true}, {"type": "lean", "content": "65", "hidden": true}, {"type": "lean", "content": "66", "hidden": true}, {"type": "text", "content": "67"}, {"type": "hint", "content": "68", "title": "69"}, {"type": "hint", "content": "70", "title": "71"}, {"type": "theorem", "text": "72", "lean": "theorem add_comm_left_right : (s + t) + u  = u + (t + s) :=\n", "sideBar": false, "firstProofLineNumber": 39, "lastProofLineNumber": 45, "textBefore": "import equations.substitution -- hide\n\n/-\n# Equations\n\n## Level 5: Substitution 2\n-/\n\n\nnamespace exlean -- hide\n\nopen_locale mynum -- hide\n\nvariables (s t u : \u2115) -- hide\n\n/-\n## Task \n\nComplete the proof below. Get hints if needed by clicking on the drop-down menus below.\nIf you want to start with an explicit predicate, the first line should be\n```let P : \u2115 \u2192 Prop := \u03bb x, _,```\nwhere you should replace `_` with a statement depending on `x`.\n-/\n\n/- Hint: Structure of the proof\nYou can do this with (no more than) two `have`s and an application of substitution.\n-/\n\n/- Hint: A useful result\nThe result proved in the previous level will come in handy.\n-/\n\n\n/- Theorem : no-side-bar\n$(s + t) + u  = u + (t + s)$, for all natural numbers $s$, $t$, and $u$.\n-/\ntheorem add_comm_left_right : (s + t) + u  = u + (t + s) :=\nbegin\n", "proof": "  let P : \u2115 \u2192 Prop := \u03bb x, (s + t) + u = x,\n  have h\u2081 : (t + s) + u = u + (t + s), apply add_comm,\n  have h\u2082 : P((t + s) + u), apply add_comm_congr_right,\n  from eq.sub P h\u2081 h\u2082,\n\n\n", "proof_hint": "sorry", "textAfter": "\nend\n\nend exlean -- hide\n\n\n", "height": 7, "editorText": "sorry", "lineOffset": 38, "name": "add_comm_left_right", "statement": "(s + t) + u  = u + (t + s)"}, {"type": "lean", "content": "73", "hidden": true}]}, {"name": "", "problemIndex": 10, "objects": [{"type": "lean", "content": "74", "hidden": true}, {"type": "text", "content": "75"}, {"type": "lean", "content": "76", "hidden": true}, {"type": "lean", "content": "77", "hidden": true}, {"type": "lean", "content": "78", "hidden": true}, {"type": "axiom", "content": "79", "name": "congr_arg (f : \u03b1 \u2192 \u03b2) (h : a\u2081 = a\u2082) :", "sideBar": true}, {"type": "text", "content": "80"}, {"type": "lean", "content": "81", "hidden": false}, {"type": "text", "content": "82"}, {"type": "text", "content": "83"}, {"type": "theorem", "text": "84", "lean": "theorem congr_intro : (s + (t + u)) * t = (s + (u + t)) * t :=\n", "sideBar": false, "firstProofLineNumber": 58, "firstProofHintLineNumber": 62, "lastProofHintLineNumber": 63, "lastProofLineNumber": 64, "textBefore": "import equations.substitution2 -- hide\n\n/-\n# Equations\n\n## Level 6: Congruence of arguments\n-/\n\n\nnamespace exlean -- hide\n\nopen_locale mynum -- hide\n\nvariables (s t u : \u2115) -- hide\n\n/- Axiom :  congr_arg (f : \u03b1 \u2192 \u03b2) (h : a\u2081 = a\u2082) :\nf a\u2081 = f a\u2082\n-/\n\n/-\nLet `f` be a function. Suppose `h : a = b`. Then `congr_arg f h` gives a proof of `f(a) = f (b)`.\nThis is called congruence of arguments.\n\nIn the example below, $f$ is the function from $\\mathbb N$ to $\\mathbb N$ given by $f(x) := 5 x$.\nThe term $h$ is a proof of $t + u = u + t$. Thus, `congr_arg f h` is a proof that\n$5(t + u) = 5(u + t)$.\n-/\n\nexample : 5 * (t + u) = 5 * (u + t) :=\nbegin\n  let f : \u2115 \u2192 \u2115 := \u03bb x, 5 * x,\n  have h : t + u = u + t, apply add_comm,\n  show 5 * (t + u) = 5 * (u + t), from congr_arg f h,\nend\n\n/-\n## Translation to a hand-written proof\n\nThe proof above can be written by hand as follows.\n> Let $f : \\mathbb N \\to \\mathbb N$ be the function $f(x) := 5 x$.\n> We have $h : t + u = u + t$ by commutativity of addition.\n> The result follows by congruence of arguments with $f$ and $h$.\n-/\n\n/-\n## Task \n\nComplete the proof below, adapting the proof above.\n-/\n\n\n/- Theorem : no-side-bar\n$(s + (t + u))  t = (s + (u + t))  t$, for all natural numbers\n$s$, $t$, $u$.\n-/\ntheorem congr_intro : (s + (t + u)) * t = (s + (u + t)) * t :=\nbegin\n", "proof": "  let f : \u2115 \u2192 \u2115 := \u03bb x, (s + x) * t,\n  have h : t + u = u + t, apply add_comm,\n  from congr_arg f h,\n/- hint\nlet f : \u2115 \u2192 \u2115 := \u03bb x, sorry,\nsorry,\n-/", "proof_hint": "let f : \u2115 \u2192 \u2115 := \u03bb x, sorry,\nsorry,", "textAfter": "\nend\n\nend exlean -- hide\n\n\n", "height": 7, "editorText": "let f : \u2115 \u2192 \u2115 := \u03bb x, sorry,\nsorry,", "lineOffset": 57, "name": "congr_intro", "statement": "(s + (t + u)) * t = (s + (u + t)) * t"}, {"type": "lean", "content": "85", "hidden": true}]}, {"name": "", "problemIndex": 6, "objects": [{"type": "lean", "content": "86", "hidden": true}, {"type": "text", "content": "87"}, {"type": "lean", "content": "88", "hidden": true}, {"type": "text", "content": "89"}, {"type": "lean", "content": "90", "hidden": true}, {"type": "lean", "content": "91", "hidden": true}, {"type": "theorem", "text": "92", "lean": "theorem congr_arg (f : \u03b1 \u2192 \u03b2) (h : a = b) : f(a) = f(b) :=\n", "sideBar": false, "firstProofLineNumber": 31, "firstProofHintLineNumber": 35, "lastProofHintLineNumber": 37, "lastProofLineNumber": 40, "textBefore": "import equations.congruence -- hide\n\n/-\n# Equations\n\n## Level 7: Congruence of arguments - proof\n-/\n\n\nnamespace exlean -- hide\n\n\n/-\n## Task \n\nYou've used the `congr_arg` theorem. In this level, you'll *prove* it. Naturally, I've disabled\nthe ordinary `congr_arg` theorem so you can't cheat!\n-/\n\nnamespace hidden -- hide\n\nvariables {\u03b1 : Type*} {\u03b2 : Type*} {a b : \u03b1} -- hide\n\n/- Theorem : no-side-bar\nLet $f$ be a function from a type $\\alpha$ to a type $\\beta$. \nLet $a$ and $b$ be terms of type $\\alpha$ and suppose $h : a = b$.\nThen $f(a) = f(b)$. \n-/\ntheorem congr_arg (f : \u03b1 \u2192 \u03b2) (h : a = b) : f(a) = f(b) :=\nbegin\n", "proof": "  let P : \u03b1 \u2192 Prop := \u03bb x, f(a) = f(x),\n  have h\u2082 : P(a), from rfl,\n  from eq.sub P h h\u2082,\n/- hint\nlet P : \u03b1 \u2192 Prop := \u03bb x, _,\nhave h\u2082 : P(a), from sorry,\nfrom eq.sub P h h\u2082,\n-/\n\n", "proof_hint": "let P : \u03b1 \u2192 Prop := \u03bb x, _,\nhave h\u2082 : P(a), from sorry,\nfrom eq.sub P h h\u2082,", "textAfter": "\nend\n\nend hidden -- hide\n\nend exlean -- hide\n\n\n", "height": 10, "editorText": "let P : \u03b1 \u2192 Prop := \u03bb x, _,\nhave h\u2082 : P(a), from sorry,\nfrom eq.sub P h h\u2082,", "lineOffset": 30, "name": "congr_arg", "statement": "(f : \u03b1 \u2192 \u03b2) (h : a = b) : f(a) = f(b)"}, {"type": "lean", "content": "93", "hidden": true}, {"type": "lean", "content": "94", "hidden": true}]}, {"name": "", "problemIndex": 13, "objects": [{"type": "lean", "content": "95", "hidden": true}, {"type": "text", "content": "96"}, {"type": "lean", "content": "97", "hidden": true}, {"type": "lean", "content": "98", "hidden": true}, {"type": "text", "content": "99"}, {"type": "axiom", "content": "100", "name": "add_assoc (a b c : \u2115) :", "sideBar": true}, {"type": "lean", "content": "101", "hidden": true}, {"type": "lean", "content": "102", "hidden": true}, {"type": "text", "content": "103"}, {"type": "lean", "content": "104", "hidden": false}, {"type": "text", "content": "105"}, {"type": "lean", "content": "106", "hidden": false}, {"type": "lean", "content": "107", "hidden": true}, {"type": "theorem", "text": "108", "lean": "theorem add_assoc_symm : a + (b + c) = (a + b) + c :=\n", "sideBar": true, "firstProofLineNumber": 56, "lastProofLineNumber": 62, "textBefore": "import equations.congruence -- hide\n\n/-\n# Equations\n\n## Level 8: Associativity\n-/\n\n\nnamespace exlean -- hide\n\nopen_locale mynum -- hide\n\n/-\nAdditional of natural numbers satisfy the *associative* property. That is,\nfor all natural numbers $x$, $y$, and $z$, we have $(x + y) + z = x + (y + z)$.\nIn Lean, `add_assoc` is the name of this theorem. Thus, `add_assoc a b c` is a proof that\n`(a + b) + c = a + (b + c)`.\n-/\n\n/- Axiom : add_assoc (a b c : \u2115) :\n(a + b) + c = a + (b + c)\n-/\ntheorem add_assoc (a b c : \u2115) : (a + b) + c = a + (b + c) := mynat.add_assoc' a b c -- hide\n\nvariables (s t u v : \u2115) -- hide\n\n/-\nThus, `add_assoc (s + t) u v` is a proof that $((s + t) + u) + v = (s + t) + (u + v)$.\n-/\n\nexample : ((s + t) + u) + v = (s + t) + (u + v) :=\nbegin\n  from add_assoc (s + t) u v,\nend\n\n/-\nWe can let Lean do the chore of determining the arguments to `add_assoc` by using the `apply`\ntactic.\n-/\n\n\nexample : ((s + t) + u) + v = (s + t) + (u + v) :=\nbegin\n  apply add_assoc,\nend\n\n\nvariables (a b c : \u2115) -- hide\n\n/- Theorem :\n$a + (b + c) = (a + b) + c$, for all natural numbers $a$, $b$, and $c$.\n-/\ntheorem add_assoc_symm : a + (b + c) = (a + b) + c :=\nbegin\n", "proof": "  have h\u2081 : (a + b) + c = a + (b + c), apply add_assoc,\n  have h\u2082 : (a + b) + c = (a + b) + c, from rfl,\n  from eq.sub _ h\u2081 h\u2082\n\n\n\n", "proof_hint": "sorry", "textAfter": "\nend\n\n\nend exlean -- hide\n\n\n", "height": 7, "editorText": "sorry", "lineOffset": 55, "name": "add_assoc_symm", "statement": "a + (b + c) = (a + b) + c"}, {"type": "lean", "content": "109", "hidden": true}]}, {"name": "", "problemIndex": 13, "objects": [{"type": "lean", "content": "110", "hidden": true}, {"type": "text", "content": "111"}, {"type": "lean", "content": "112", "hidden": true}, {"type": "lean", "content": "113", "hidden": true}, {"type": "text", "content": "114"}, {"type": "axiom", "content": "115", "name": "eq.symm (h : a = b) :", "sideBar": true}, {"type": "text", "content": "116"}, {"type": "lean", "content": "117", "hidden": true}, {"type": "lean", "content": "118", "hidden": false}, {"type": "text", "content": "119"}, {"type": "lean", "content": "120", "hidden": false}, {"type": "lean", "content": "121", "hidden": true}, {"type": "text", "content": "122"}, {"type": "theorem", "text": "123", "lean": "theorem add_right_left_comm : s + (t + u) = (t + s) + u :=\n", "sideBar": false, "firstProofLineNumber": 61, "firstProofHintLineNumber": 65, "lastProofHintLineNumber": 67, "lastProofLineNumber": 71, "textBefore": "import equations.associativity -- hide\n\n/- \n# Equations\n\n## Level 9: Symmetry\n-/\n\n\nnamespace exlean -- hide\n\nopen_locale mynum -- hide\n\n/-\nThe symmetry property of $=$ states that if $a = b$, then $b = a$. In Lean, if $h : a = b$,\nthen `eq.symm h` is a proof that `b = a`. This can also be written `h.symm`.\n-/\n\n/- Axiom : eq.symm (h : a = b) :\nb = a\n-/\n\n/-\nUsing `eq.symm`, we'll reprove the result from the previous level.\n-/\n\nvariables (a b c : \u2115) -- hide\n\nexample : a + (b + c) = (a + b) + c :=\nbegin\n  have h : (a + b) + c = a + (b + c), apply add_assoc,\n  show a + (b + c) = (a + b) + c, from eq.symm h,\nend\n\n\n/-\nOr, more simply:\n-/\n\nexample : a + (b + c) = (a + b) + c :=\nbegin\n  from (add_assoc a b c).symm\nend\n\n\nvariables (s t u : \u2115) -- hide\n\n/-\n## Task\n\nComplete the proof below, replacing each underscore `_` with a statement and\neach `sorry` with a proof.\n-/\n\n\n/- Theorem : no-side-bar\n$s + (t + u) = (t + s) + u$, for all natural numbers $s$, $t$, and $u$.\n-/\ntheorem add_right_left_comm : s + (t + u) = (t + s) + u :=\nbegin\n", "proof": "  have h\u2081 : s + t = t + s, from add_comm s t,\n  have h\u2082 : s + (t + u) = (s + t) + u, apply add_assoc_symm,\n  show s + (t + u) = (t + s) + u, from eq.sub _ h\u2081 h\u2082,\n/- hint\nhave h\u2081 : _, from add_comm s t,\nhave h\u2082 : s + (t + u) = (s + t) + u, sorry,\nshow _, sorry,\n-/\n\n\n", "proof_hint": "have h\u2081 : _, from add_comm s t,\nhave h\u2082 : s + (t + u) = (s + t) + u, sorry,\nshow _, sorry,", "textAfter": "\nend\n\n\nend exlean -- hide\n\n\n", "height": 11, "editorText": "have h\u2081 : _, from add_comm s t,\nhave h\u2082 : s + (t + u) = (s + t) + u, sorry,\nshow _, sorry,", "lineOffset": 60, "name": "add_right_left_comm", "statement": "s + (t + u) = (t + s) + u"}, {"type": "lean", "content": "124", "hidden": true}]}, {"name": "", "problemIndex": 10, "objects": [{"type": "lean", "content": "125", "hidden": true}, {"type": "text", "content": "126"}, {"type": "lean", "content": "127", "hidden": true}, {"type": "lean", "content": "128", "hidden": true}, {"type": "text", "content": "129"}, {"type": "axiom", "content": "130", "name": "eq.trans (h\u2081 : a = b) (h\u2082 : b = c):", "sideBar": true}, {"type": "text", "content": "131"}, {"type": "lean", "content": "132", "hidden": true}, {"type": "lean", "content": "133", "hidden": false}, {"type": "text", "content": "134"}, {"type": "theorem", "text": "135", "lean": "theorem add_right_comm : (x + y) + z = (x + z) + y :=\n", "sideBar": true, "firstProofLineNumber": 50, "firstProofHintLineNumber": 56, "lastProofHintLineNumber": 59, "lastProofLineNumber": 61, "textBefore": "import equations.symmetry -- hide\n\n/- \n# Equations\n\n## Level 10 : Transitivity\n-/\n\n\nnamespace exlean -- hide\n\nopen_locale mynum -- hide\n\n/-\nGiven `h\u2081 : a = b` and `h\u2082 : b = c`, we have `a = c`. This is called *transitivity*. Specifically,\nthe Lean result `eq.trans h\u2081 h\u2082` is a  proof of `a = c`.\n-/\n\n/- Axiom : eq.trans (h\u2081 : a = b) (h\u2082 : b = c):\na = c\n-/\n\n\n/-\nWe'll prove a result using `eq.trans` and two other results we've seen.\n-/\n\nvariables (x y z : \u2115) -- hide\n\nexample : (x + y) + z = x + (z + y) :=\nbegin\n  have h\u2081 : (x + y) + z = x + (y + z), apply add_assoc,\n  have h\u2082 : x + (y + z) = x + (z + y), apply add_comm_congr_left,\n  show (x + y) + z = x + (z + y), from eq.trans h\u2081 h\u2082,\nend\n\n/-\n## Task\n\nComplete the proof below. You may need to replace `sorry` with two lines. The last\nline should invoke `eq.trans`.\n-/\n\n\n/- Theorem :\n$(x + y) + z = (x + z) + y$, for all natural numbers $x$, $y$, and $z$.\n-/\ntheorem add_right_comm : (x + y) + z = (x + z) + y :=\nbegin\n", "proof": "  have h\u2081 : (x + y) + z = x + (y + z), apply add_assoc,\n  have h\u2082 : x + (y + z) = x + (z + y), apply add_comm_congr_left,\n  have k : (x + y) + z = x + (z + y), from eq.trans h\u2081 h\u2082,\n  have h\u2083 : x + (z + y) = (x + z) + y, apply add_assoc_symm,\n  from eq.trans k h\u2083,\n/- hint\nhave h\u2081 : (x + y) + z = x + (y + z), apply add_assoc,\nhave h\u2082 : x + (y + z) = x + (z + y), apply add_comm_congr_left,\nhave k : (x + y) + z = x + (z + y), from eq.trans h\u2081 h\u2082,\nsorry,\n-/\n", "proof_hint": "have h\u2081 : (x + y) + z = x + (y + z), apply add_assoc,\nhave h\u2082 : x + (y + z) = x + (z + y), apply add_comm_congr_left,\nhave k : (x + y) + z = x + (z + y), from eq.trans h\u2081 h\u2082,\nsorry,", "textAfter": "\nend\n\n\n\nend exlean -- hide\n\n\n", "height": 12, "editorText": "have h\u2081 : (x + y) + z = x + (y + z), apply add_assoc,\nhave h\u2082 : x + (y + z) = x + (z + y), apply add_comm_congr_left,\nhave k : (x + y) + z = x + (z + y), from eq.trans h\u2081 h\u2082,\nsorry,", "lineOffset": 49, "name": "add_right_comm", "statement": "(x + y) + z = (x + z) + y"}, {"type": "lean", "content": "136", "hidden": true}]}, {"name": "", "problemIndex": 8, "objects": [{"type": "lean", "content": "137", "hidden": true}, {"type": "text", "content": "138"}, {"type": "lean", "content": "139", "hidden": true}, {"type": "lean", "content": "140", "hidden": true}, {"type": "text", "content": "141"}, {"type": "lean", "content": "142", "hidden": true}, {"type": "lean", "content": "143", "hidden": false}, {"type": "text", "content": "144"}, {"type": "theorem", "text": "145", "lean": "theorem shift_vars : (x + y) + z = (z + x) + y :=\n", "sideBar": false, "firstProofLineNumber": 58, "firstProofHintLineNumber": 62, "lastProofHintLineNumber": 64, "lastProofLineNumber": 65, "textBefore": "import equations.transitivity -- hide\n\n/- \n# Equations\n\n## Level 11 : Proof by calculation\n-/\n\n\nnamespace exlean -- hide\n\nopen_locale mynum -- hide\n\n/-\nIf you did the exericse from the previous level, you may have found it overly complicated for\nsuch a simple result. The proof required showing three equations of the form `h\u2081 : a = b`,\n`h\u2082 : b = c`, and `h\u2083 : c = d` and combining them by two applications of transitivity.\n\nThis technique is so common, that we have a special notation for proofs that combine several\nequations via transitivity. First, we present the handwritten version.\n\n**Proof**:\n$$\n\\begin{align}\n(x + y) + z &= x + (y + z) & & \\text{[by associativity of addition]} \\\\\\\\\n&= x + (z + y) & &\\text{[by Theorem add_comm_congr_left]} \\\\\\\\\n&= (x + z) + y. & & \\text{[by associativity of addition (backward)]}\n\\end{align}\n$$\n\nThe same proof can be presented in Lean as follows. Here, I use underscores `_` to ask Lean\nto fill in the missing arguments.\n-/\n\nvariables (x y z : \u2115) -- hide\n\nexample : (x + y) + z = (x + z) + y :=\nbegin\n  calc  \n  (x + y) + z = x + (y + z) : add_assoc _ _ _\n          ... = x + (z + y) : add_comm_congr_left _ _ _\n          ... = (x + z) + y : add_assoc_symm _ _ _,\nend\n\n\n/-\n## Task\n\nComplete the proof below. As usual, you will find it helpful to use the results already proved.\n-/\n\n\n/- Theorem : no-side-bar\n$(x + y) + z = (z + x) + y$, for all natural numbers $x$, $y$, and $z$.\n-/\ntheorem shift_vars : (x + y) + z = (z + x) + y :=\nbegin\n", "proof": "  calc\n  (x + y) + z = (x + z) + y : add_right_comm _ _ _\n          ... = (z + x) + y : add_comm_congr_right _ _ _,\n/- hint\ncalc\n(x + y) + z = (x + z) + y : sorry\n        ... = (z + x) + y : sorry,\n-/", "proof_hint": "calc\n(x + y) + z = (x + z) + y : sorry\n        ... = (z + x) + y : sorry,", "textAfter": "\nend\n\n\nend exlean -- hide\n\n\n", "height": 8, "editorText": "calc\n(x + y) + z = (x + z) + y : sorry\n        ... = (z + x) + y : sorry,", "lineOffset": 57, "name": "shift_vars", "statement": "(x + y) + z = (z + x) + y"}, {"type": "lean", "content": "146", "hidden": true}]}, {"name": "", "problemIndex": 8, "objects": [{"type": "lean", "content": "147", "hidden": true}, {"type": "text", "content": "148"}, {"type": "lean", "content": "149", "hidden": true}, {"type": "lean", "content": "150", "hidden": true}, {"type": "text", "content": "151"}, {"type": "hint", "content": "152", "title": "153"}, {"type": "hint", "content": "154", "title": "155"}, {"type": "lean", "content": "156", "hidden": true}, {"type": "theorem", "text": "157", "lean": "theorem challenge_comm_assoc : (x + y) + (s + t) = (y + (t + s)) + x :=\n", "sideBar": false, "firstProofLineNumber": 38, "lastProofLineNumber": 45, "textBefore": "import equations.calculation -- hide\n\n/- \n# Equations\n\n## Level 12 : Challenge level\n-/\n\n\nnamespace exlean -- hide\n\nopen_locale mynum -- hide\n\n/-\nWrite a proof by calculation (or by any other method) of the result below.\n-/\n\n/- Hint : Required results\nYou can do this entirely using `congr_arg`, `add_assoc`, and `add_comm`.\n-/\n\n/- Hint : A proof template\nTry the following proof template. For the first `sorry`, you'll need `congr_arg`.\n```\ncalc (x + y) + (s + t) = (x + y) + (t + s) : sorry\n... = x + (y + (t + s)) : sorry\n... = (y + (t + s)) + x : sorry,\n```\n-/\n\nvariables (x y z s t : \u2115) -- hide\n\n/- Theorem : no-side-bar\n$(x + y) + (s + t) = (y + (t + s)) + x$, for all natural numbers $x$, $y$, $s$, and $t$.\n-/\ntheorem challenge_comm_assoc : (x + y) + (s + t) = (y + (t + s)) + x :=\nbegin\n", "proof": "  calc (x + y) + (s + t) = (x + y) + (t + s) : congr_arg _ (add_comm s t)\n  ... = x + (y + (t + s)) : add_assoc _ _ _\n  ... = (y + (t + s)) + x : add_comm _ _,\n\n\n\n\n", "proof_hint": "sorry", "textAfter": "\nend\n\n\n\nend exlean -- hide\n\n\n", "height": 8, "editorText": "sorry", "lineOffset": 37, "name": "challenge_comm_assoc", "statement": "(x + y) + (s + t) = (y + (t + s)) + x"}, {"type": "lean", "content": "158", "hidden": true}]}, {"name": "", "problemIndex": 16, "objects": [{"type": "lean", "content": "159", "hidden": true}, {"type": "text", "content": "160"}, {"type": "lean", "content": "161", "hidden": true}, {"type": "lean", "content": "162", "hidden": true}, {"type": "text", "content": "163"}, {"type": "text", "content": "164"}, {"type": "lean", "content": "165", "hidden": true}, {"type": "lean", "content": "166", "hidden": false}, {"type": "tactic", "content": "167", "name": "rw", "sideBar": true}, {"type": "text", "content": "168"}, {"type": "lean", "content": "169", "hidden": false}, {"type": "text", "content": "170"}, {"type": "lean", "content": "171", "hidden": false}, {"type": "text", "content": "172"}, {"type": "text", "content": "173"}, {"type": "lean", "content": "174", "hidden": true}, {"type": "theorem", "text": "175", "lean": "theorem add_right_comm : (x + y) + z = (x + z) + y :=\n", "sideBar": false, "firstProofLineNumber": 101, "firstProofHintLineNumber": 107, "lastProofHintLineNumber": 108, "lastProofLineNumber": 110, "textBefore": "import equations.challenge tactic.pure_maths -- hide\n\n/- \n# Equations\n\n## Level 13 : Backward proof and the `rw` tactic\n-/\n\n\nnamespace exlean -- hide\n\nopen_locale mynum -- hide\n\n/-\nLet's give a backward proof of $x + (y + z) = (z + y) + x$.\n\n**Proof**:\n$$\n\\begin{align}\n&& x + (y + z) & = (z + y) + x & &  \\\\\\\\\n&\\iff & x + (z + y)& = (z + y) + x & & \\text{[by commutativity of addition on $y$ and $z$]} \\\\\\\\\n&\\iff & (z + y) + x&= (z + y) + x. & & \\text{[by commutativity of addition on $x$ and $z + y$]}\n\\end{align}\n$$\nThe last line follows by reflexivity. \u220e\n-/\n\n/-\nHere is a Lean proof of this result.\n-/\nvariables (x y z : \u2115) -- hide\n\nexample : x + (y + z) = (z + y) + x :=\nbegin [pure_maths]\n  show x + (y + z) = (z + y) + x,   rw add_comm y z,\n  show x + (z + y) = (z + y) + x,   rw add_comm x (z + y),\n  show (z + y) + x = (z + y) + x,   from rfl,\nend\n\n/- Tactic : rw\nIf `h` is an equation of the form `p = q`, `rw h` rewrites replaces `p` in the target with `q`.\n\nIf `k` is in the context, `rw h at k` performs the rewrite at `k` instead of at the target.\n\n`rw \u2190h` will rewrite backward: every occurrence of `q` is replaced with `p`. Type `\\l` to produce `\u2190`.\n\n`rw [h1, h2, h3]` rewrites with multiple hypotheses (you aren't limited to three)!\n-/\n\n/-\nIn this proof, `rw` is short for `rewrite` and the expression `rw add_comm y z` is the Lean\nversion of the handwritten, 'by commutativity of addition on $y$ and $z$'. The only difference\nis that each `rw` appears one line above where it would in a handwritten proof.\n\nIn general, if you use `rw h` where `h : a = b`, then Lean\nwill look for every instance of `a` in the target and replace it with `b`.\n\n\n\n## Task\nThere are many ways to prove a given theorem. Below is a different backward proof of our result.\nConvert this Lean proof into a handwritten proof.\n-/\n\n\nexample : x + (y + z) = (z + y) + x :=\nbegin [pure_maths] \n  show x + (y + z) = (z + y) + x,   rw add_comm (z + y) x,\n  show x + (y + z) = x + (z + y),   rw add_comm y z,\n  show x + (z + y) = x + (z + y),   from rfl,\nend\n\n/-\nThe use of `show` isn't required by Lean. Moreover, multiple applications of `rw` can\nbe combined on one line, as shown below. However, this translates poorly to handwritten proofs.\n-/\n\nexample : x + (y + z) = (z + y) + x:=\nbegin [pure_maths]\n  rw [add_comm y z, add_comm], from rfl,\nend\n/-\n\n-/\n\n/-\n## Task \nGiven a backward of the theorem `add_right_comm` that you first encounterd in the transitivity level.\nI've provided you with a suggested first line.\n\nThe old `add_right_comm` result is unavailable for use in your proof!\n-/\n\nnamespace hidden -- hide\n\n/- Theorem : no-side-bar\n$(x + y) + z = (x + z) + y$, for all natural numbers $x$, $y$, and $z$.\n-/\ntheorem add_right_comm : (x + y) + z = (x + z) + y :=\nbegin[pure_maths]\n", "proof": "  show (x + y) + z = (x + z) + y,   rw add_assoc,\n  show x + (y + z) = (x + z) + y,   rw add_assoc,\n  show x + (y + z) = x + (z + y),   rw add_comm y z,\n  show x + (z + y) = x + (z + y),   from rfl,\n\n/- hint\nshow (x + y) + z = (x + z) + y,   rw add_assoc,\nsorry,\n-/\n  ", "proof_hint": "show (x + y) + z = (x + z) + y,   rw add_assoc,\nsorry,", "textAfter": "\nend\n\nend hidden -- hide\n\n\nend exlean -- hide\n\n\n", "height": 10, "editorText": "show (x + y) + z = (x + z) + y,   rw add_assoc,\nsorry,", "lineOffset": 100, "name": "add_right_comm", "statement": "(x + y) + z = (x + z) + y"}, {"type": "lean", "content": "176", "hidden": true}, {"type": "lean", "content": "177", "hidden": true}]}, {"name": "", "problemIndex": 10, "objects": [{"type": "lean", "content": "178", "hidden": true}, {"type": "text", "content": "179"}, {"type": "lean", "content": "180", "hidden": true}, {"type": "lean", "content": "181", "hidden": true}, {"type": "text", "content": "182"}, {"type": "lean", "content": "183", "hidden": true}, {"type": "lean", "content": "184", "hidden": false}, {"type": "text", "content": "185"}, {"type": "text", "content": "186"}, {"type": "hint", "content": "187", "title": "188"}, {"type": "theorem", "text": "189", "lean": "theorem challenge2 : x + ((y + z) + z) = ((z + z) + x) + y:=\n", "sideBar": false, "firstProofLineNumber": 56, "firstProofHintLineNumber": 63, "lastProofHintLineNumber": 65, "lastProofLineNumber": 68, "textBefore": "import equations.challenge tactic.pure_maths -- hide\n\n/- \n# Equations\n\n## Level 14 : Easy calculation proofs using `rw`\n-/\n\nnamespace exlean -- hide\n\nopen_locale mynum -- hide\n\n/-\nThe idea of 'replacing equals with equals' can lead to simpler proofs. Using this idea,\nwe present a proof of the result from the challenge level.\n-/\n\nvariables (x y z s t: \u2115) -- hide\n\nexample : (x + y) + (s + t) = (y + (t + s)) + x :=\nbegin\n  calc\n  (x + y) + (s + t) = (x + y) + (t + s) : by rw add_comm s t\n                ... = x + (y + (t + s)) : by rw add_assoc\n                ... = (y + (t + s)) + x : by rw add_comm,\nend\n\n/-\nIn each line of justification above, the word `by` announces that we are to provide Lean with a \ntactic proof.\n\nThus, `rw add_comm s t` is a tactic proof of `(x + y) + (s + t) = (x + y) + (t + s)`.\n-/\n\n/-\n## Task\n\nComplete the proof below. To do this, replace the `_` with an expression, add extra lines of calculation,\nand replace the `sorry` with a final justification.\n-/\n\n/- Hint : Problems with applying `add_assoc` or `add_comm`?\nIf you try `add_comm` (or `add_assoc`) and Lean doesn't do what you expect, you may need\nto be more precise about what you want to add `add_comm` to.\n\nFor example, to justify the line `a + (b + c) = a + (c + b)` requires `rw add_comm b c`\n(or `rw add_comm b`). The problem is that `rw add_comm` by itself transforms \n`a + (b + c)` into `(b + c) + a`.\n-/\n\n/- Theorem : no-side-bar\n$x + ((y + z) + z) = ((z + z) + x) + y$, for all natural numbers $x$, $y$, and $z$.\n-/\ntheorem challenge2 : x + ((y + z) + z) = ((z + z) + x) + y:=\nbegin[pure_maths]\n", "proof": "  calc\n  x + ((y + z) + z) = ((y + z) + z) + x : by rw add_comm\n                ... = (y + (z + z)) + x : by rw add_assoc y\n                ... = y + ((z + z) + x) : by rw add_assoc\n                ... = (z + z) + x + y   : by rw add_comm,\n\n/- hint\ncalc\nx + ((y + z) + z) = _                 : by rw add_comm\n              ... = (z + z) + x + y   : sorry,\n-/\n\n  ", "proof_hint": "calc\nx + ((y + z) + z) = _                 : by rw add_comm\n              ... = (z + z) + x + y   : sorry,", "textAfter": "\nend\n\nend exlean -- hide\n\n\n", "height": 13, "editorText": "calc\nx + ((y + z) + z) = _                 : by rw add_comm\n              ... = (z + z) + x + y   : sorry,", "lineOffset": 55, "name": "challenge2", "statement": "x + ((y + z) + z) = ((z + z) + x) + y"}, {"type": "lean", "content": "190", "hidden": true}]}, {"name": "", "problemIndex": 7, "objects": [{"type": "lean", "content": "191", "hidden": true}, {"type": "text", "content": "192"}, {"type": "lean", "content": "193", "hidden": true}, {"type": "lean", "content": "194", "hidden": true}, {"type": "text", "content": "195"}, {"type": "lean", "content": "196", "hidden": false}, {"type": "text", "content": "197"}, {"type": "theorem", "text": "198", "lean": "theorem ymca (x y z : \u2115)\n  : (y + x) + (0 + z + 0) + (0 + x + 0) = y + (z + (x + x)) :=\n", "sideBar": false, "firstProofLineNumber": 43, "lastProofLineNumber": 57, "textBefore": "import equations.rewrite_calc-- hide\n\n/- \n# Equations\n\n## Level 15 : The simplifier\n-/\n\nnamespace exlean -- hide\n\nopen_locale mynum -- hide\n\n/-\nThis level introduces a powerful new tactic, `simp`, Lean's simplifier. It rewrites \nrepeatedly using either supplied theorems & hypotheses or theorems that it 'knows'.\n\nTo suggest theorems and hypotheses for use with `simp`, provide them as a comma-separated list.\nIn the example below, we supply `simp` with `add_assoc` and `add_comm y x`.\n\nWithout `simp`, you'd need several applications of `rw add_assoc`. \n-/\n\nexample (x y z : \u2115) : x + ((y + z) + x) = (y + x) + (z + x) :=\nbegin\n  simp [add_assoc, add_comm y x],\nend\n\n/-\n## Tasks\n\n* Prove the result below using only `simp` with supplied theorems, as in the example above. You should\nonly need to supply two theorems.\n\n* For fun (!) try proving this result using `rw`. Which proof do you prefer?\n-/\n\n/- Theorem : no-side-bar\nLet `x`, `y`, and `z` be natural numbers. Then `(y + x) + (0 + z + 0) + (0 + x + 0) = y + (z + (x + x))`.\n-/\ntheorem ymca (x y z : \u2115)\n  : (y + x) + (0 + z + 0) + (0 + x + 0) = y + (z + (x + x)) :=\nbegin\n", "proof": "  --simp [add_assoc, add_comm x z, add_zero, zero_add],\n  rw [add_zero, add_zero, zero_add, zero_add, add_assoc y x z, add_assoc,\n    add_right_comm, add_comm _ z],\n\n\n\n\n\n\n\n\n\n\n\n", "proof_hint": "sorry", "textAfter": "\nend\n\n/- Tactic : simp\nThe `simp` tactic rewrites repeatedly using either supplied theorems & hypotheses or theorems\nthat it 'knows'.\n\nTo suggest theorems and hypotheses for use with `simp`, provide them as a comma-separated list.\nFor example `simp [h, add_comm]` rewrites repeatedly with hypotheses `h` and theorem `add_comm`.\n-/\n\n\nend exlean -- hide\n\n\n", "height": 15, "editorText": "sorry", "lineOffset": 42, "name": "ymca", "statement": "(x y z : \u2115)\n  : (y + x) + (0 + z + 0) + (0 + x + 0) = y + (z + (x + x))"}, {"type": "tactic", "content": "199", "name": "simp", "sideBar": true}, {"type": "lean", "content": "200", "hidden": true}]}]}, {"name": "201", "levels": [{"name": "", "problemIndex": 19, "objects": [{"type": "lean", "content": "202", "hidden": true}, {"type": "lean", "content": "203", "hidden": true}, {"type": "lean", "content": "204", "hidden": true}, {"type": "lean", "content": "205", "hidden": true}, {"type": "lean", "content": "206", "hidden": true}, {"type": "text", "content": "207"}, {"type": "lean", "content": "208", "hidden": false}, {"type": "text", "content": "209"}, {"type": "lean", "content": "210", "hidden": false}, {"type": "text", "content": "211"}, {"type": "axiom", "content": "212", "name": "evenb_O :", "sideBar": true}, {"type": "lean", "content": "213", "hidden": false}, {"type": "axiom", "content": "214", "name": "evenb_S (n : \u2115) :", "sideBar": true}, {"type": "lean", "content": "215", "hidden": false}, {"type": "text", "content": "216"}, {"type": "lean", "content": "217", "hidden": false}, {"type": "text", "content": "218"}, {"type": "lean", "content": "219", "hidden": false}, {"type": "text", "content": "220"}, {"type": "theorem", "text": "221", "lean": "theorem evenb_two : evenb(S(S(O))) = tt :=\n", "sideBar": false, "firstProofLineNumber": 102, "firstProofHintLineNumber": 108, "lastProofHintLineNumber": 110, "lastProofLineNumber": 111, "textBefore": "import mynat.basic tactic.pure_maths -- hide\n\nset_option pp.structure_projections false -- hide\n\nnamespace exlean -- hide\n\nopen_locale mynum -- hide\n\nopen mynat -- hide\n\n/-\n# Natural numbers\n\n## Level 1: A boolen evenness function\n\nIn this world, a natural number is either `O` (the capital letter `O`) or\n`S(k)`, where `k` is a natural number. The successor function `S` can be thought of\nas 'returning' the number `S(k)` that comes after `k`.\n\nThe number we call $2$ can be written with this definition as `S(S(O))` or `S(S O)`.\n-/\n\nexample : \u2115 := O \n\nexample : \u2115 := S O \n\nexample : \u2115 := S(S(O))\n\nexample : \u2115 := S(S(S O))\n\n/-\n\nTo define a function on `\u2115` is to give its value at `O` and to specify how its\nvalue at `S(k)` depends on its value at `k`.\n\nWe define a function `evenb` such that `evenb(n)` is `tt` (true) if `n` is even and is\n`ff` (false) otherwise. In the following recursive definition of `evenb`, the symbol `!`\nrepresents the Boolean 'not' function, defined so that `!(tt) := ff` and `!(ff) := tt`.\n-/\n\n\ndef evenb : \u2115 \u2192 bool\n| O     := tt\n| (S k) := !(evenb k)\n\n/-\nBy definition of `evenb`, we extract two lemmas. The first, `evenb_O`, asserts\n`evenbO = tt`. The second, `evenb_S`, asserts that `evenb(S(n)) = !(evenb(n))`.\n-/\n\n/- Axiom : evenb_O :\nevenb(O) = tt\n-/\nlemma evenb_O : evenb O = tt := rfl\n\n/- Axiom : evenb_S (n : \u2115) :\nevenb (S(n)) = !(evenb n)\n-/\nlemma evenb_S (n : \u2115) : evenb (S n) = !(evenb n) := rfl\n\n/-\nUsing these two lemmas, we give a proof by calculation that 3 is not even. More precisely,\nthat `evenb(S(S(S(O)))) = ff`.\n-/\n\nexample : evenb(S(S(S(O)))) = ff :=\nbegin\n  calc\n  evenb(S(S(S(O)))) = !evenb((S(S(O)))) : by rw evenb_S\n                ... = !!evenb(S O)      : by rw evenb_S\n                ... = !!!evenb(O)       : by rw evenb_S\n                ... = !!!tt             : by rw evenb_O\n                ... = ff                : rfl,\nend\n\n/-\nIn fact, as each step of the proof above involves an application of a definition, the\nresult holds by reflexivity.\n-/\n\nexample : evenb(S(S(S(O)))) = ff :=\nbegin\n  from rfl,\nend\n\n/-\n## Task\n\nComplete the proof by calculation that 2 is even. You'll need\nadditional lines of calculation.\n\nOnce you've done this, check that `from rfl,` suffices\nas a one-line proof.\n-/\n\n\n/- Theorem : no-side-bar\nThat $2$ is even has value 'true'.\n-/\ntheorem evenb_two : evenb(S(S(O))) = tt :=\nbegin [pure_maths]\n", "proof": "  calc\n  evenb(S(S(O)))  = !evenb(S(O))  : by rw evenb_S\n              ... = !!evenb(O)    : by rw evenb_S\n              ... = !!tt          : by rw evenb_O\n              ... = tt            : rfl,\n/- hint\n  calc\n  evenb(S(S(O)))  = !evenb(S(O))  : sorry\n              ... = tt            : sorry,\n-/", "proof_hint": "  calc\n  evenb(S(S(O)))  = !evenb(S(O))  : sorry\n              ... = tt            : sorry,", "textAfter": "\nend\n\nend exlean -- hide", "height": 10, "editorText": "  calc\n  evenb(S(S(O)))  = !evenb(S(O))  : sorry\n              ... = tt            : sorry,", "lineOffset": 101, "name": "evenb_two", "statement": "evenb(S(S(O))) = tt"}, {"type": "lean", "content": "222", "hidden": true}]}, {"name": "", "problemIndex": 16, "objects": [{"type": "lean", "content": "223", "hidden": true}, {"type": "lean", "content": "224", "hidden": true}, {"type": "lean", "content": "225", "hidden": true}, {"type": "lean", "content": "226", "hidden": true}, {"type": "lean", "content": "227", "hidden": true}, {"type": "text", "content": "228"}, {"type": "axiom", "content": "229", "name": "add_O (n : \u2115) :", "sideBar": true}, {"type": "axiom", "content": "230", "name": "add_S (m n : \u2115) :", "sideBar": true}, {"type": "text", "content": "231"}, {"type": "lean", "content": "232", "hidden": false}, {"type": "text", "content": "233"}, {"type": "lean", "content": "234", "hidden": false}, {"type": "text", "content": "235"}, {"type": "axiom", "content": "236", "name": "S_eq_add_one (n : \u2115) :", "sideBar": true}, {"type": "lean", "content": "237", "hidden": false}, {"type": "text", "content": "238"}, {"type": "theorem", "text": "239", "lean": "theorem one_add_two : (S O) + (S(S(O))) = S(S(S(O))) :=\n", "sideBar": false, "firstProofLineNumber": 87, "firstProofHintLineNumber": 92, "lastProofHintLineNumber": 94, "lastProofLineNumber": 95, "textBefore": "import natural_numbers.evenb -- hide\n\nset_option pp.structure_projections false -- hide\n\nnamespace exlean -- hide\n\nopen_locale mynum -- hide\n\nopen mynat -- hide\n\n/-\n# Natural numbers\n\n## Level 2: The definition of addition\n\nOur addition function is defined so that for every natural number `m`, we have\n`m + O = m` and `m + (S n) = S(m + n)`, for every natural number `n`.\n\nThese definitions are available as the theorems `add_O` and `add_S`:\n\n`add_O (m : \u2115) : m + O = m`\n\n`add_S (m n : \u2115) : m + (S n) = S(m + n)`\n-/\n\n/- Axiom : add_O (n : \u2115) :\nn + O = n\n-/\n\n/- Axiom : add_S (m n : \u2115) :\nm + (S n) = S(m + n)\n-/\n\n/-\nUsing these two lemmas, we give a proof by calculation that `(S O) + (S O) = S(S(O))`,\nthat is, that $1 + 1 = 2$.\n-/\n\nexample : (S O) + (S O) = S(S(O)) :=\nbegin\n  calc\n  (S O) + (S O) = S((S O) + O)  : by rw add_S\n            ... = S(S(O))       : by rw add_O\nend\n\n/-\nAs in the previous level, both sides are *definitionally* equal to `S(S(O))`, thus\nthe result could, more easily, be proved by reflexivity.\n-/\n\nexample : (S O) + (S O) = S(S(O)) :=\nbegin\n  from rfl,\nend\n\n/-\nAs another example, we prove that `S(n) = n + (S O)`, effectively that\n$\\mathsf{S}(n) = n + 1$.\n-/\n\n/- Axiom : S_eq_add_one (n : \u2115) :\nS n = n + (S O)\n-/\nlemma S_eq_add_one (n : \u2115) : S n = n + (S O) :=\nbegin [pure_maths]\n  show S n = n + (S O), rw add_S,\n  show S n = S(n + O),  rw add_O,\n  show S n = S n, from rfl,\nend\n\n/-\n## Task\n\nComplete the proof by calculation that $1 + 2 = 3$. You'll need\nadditional lines of calculation.\n\nOnce you've done this, check that `from rfl,` suffices\nas a one-line proof.\n-/\n\n\n/- Theorem : no-side-bar\n$1 + 2 = 3$.\n-/\ntheorem one_add_two : (S O) + (S(S(O))) = S(S(S(O))) :=\nbegin [pure_maths]\n", "proof": "  calc\n  (S O) + (S(S(O))) = S((S O) + S(O)) : by rw add_S\n                ... = S(S((S O) + O)) : by rw add_S\n                ... = S(S(S(O)))      : by rw add_O\n/- hint\n  calc\n  (S O) + (S(S(O))) = S((S O) + S(O)) : sorry\n                ... = S(S(S(O)))      : sorry,\n-/", "proof_hint": "  calc\n  (S O) + (S(S(O))) = S((S O) + S(O)) : sorry\n                ... = S(S(S(O)))      : sorry,", "textAfter": "\nend\n\nend exlean -- hide", "height": 9, "editorText": "  calc\n  (S O) + (S(S(O))) = S((S O) + S(O)) : sorry\n                ... = S(S(S(O)))      : sorry,", "lineOffset": 86, "name": "one_add_two", "statement": "(S O) + (S(S(O))) = S(S(S(O)))"}, {"type": "lean", "content": "240", "hidden": true}]}, {"name": "", "problemIndex": 19, "objects": [{"type": "lean", "content": "241", "hidden": true}, {"type": "lean", "content": "242", "hidden": true}, {"type": "lean", "content": "243", "hidden": true}, {"type": "lean", "content": "244", "hidden": true}, {"type": "lean", "content": "245", "hidden": true}, {"type": "text", "content": "246"}, {"type": "text", "content": "247"}, {"type": "text", "content": "248"}, {"type": "tactic", "content": "249", "name": "induction", "sideBar": true}, {"type": "axiom", "content": "250", "name": "O_add (n : \u2115) :", "sideBar": true}, {"type": "lean", "content": "251", "hidden": false}, {"type": "lean", "content": "252", "hidden": true}, {"type": "lean", "content": "253", "hidden": false}, {"type": "lean", "content": "254", "hidden": true}, {"type": "lean", "content": "255", "hidden": false}, {"type": "text", "content": "256"}, {"type": "lean", "content": "257", "hidden": false}, {"type": "text", "content": "258"}, {"type": "hint", "content": "259", "title": "260"}, {"type": "theorem", "text": "261", "lean": "theorem S_eq_one_add (n : \u2115) : S(n) = S(O) + n :=\n", "sideBar": true, "firstProofLineNumber": 128, "firstProofHintLineNumber": 140, "lastProofHintLineNumber": 146, "lastProofLineNumber": 147, "textBefore": "import natural_numbers.addition -- hide\n\nset_option pp.structure_projections false -- hide\n\nnamespace exlean -- hide\n\nopen_locale mynum -- hide\n\nopen mynat -- hide\n\n/-\n# Natural numbers\n\n## Level 3: Induction and `S_eq_one_add`\n\nLet $P$ be a predicate on $\\mathbb N$. To prove that $P(n)$ holds for every natural number $n$\nis to:\n1. [base case] prove $P(\\mathsf{O})$ and\n2. [inductive step] prove that for every $k : \\mathbb N$, $P(\\mathsf S(k))$ follows from the *induction hypothesis*,\nthe assumption of $P(k)$.\n\nThis is called *proof by induction*.\n-/\n\n/-\nVia proof by induction, one may prove $\\mathsf O + n = n$, for every $n : \\mathbb N$. Here, the\npredicate $P$ is given by $P(n) := \\mathsf O + n = n$.\n\n**Proof**:\n1. [Base case] We must show $P(\\mathsf O)$. That is, $\\mathsf O + \\mathsf O = \\mathsf O$. This follows by definition of\naddition.\n\n2. [Inductive step] Let $k$ be a natural number. Assume the induction hypothesis $h : P(k)$, which is\n$\\mathsf O + k = k$. We must show $P(\\mathsf S(k))$, i.e. $\\mathsf O + \\mathsf S(k) = \\mathsf S(k)$.\nBut\n$$\n\\begin{align}\n\\mathsf O + \\mathsf S(k) & = \\mathsf S(\\mathsf O + k) && \\text{[by definition of addition]} \\\\\\\\\n&= \\mathsf S(k). & & \\text{[by  $h$]}\n\\end{align}\n$$\n\nThe result follows by induction. \u220e \n-/\n\n/-\nThe same result is proved in Lean below. Here, `induction n` marks the start of the proof. The base case is\nindicated with `case O` and the inductive step with `case S`.\n\nThe base case is the proof of `P(O)`. That is, the proof of `O + O = O`. This holds by\ndefinition of addition, and hence by reflexivity.\n\nIn the inductive step, the quantities `k` and `h` in `case S : k h` are the induction variable\nand induction hypothesis, respectively. We must show `P(S(k))`, i.e. `O + S(k) = S(k)`,\ngiven the induction hypothesis: the assumption of `P(k)`, i.e.\nof `O + k = k`.\n-/\n\n/- Tactic : induction\nTo prove `P(n)` holds for all `n : \u2115`, use the `induction n`. This opens up two new goals:\n(1) to prove `P(O)` and (2) to prove `P(S(k))` on the assumption of `P(k)`.\n\nTo specify the names of the induction variable (say `k`) and induction hypothesis (say `h`)\nyou can either use the form `induction with k h` or you can tag the induction step with\n`case S : k h`.\n-/\n\n\n/- Axiom : O_add (n : \u2115) :\nO + n = n\n-/\n@[simp] lemma O_add (n : \u2115) : O + n = n :=\nbegin\n  induction n,\n  -- hide\n  case O :\n  { show O + O = O, from rfl, },\n  -- hide\n  case S : k h\n  { show O + S(k) = S(k),\n    given h : O + k = k,\n    calc\n    O + S(k)  = S(O + k)  : by rw add_S\n          ... = S(k)      : by rw h, },\nend\n\n/-\nAs an aside, note that I've tagged the theorem above with `@[simp]`. This\nmeans that the `simp` tactic will automatically call on `O_add` whenever applicable, as in\nthe proof below.\n-/\n\nexample (n : \u2115) : (O + (O + n)) + O  = n :=\nbegin\n  simp,\nend\n\n/-\n## Task\n\nComplete the following proof by induction, following the template given by the proof of `O_add`\nabove. Note you have to separately proof the base case and the inductive step.\n-/\n\n/- Hint : A proof template\nIf you're not sure how to start, begin with the following template. The `sorry` in the inductive\nstep can be filled in with a proof by calculation, as above.\n```\ninduction n,\n\ncase O :\n{ show S(O) = S(O) + O, sorry, },\n\ncase S : k h\n{ show S(S(k)) = S(O) + S(k),\n  given h : S(k) = S(O) + k,\n  sorry, },\n```\n\n-/\n\n/- Theorem :\nFor every natural number $n$, we have $\\mathsf S(n) = \\mathsf S(\\mathsf O) + n$. That is,\n$\\mathsf S(n) = 1 + n$.\n-/\ntheorem S_eq_one_add (n : \u2115) : S(n) = S(O) + n :=\nbegin [pure_maths]\n", "proof": "  induction n,\n\n  case O :\n  { show S(O) = S(O) + O, from rfl, },\n\n  case S : k h\n  { show S(S(k)) = S(O) + S(k),\n    given h : S(k) = S(O) + k,\n    calc\n    S(S(k)) = S(S(O) + k) : by rw h\n        ... = S(O) + S(k) : rfl, },\n/- hint\n  induction n,\n\n  case O :\n  { sorry, },\n\n  case S : k h\n  { sorry, },\n-/", "proof_hint": "  induction n,\n\n  case O :\n  { sorry, },\n\n  case S : k h\n  { sorry, },", "textAfter": "\nend\n\nend exlean -- hide", "height": 20, "editorText": "  induction n,\n\n  case O :\n  { sorry, },\n\n  case S : k h\n  { sorry, },", "lineOffset": 127, "name": "S_eq_one_add", "statement": "(n : \u2115) : S(n) = S(O) + n"}, {"type": "lean", "content": "262", "hidden": true}]}, {"name": "", "problemIndex": 8, "objects": [{"type": "lean", "content": "263", "hidden": true}, {"type": "lean", "content": "264", "hidden": true}, {"type": "lean", "content": "265", "hidden": true}, {"type": "lean", "content": "266", "hidden": true}, {"type": "lean", "content": "267", "hidden": true}, {"type": "text", "content": "268"}, {"type": "hint", "content": "269", "title": "270"}, {"type": "hint", "content": "271", "title": "272"}, {"type": "theorem", "text": "273", "lean": "theorem S_add (m n : \u2115) : S(m) + n = S(m + n) :=\n", "sideBar": true, "firstProofLineNumber": 59, "firstProofHintLineNumber": 72, "lastProofHintLineNumber": 78, "lastProofLineNumber": 79, "textBefore": "import natural_numbers.S_eq_one_add -- hide\n\nset_option pp.structure_projections false -- hide\n\nnamespace exlean -- hide\n\nopen_locale mynum -- hide\n\nopen mynat -- hide\n\n/-\n# Natural numbers\n\n## Level 4: `S_add`\n\nIn this level, you'll prove a result that depends on two variables $m$ and $n$ by fixing $m$\nand performing induction on $n$.\n\n## Task\n\nComplete the following proof by induction.\n-/\n\n/- Hint : A proof template\nIf you're not sure how to start, begin with the following template. The `sorry` in the inductive\nstep can be filled in with a proof by calculation, as above.\n```\ninduction n,\n\ncase O :\n{ show S m + O = S(m + O), sorry, },\n\ncase S : k h\n{ show S(m) + S(k) = S(m + S(k)),\n  given h : S(m) + k = S(m + k),\n  sorry, },\n```\n-/\n\n/- Hint : A cheap proof using `simp`\nIf you used the proof template above, the goal of the inductive step is\n```\n m k : \u2115,\n h : S m + k = S (m + k)\n \u22a2 S m + S k = S (m + S k)\n```\nTo help you understand proof by induction, I recommend using a proof by calculation here.\nHowever, Lean can partially automate the construction of a proof using the `simp` tactic. Here,\n`simp [add_S, h]` proves the inductive step. It tells Lean to use `add_S` and the inductive\nhypothesis `h` (and any other lemma marked with the `simp` attribute) as many times as necesary\nand in whatever order until a proof is found or no further simplification is possible.\n-/\n\n/- Theorem :\nFor all natural numbers $m$ and $n$, we have $\\mathsf S(m) + n = \\mathsf S(m + n)$.\n-/\ntheorem S_add (m n : \u2115) : S(m) + n = S(m + n) :=\nbegin [pure_maths]\n", "proof": "  induction n,\n\n  case O :\n  { show S m + O = S(m + O), from rfl, },\n\n  case S : k h\n  { show S(m) + S(k) = S(m + S(k)), \n    given h : S(m) + k = S(m + k),\n    calc\n    S(m) + S(k) = S(S(m) + k) : by rw add_S\n            ... = S(S(m + k)) : by rw h\n            ... = S(m + S(k)) : by rw add_S, },\n/- hint\n  induction n,\n\n  case O :\n  { sorry, },\n\n  case S : k h\n  { sorry, },\n-/", "proof_hint": "  induction n,\n\n  case O :\n  { sorry, },\n\n  case S : k h\n  { sorry, },", "textAfter": "\nend\n\nend exlean -- hide", "height": 21, "editorText": "  induction n,\n\n  case O :\n  { sorry, },\n\n  case S : k h\n  { sorry, },", "lineOffset": 58, "name": "S_add", "statement": "(m n : \u2115) : S(m) + n = S(m + n)"}, {"type": "lean", "content": "274", "hidden": true}]}, {"name": "", "problemIndex": 13, "objects": [{"type": "lean", "content": "275", "hidden": true}, {"type": "lean", "content": "276", "hidden": true}, {"type": "lean", "content": "277", "hidden": true}, {"type": "lean", "content": "278", "hidden": true}, {"type": "lean", "content": "279", "hidden": true}, {"type": "text", "content": "280"}, {"type": "lean", "content": "281", "hidden": false}, {"type": "text", "content": "282"}, {"type": "axiom", "content": "283", "name": "double_O :", "sideBar": true}, {"type": "lean", "content": "284", "hidden": false}, {"type": "axiom", "content": "285", "name": "double_S (n : \u2115) :", "sideBar": true}, {"type": "lean", "content": "286", "hidden": false}, {"type": "text", "content": "287"}, {"type": "theorem", "text": "288", "lean": "theorem double_eq_add_self (n : \u2115) : double(n) = n + n :=\n", "sideBar": true, "firstProofLineNumber": 53, "firstProofHintLineNumber": 67, "lastProofHintLineNumber": 73, "lastProofLineNumber": 74, "textBefore": "import natural_numbers.S_add -- hide\n\nset_option pp.structure_projections false -- hide\n\nnamespace exlean -- hide\n\nopen_locale mynum -- hide\n\nopen mynat -- hide\n\n/-\n# Natural numbers\n\n## Level 5: Doubling\n\nThe function `double` from `\u2115` to `\u2115` is defined so that `double(O) := O` and\n`double(S(k)) = S(S(double(k)))`. It corresponds to the ordinary notion of doubling a natural\nnumber.\n-/\n\ndef double : \u2115 \u2192 \u2115\n| O     := O\n| (S k) := S (S (double k))\n\n\n/-\nThe definition equations of `double` give two results, by reflexivity.\n-/\n\n/- Axiom : double_O :\ndouble(O) = O\n-/\nlemma double_O : double(O) = O := rfl\n\n/- Axiom : double_S (n : \u2115) :\ndouble(S(n)) = S(S(double(n)))\n-/\n\nlemma double_S (n : \u2115) : double(S(n)) = S(S(double(n))) := rfl\n\n/-\n## Task\n\nComplete the following proof by induction. Use the results `double_O` and `double_S` above\ntogether with any relevant results from previous levels in this world.\n-/\n\n/- Theorem :\nFor every natural number $n$, we have $\\mathsf{double}(n) = n + n$.\n-/\ntheorem double_eq_add_self (n : \u2115) : double(n) = n + n :=\nbegin [pure_maths]\n", "proof": "  induction n,\n\n  case O :\n  { show double(O) = O + O, from rfl, },\n\n  case S : k h\n  { show double(S(k)) = S(k) + S(k),\n    given h : double k = k + k,\n    calc\n    double(S(k))  = S(S(double(k))) : by rw double_S\n              ... = S(S(k + k))     : by rw h\n              ... = S(k + S(k))     : by rw add_S\n              ... = S(k) + S(k)     : by rw S_add },\n/- hint\n  induction n,\n\n  case O :\n  { sorry, },\n\n  case S : k h\n  { sorry, },\n-/", "proof_hint": "  induction n,\n\n  case O :\n  { sorry, },\n\n  case S : k h\n  { sorry, },", "textAfter": "\nend\n\nend exlean -- hide", "height": 22, "editorText": "  induction n,\n\n  case O :\n  { sorry, },\n\n  case S : k h\n  { sorry, },", "lineOffset": 52, "name": "double_eq_add_self", "statement": "(n : \u2115) : double(n) = n + n"}, {"type": "lean", "content": "289", "hidden": true}]}, {"name": "", "problemIndex": 8, "objects": [{"type": "lean", "content": "290", "hidden": true}, {"type": "lean", "content": "291", "hidden": true}, {"type": "lean", "content": "292", "hidden": true}, {"type": "lean", "content": "293", "hidden": true}, {"type": "lean", "content": "294", "hidden": true}, {"type": "text", "content": "295"}, {"type": "text", "content": "296"}, {"type": "hint", "content": "297", "title": "298"}, {"type": "theorem", "text": "299", "lean": "theorem add_comm (m n : \u2115) : m + n = n + m :=\n", "sideBar": true, "firstProofLineNumber": 34, "firstProofHintLineNumber": 49, "lastProofHintLineNumber": 55, "lastProofLineNumber": 56, "textBefore": "import natural_numbers.double_eq_add_self -- hide\n\nset_option pp.structure_projections false -- hide\n\nnamespace exlean -- hide\n\nopen_locale mynum -- hide\n\nopen mynat -- hide\n\n/-\n# Natural numbers\n\n## Level 6: Commutativity of addition\n-/\n\n/-\n## Task\n\nLet $m$ be a natural number. By induction on $n$, prove that $m + n = n + m$\nfor all natural numbers $n$.\n-/\n\n/- Hint : Proving the base case\nThis is the first level where the base case cannot be proved by reflexivity. Previously proved\nresults will come in handy here. See the 'Theorem statements' side bar on the left for inspiration.\n-/\n\n/- Theorem :\nFor all natural numbers $m$ and $n$, we have $m + n = n + m$.\n-/\ntheorem add_comm (m n : \u2115) : m + n = n + m :=\nbegin [pure_maths]\n", "proof": "  induction n,\n\n  case O :\n  { show m + O = O + m, calc\n    m + O = m     : by rw add_O\n      ... = O + m : by rw O_add, },\n\n  case S : k h\n  { show m + S(k) = S(k) + m,\n    given h : m + k = k + m,\n    calc\n    m + S(k)  = S(m + k) : by rw add_S\n          ... = S(k + m) : by rw h\n          ... = S(k) + m : by rw S_add, },\n/- hint\n  induction n,\n\n  case O :\n  { sorry, },\n\n  case S : k h\n  { sorry, },\n-/", "proof_hint": "  induction n,\n\n  case O :\n  { sorry, },\n\n  case S : k h\n  { sorry, },", "textAfter": "\nend\n\nend exlean -- hide", "height": 23, "editorText": "  induction n,\n\n  case O :\n  { sorry, },\n\n  case S : k h\n  { sorry, },", "lineOffset": 33, "name": "add_comm", "statement": "(m n : \u2115) : m + n = n + m"}, {"type": "lean", "content": "300", "hidden": true}]}, {"name": "", "problemIndex": 7, "objects": [{"type": "lean", "content": "301", "hidden": true}, {"type": "lean", "content": "302", "hidden": true}, {"type": "lean", "content": "303", "hidden": true}, {"type": "lean", "content": "304", "hidden": true}, {"type": "lean", "content": "305", "hidden": true}, {"type": "text", "content": "306"}, {"type": "text", "content": "307"}, {"type": "theorem", "text": "308", "lean": "theorem add_assoc (x y z : \u2115) : (x + y) + z = x + (y + z) :=\n", "sideBar": true, "firstProofLineNumber": 29, "firstProofHintLineNumber": 41, "lastProofHintLineNumber": 47, "lastProofLineNumber": 48, "textBefore": "import natural_numbers.add_comm -- hide\n\nset_option pp.structure_projections false -- hide\n\nnamespace exlean -- hide\n\nopen_locale mynum -- hide\n\nopen mynat -- hide\n\n/-\n# Natural numbers\n\n## Level 7: Associativity of addition\n-/\n\n/-\n## Task\n\nLet $x$ and $y$ be a natural numbers. By induction on $z$, prove that $(x + y) + z = x + (y + z)$\nfor all natural numbers $z$.\n-/\n\n/- Theorem :\nFor all natural numbers $x$, $y$, and $z$, we have $(x + y) + z = x + (y + z)$.\n-/\ntheorem add_assoc (x y z : \u2115) : (x + y) + z = x + (y + z) :=\nbegin [pure_maths]\n", "proof": "  induction z with k h,\n\n  case O :\n  { refl, },\n\n  case S : k h\n  { given h : (x + y) + k = x + (y + k),\n    show (x + y) + S(k) = x + (y + S(k)), calc\n    (x + y) + S(k)  = S((x + y) + k)    : by rw add_S\n                ... = S(x + (y + k))    : by rw h\n                ... = x + (y + (S(k)))  : rfl },\n/- hint\n  induction z,\n\n  case O :\n  { sorry, },\n\n  case S : k h\n  { sorry, },\n-/", "proof_hint": "  induction z,\n\n  case O :\n  { sorry, },\n\n  case S : k h\n  { sorry, },", "textAfter": "\nend\n\nend exlean -- hide", "height": 20, "editorText": "  induction z,\n\n  case O :\n  { sorry, },\n\n  case S : k h\n  { sorry, },", "lineOffset": 28, "name": "add_assoc", "statement": "(x y z : \u2115) : (x + y) + z = x + (y + z)"}, {"type": "lean", "content": "309", "hidden": true}]}, {"name": "", "problemIndex": 12, "objects": [{"type": "lean", "content": "310", "hidden": true}, {"type": "lean", "content": "311", "hidden": true}, {"type": "lean", "content": "312", "hidden": true}, {"type": "lean", "content": "313", "hidden": true}, {"type": "lean", "content": "314", "hidden": true}, {"type": "text", "content": "315"}, {"type": "text", "content": "316"}, {"type": "lean", "content": "317", "hidden": true}, {"type": "lean", "content": "318", "hidden": true}, {"type": "lean", "content": "319", "hidden": false}, {"type": "tactic", "content": "320", "name": "ac_refl", "sideBar": true}, {"type": "text", "content": "321"}, {"type": "theorem", "text": "322", "lean": "theorem easy_add :\n(v + (i + o)) + (l + (e + t)) = ((l + o) + (v + e)) + (i + t)  :=\n", "sideBar": false, "firstProofLineNumber": 65, "lastProofLineNumber": 65, "textBefore": "import natural_numbers.add_assoc algebra.group.defs -- hide\n\nset_option pp.structure_projections false -- hide\n\nnamespace exlean -- hide\n\nopen_locale mynum -- hide\n\nopen mynat -- hide\n\n/-\n# Natural numbers\n\n## Level 8: Easy addition with `ac_refl`\n-/\n\n/-\nIf you were asked to prove $(a + b) + (c + (b + a)) = (c + (b + b)) + (a + a)$ for all natural \nnumbers $a$, $b$, and $c$, you might say that the statement is clearly true, by rearranging.\n\nIf you were required to prove this step-by-step using the laws of commutativity and associativity\nof addition, it would be a pain.\n\nFortunately, Lean comes with a clever tactic called `ac_refl` that can creates proofs of any\nresult that can be justified solely by associativity, commutativity, and reflexivity.\n\nSince we've shown `+` is associative and commutative, we may use `ac_refl`.\n-/\n\n-- begin hide\ninstance : add_comm_monoid mynat :=\n{ add_assoc := add_assoc,\n  add_comm := add_comm,\n  zero_add := O_add,\n  add_zero := add_O,\n  .. }\n\n-- end hide\n\nvariables (a b c v i o l e t : \u2115) -- hide\n\nexample : (a + b) + (c + (b + a)) = (c + (b + b)) + (a + a) :=\nbegin\n  ac_refl,\nend\n\n/- Tactic : ac_refl\nThis tactic closes any goal that can be proved only by associativity, commutativity, and\nreflexivity.\n-/\n\n\n/-\n## Task\n\nUse `ac_refl` to prove the following.\n-/\n\n/- Theorem : no-side-bar\n$(v + (i + o)) + (l + (e + t)) = ((l + o) + (v + e)) + (i + t)$.\n-/\ntheorem easy_add :\n(v + (i + o)) + (l + (e + t)) = ((l + o) + (v + e)) + (i + t)  :=\nbegin [pure_maths]\n", "proof": "  ac_refl,", "proof_hint": "sorry", "textAfter": "\nend\n\nend exlean -- hide", "height": 1, "editorText": "sorry", "lineOffset": 64, "name": "easy_add", "statement": "(v + (i + o)) + (l + (e + t)) = ((l + o) + (v + e)) + (i + t)"}, {"type": "lean", "content": "323", "hidden": true}]}, {"name": "", "problemIndex": 12, "objects": [{"type": "lean", "content": "324", "hidden": true}, {"type": "lean", "content": "325", "hidden": true}, {"type": "lean", "content": "326", "hidden": true}, {"type": "lean", "content": "327", "hidden": true}, {"type": "lean", "content": "328", "hidden": true}, {"type": "text", "content": "329"}, {"type": "axiom", "content": "330", "name": "mul_O (n : \u2115) :", "sideBar": true}, {"type": "axiom", "content": "331", "name": "mul_S (m n : \u2115) :", "sideBar": true}, {"type": "text", "content": "332"}, {"type": "axiom", "content": "333", "name": "mul_one (n : \u2115) :", "sideBar": true}, {"type": "lean", "content": "334", "hidden": false}, {"type": "text", "content": "335"}, {"type": "theorem", "text": "336", "lean": "theorem mul_two (n : \u2115) : n * S(S(O)) = n + n :=\n", "sideBar": true, "firstProofLineNumber": 67, "firstProofHintLineNumber": 73, "lastProofHintLineNumber": 75, "lastProofLineNumber": 76, "textBefore": "import natural_numbers.easy_addition -- hide\n\nset_option pp.structure_projections false -- hide\n\nnamespace exlean -- hide\n\nopen_locale mynum -- hide\n\nopen mynat -- hide\n\n/-\n# Natural numbers\n\n## Level 9: Multiplication and `mul_two`\n\nThe multiplication function is defined so that for every natural number `m`, we have\n`m * O = O` and `m * (S n) = m * n + m`, for every natural number `n`.\n\nThese definitions are available as the theorems `mul_O` and `mul_S`:\n\n`mul_O (m : \u2115) : m * O = O`\n\n`mul_S (m n : \u2115) : m * (S n) = m * n + m`\n-/\n\n/- Axiom : mul_O (n : \u2115) :\nn * O = O\n-/\n\n/- Axiom : mul_S (m n : \u2115) :\nm * (S n) = m * n + m\n-/\n\n/-\nUsing these 'definitional' results, we'll prove $n \\times 1 = n$.\n-/\n\n/- Axiom : mul_one (n : \u2115) :\nn * S(O) = n\n-/\n@[simp] lemma mul_one (n : \u2115) : n * S(O) = n :=\nbegin\n  calc\n  n * S(O)  = n * O + n : by rw mul_S\n        ... = O + n     : by rw mul_O\n        ... = n         : by rw O_add,\nend\n\n/-\n## Task\n\nProve that $n \\times \\mathsf S(\\mathsf S(\\mathsf O)) = n + n$, for every natural number $n$.\nYou *do not* require induction for this proof. Give a proof by calculation using previously\nproved results.\n\nTo complete the proof, replace the `_` with an expression, add extra lines of calculation,\nand replace the `sorry` with a final justification.\n-/\n\n/- Theorem :\nFor every natural number $n$, we have $n \\times 2 = n + n$.\n-/\n\n\ntheorem mul_two (n : \u2115) : n * S(S(O)) = n + n :=\nbegin [pure_maths]\n", "proof": "  calc\n  n * S(S(O)) = n * S(O) + n    : by rw mul_S\n          ... = (n * O + n) + n : by rw mul_S\n          ... = (O + n) + n     : by rw mul_O\n          ... = n + n           : by rw O_add,\n/- hint\n  calc\n  n * S(S(O)) = _               : by rw mul_S\n          ... = n + n           : by sorry,\n-/", "proof_hint": "  calc\n  n * S(S(O)) = _               : by rw mul_S\n          ... = n + n           : by sorry,", "textAfter": "\nend\n\nend exlean -- hide", "height": 10, "editorText": "  calc\n  n * S(S(O)) = _               : by rw mul_S\n          ... = n + n           : by sorry,", "lineOffset": 66, "name": "mul_two", "statement": "(n : \u2115) : n * S(S(O)) = n + n"}, {"type": "lean", "content": "337", "hidden": true}]}, {"name": "", "problemIndex": 7, "objects": [{"type": "lean", "content": "338", "hidden": true}, {"type": "lean", "content": "339", "hidden": true}, {"type": "lean", "content": "340", "hidden": true}, {"type": "lean", "content": "341", "hidden": true}, {"type": "lean", "content": "342", "hidden": true}, {"type": "text", "content": "343"}, {"type": "text", "content": "344"}, {"type": "theorem", "text": "345", "lean": "theorem O_mul (n : \u2115) : O * n = O :=\n", "sideBar": true, "firstProofLineNumber": 29, "lastProofLineNumber": 45, "textBefore": "import natural_numbers.mul_two -- hide\n\nset_option pp.structure_projections false -- hide\n\nnamespace exlean -- hide\n\nopen_locale mynum -- hide\n\nopen mynat -- hide\n\n/-\n# Natural numbers\n\n## Level 10: Multiply by O on the left\n-/\n\n/-\n## Task\n\nBy induction on $n$, prove that $\\mathsf O \\times n = \\mathsf O$,\nfor every natural number $n$.\n-/\n\n/- Theorem :\nFor every natural number $n$, we have $\\mathsf O \\times n = \\mathsf O$.\n-/\ntheorem O_mul (n : \u2115) : O * n = O :=\nbegin [pure_maths]\n", "proof": "  induction n,\n\n  case O :\n  { show O * O = O, from rfl, },\n\n  case S : k h\n  { show O * S(k) = O,\n    given h : O * k = O,\n    calc\n    O * S(k)  = O * k + O : by rw mul_S\n          ... = O + O     : by rw h\n          ... = O         : by rw add_O, },\n\n\n\n\n", "proof_hint": "sorry", "textAfter": "\nend\n\nattribute [simp] O_mul -- hide\n\nend exlean -- hide", "height": 17, "editorText": "sorry", "lineOffset": 28, "name": "O_mul", "statement": "(n : \u2115) : O * n = O"}, {"type": "lean", "content": "346", "hidden": true}, {"type": "lean", "content": "347", "hidden": true}]}, {"name": "", "problemIndex": 7, "objects": [{"type": "lean", "content": "348", "hidden": true}, {"type": "lean", "content": "349", "hidden": true}, {"type": "lean", "content": "350", "hidden": true}, {"type": "lean", "content": "351", "hidden": true}, {"type": "lean", "content": "352", "hidden": true}, {"type": "text", "content": "353"}, {"type": "text", "content": "354"}, {"type": "theorem", "text": "355", "lean": "theorem mul_add (x y z : \u2115) : x * (y + z) = x * y + x * z :=\n", "sideBar": true, "firstProofLineNumber": 29, "lastProofLineNumber": 51, "textBefore": "import natural_numbers.zero_mul -- hide\n\nset_option pp.structure_projections false -- hide\n\nnamespace exlean -- hide\n\nopen_locale mynum -- hide\n\nopen mynat -- hide\n\n/-\n# Natural numbers\n\n## Level 11: Left distributivity of multiplication\n-/\n\n/-\n## Task\n\nLet $x$ and $y$ be natural numbers. By induction on $z$, prove that\n$x(y + z) = x y + xz$, for every natural number $z$.\n-/\n\n/- Theorem :\nFor all natural numbers $x$, $y$, and $z$, we have $x(y + z) = xy + xz$.\n-/\ntheorem mul_add (x y z : \u2115) : x * (y + z) = x * y + x * z :=\nbegin [pure_maths]\n", "proof": "  induction z,\n\n  case O :\n  { show x * (y + O) = x * y + x * O, calc\n    x * (y + O) = x * y           : by rw add_O\n            ... = x * y + O       : by rw add_O\n            ... = x * y + (x * O) : by rw mul_O },\n\n  case S : k h\n  { show x * (y + S(k)) = x * y + x * S(k),\n    given h : x * (y + k) = x * y + x * k,\n    calc\n    x * (y + S(k))  = x * (S(y + k))        : by rw add_S\n                ... = x * (y + k) + x       : by rw mul_S\n                ... = (x * y + x * k) + x   : by rw h\n                ... = x * y + (x * k + x)   : by rw add_assoc\n                ... = x * y + x * S(k)      : by rw mul_S, },\n\n\n\n\n\n", "proof_hint": "sorry", "textAfter": "\nend\n\nend exlean -- hide", "height": 23, "editorText": "sorry", "lineOffset": 28, "name": "mul_add", "statement": "(x y z : \u2115) : x * (y + z) = x * y + x * z"}, {"type": "lean", "content": "356", "hidden": true}]}, {"name": "", "problemIndex": 8, "objects": [{"type": "lean", "content": "357", "hidden": true}, {"type": "lean", "content": "358", "hidden": true}, {"type": "lean", "content": "359", "hidden": true}, {"type": "lean", "content": "360", "hidden": true}, {"type": "lean", "content": "361", "hidden": true}, {"type": "text", "content": "362"}, {"type": "text", "content": "363"}, {"type": "hint", "content": "364", "title": "365"}, {"type": "theorem", "text": "366", "lean": "theorem mul_assoc (x y z : \u2115) : (x * y) * z = x * (y * z) :=\n", "sideBar": true, "firstProofLineNumber": 34, "lastProofLineNumber": 53, "textBefore": "import natural_numbers.mul_add -- hide\n\nset_option pp.structure_projections false -- hide\n\nnamespace exlean -- hide\n\nopen_locale mynum -- hide\n\nopen mynat -- hide\n\n/-\n# Natural numbers\n\n## Level 12: Associativity of multiplication\n-/\n\n/-\n## Task\n\nLet $x$ and $y$ be natural numbers. By induction on $z$, prove that\n$(xy)z = x(yz)$, for every natural number $z$.\n-/\n\n/- Hint : A helpful result\nAt some point in your proof, it will be helpful to use `mul_add`, the\nleft distributivity of multiplication result.\n-/\n\n/- Theorem :\nFor all natural numbers $x$, $y$, and $z$, we have $(xy)z = x(yz)$.\n-/\ntheorem mul_assoc (x y z : \u2115) : (x * y) * z = x * (y * z) :=\nbegin [pure_maths]\n", "proof": "  induction z,\n\n  case O :\n  { show (x * y) * O = x * (y * O), from rfl, },\n\n  case S : k h\n  { show (x * y) * S(k) = x * (y * S(k)),\n    given h : (x * y) * k = x * (y * k),\n    calc\n    (x * y) * S(k)  = (x * y) * k + (x * y)   : by rw mul_S\n                ... = x * (y * k) + x * y     : by rw h\n                ... = x * (y * k + y)         : by rw mul_add\n                ... = x * (y * S(k))          : by rw mul_S, },\n\n\n\n\n\n\n", "proof_hint": "sorry", "textAfter": "\nend\n\nend exlean -- hide", "height": 20, "editorText": "sorry", "lineOffset": 33, "name": "mul_assoc", "statement": "(x y z : \u2115) : (x * y) * z = x * (y * z)"}, {"type": "lean", "content": "367", "hidden": true}]}, {"name": "", "problemIndex": 8, "objects": [{"type": "lean", "content": "368", "hidden": true}, {"type": "lean", "content": "369", "hidden": true}, {"type": "lean", "content": "370", "hidden": true}, {"type": "lean", "content": "371", "hidden": true}, {"type": "lean", "content": "372", "hidden": true}, {"type": "text", "content": "373"}, {"type": "text", "content": "374"}, {"type": "hint", "content": "375", "title": "376"}, {"type": "theorem", "text": "377", "lean": "theorem S_mul (m n : \u2115) : S(m) * n = m * n + n :=\n", "sideBar": true, "firstProofLineNumber": 36, "lastProofLineNumber": 59, "textBefore": "import natural_numbers.mul_assoc -- hide\n\nset_option pp.structure_projections false -- hide\n\nnamespace exlean -- hide\n\nopen_locale mynum -- hide\n\nopen mynat -- hide\n\n/-\n# Natural numbers\n\n## Level 13: `S_mul`\n-/\n\n/-\n## Task\n\nLet $m$ be a natural number. By induction on $n$, prove that\n$\\mathsf S(m) n = mn + n$, for every natural number $n$.\n\nThis is the hardest induction so far.\n-/\n\n/- Hint : Helpful results\nAt some point in your proof of the inductive step, it will be\nhelpful to use `mul_S`, `add_S`, `add_assoc`, and `add_comm`.\n-/\n\n/- Theorem :\nFor all natural numbers $m$ and $n$, we have $\\mathsf S(m) n = mn + n$.\n-/\ntheorem S_mul (m n : \u2115) : S(m) * n = m * n + n :=\nbegin [pure_maths]\n", "proof": "  induction n,\n\n  case O :\n  { show S(m) * O = m * O + O, from rfl, },\n\n  case S : k h\n  { show S(m) * S(k) = m * S(k) + S(k),\n    given h : S(m) * k = m * k + k,\n    calc\n    S(m) * S(k) = S(m) * k + S(m)       : by rw mul_S\n            ... = (m * k + k) + S(m)    : by rw h\n            ... = S((m * k + k) + m)    : by rw add_S\n            ... = S(m * k + (k + m))    : by rw add_assoc\n            ... = S(m * k + (m + k))    : by rw add_comm k\n            ... = S((m * k + m) + k)    : by rw add_assoc\n            ... = ((m * k) + m) + S(k)  : by rw add_S\n            ... = m * S(k) + S(k)       : by rw mul_S, },\n\n\n\n\n\n\n", "proof_hint": "sorry", "textAfter": "\nend\n\nend exlean -- hide", "height": 24, "editorText": "sorry", "lineOffset": 35, "name": "S_mul", "statement": "(m n : \u2115) : S(m) * n = m * n + n"}, {"type": "lean", "content": "378", "hidden": true}]}, {"name": "", "problemIndex": 7, "objects": [{"type": "lean", "content": "379", "hidden": true}, {"type": "lean", "content": "380", "hidden": true}, {"type": "lean", "content": "381", "hidden": true}, {"type": "lean", "content": "382", "hidden": true}, {"type": "lean", "content": "383", "hidden": true}, {"type": "text", "content": "384"}, {"type": "text", "content": "385"}, {"type": "theorem", "text": "386", "lean": "theorem mul_comm (m n : \u2115) : m * n = n * m :=\n", "sideBar": true, "firstProofLineNumber": 31, "lastProofLineNumber": 51, "textBefore": "import natural_numbers.S_mul -- hide\n\nset_option pp.structure_projections false -- hide\n\nnamespace exlean -- hide\n\nopen_locale mynum -- hide\n\nopen mynat -- hide\n\n/-\n# Natural numbers\n\n## Level 14: Commutativity of multiplication\n-/\n\n/-\n## Task\n\nLet $m$ be a natural number. By induction on $n$, prove that\n$mn = nm$, for every natural number $n$.\n\nYou've done all the hard work in the previous level, `S_mul`.\n-/\n\n/- Theorem :\nFor all natural numbers $m$ and $n$, we have $mn = nm$.\n-/\ntheorem mul_comm (m n : \u2115) : m * n = n * m :=\nbegin [pure_maths]\n", "proof": "  induction n,\n\n  case O :\n  { show m * O = O * m,\n    calc\n    m * O = O     : by rw mul_O\n      ... = O * m : by rw O_mul, },\n\n  case S : k h\n  { show m * S(k) = S(k) * m,\n    given h : m * k = k * m,\n    calc\n    m * S(k)  = m * k + m   : by rw mul_S\n          ... = k * m + m   : by rw h\n          ... = S(k) * m    : by rw S_mul, }\n\n\n\n\n\n", "proof_hint": "sorry", "textAfter": "\nend\n\nend exlean -- hide", "height": 21, "editorText": "sorry", "lineOffset": 30, "name": "mul_comm", "statement": "(m n : \u2115) : m * n = n * m"}, {"type": "lean", "content": "387", "hidden": true}]}, {"name": "", "problemIndex": 14, "objects": [{"type": "lean", "content": "388", "hidden": true}, {"type": "lean", "content": "389", "hidden": true}, {"type": "lean", "content": "390", "hidden": true}, {"type": "lean", "content": "391", "hidden": true}, {"type": "lean", "content": "392", "hidden": true}, {"type": "text", "content": "393"}, {"type": "axiom", "content": "394", "name": "one_mul (m : \u2115) :", "sideBar": true}, {"type": "lean", "content": "395", "hidden": true}, {"type": "text", "content": "396"}, {"type": "lean", "content": "397", "hidden": false}, {"type": "text", "content": "398"}, {"type": "tactic", "content": "399", "name": "ring", "sideBar": true}, {"type": "lean", "content": "400", "hidden": false}, {"type": "text", "content": "401"}, {"type": "theorem", "text": "402", "lean": "theorem easy_mul (a b : \u2115) : \u2203 (x : \u2115),\n(a + 2 * b) * (2 * a + b) = 2 * a ^ 2 + x * a * b + 2 * b ^ 2  :=\n", "sideBar": false, "firstProofLineNumber": 104, "lastProofLineNumber": 105, "textBefore": "import natural_numbers.mul_comm tactic.ring -- hide\n\nset_option pp.structure_projections false -- hide\n\nnamespace exlean -- hide\n\nopen_locale mynum -- hide\n\nopen mynat -- hide\n\n/-\n# Natural numbers\n\n## Level 15: Easy arithmetic\n\nWe've proved a significant set of theorems about natural number arithmetic. We know addition\nand multiplication are associative and commutative. We know that multiplication is distributive.\nWe know special facts about adding and multiplying by zero and multiplying by one.\n\nPut together, these facts mean that `\u2115` is something called a 'commutative semiring'. You don't\nneed to know what that means for the moment. What's important is that Lean has powerful tactics\nfor proving results in commutative semirings.\n-/\n\n/- Axiom : one_mul (m : \u2115) :\nS(O) * m = m\n-/\n-- begin hide\n@[simp] lemma one_mul (n : \u2115) : S(O) * n = n := by rw [mul_comm, mul_one]\n\ninstance : comm_monoid mynat :=\n{ mul_assoc := mul_assoc,\n  mul_comm := mul_comm,\n  one_mul := one_mul,\n  mul_one := mul_one,\n  .. }\n\ninstance : has_coe nat mynat := \u27e8\u03bb n, nat.rec_on n O (\u03bb a b, S b)\u27e9\n\nlemma coe_succ (n : nat) : \u2191(nat.succ n) = S n := rfl\n\nlemma nsmul_succ' (n : nat) (x : mynat) : \u2191(n.succ) * x = x + \u2191n * x :=\nby rw [coe_succ, S_mul, add_comm]\n\nlemma add_mul (a b c : \u2115) : (a + b) * c = a * c + b * c :=\nby rw [mul_comm, mul_add, mul_comm c, mul_comm c]\n\ninstance : comm_semiring mynat :=\n{ nsmul := \u03bb m n, m * n,\n  nsmul_zero' := O_mul,\n  nsmul_succ' := nsmul_succ',\n  left_distrib := mul_add,\n  right_distrib := add_mul,\n  zero_mul := O_mul,\n  mul_zero := mul_O,\n  ..mynat.add_comm_monoid, ..mynat.comm_monoid, .. }\n\n-- end hide\n\n/-\nFor example, the `ring` tactic can prove $(a + b)^2 = a^2 + 2ab + b^2$.\n-/\n\nexample (a b c : \u2115) :\n(a + b) ^ 2 = a ^ 2 + 2 * a * b + b ^ 2 :=\nbegin\n  ring,\nend\n\n/-\nTo make things interesting, we can pose the proof above as a question. Find $x$ such that\n$(a + b)^2 = a^2 + xab + b^2$, for all $a$ and $b$.\n\nThe answer is $2$ (of course!). You tell Lean to use $2$ by typing `use 2`. Then `ring`\nfinishes the proof.\n-/\n\n/- Tactic : ring\nProves equations in commutative semirings (such as \u2115).\n-/\n\nexample (a b c : \u2115) : \u2203 (x : \u2115),\n(a + b) ^ 2 = a ^ 2 + x * a * b + b ^ 2 :=\nbegin\n  use 2,\n  ring,\nend\n\n/-\n## Task\n\nAdapting the proof above, prove the following result by finding $x$ such that\n$(a + 2b)(2a + b) = 2a ^ 2 + xab + 2b^2$.\n-/\n\n/- Theorem : no-side-bar\nThere exists a natural number $x$ such that $(a + 2b)(2a + b) = 2a ^ 2 + xab + 2b^2$, for all\nnatural numbers $a$ and $b$.\n-/\n\ntheorem easy_mul (a b : \u2115) : \u2203 (x : \u2115),\n(a + 2 * b) * (2 * a + b) = 2 * a ^ 2 + x * a * b + 2 * b ^ 2  :=\nbegin\n", "proof": "  use 5,\n  ring,", "proof_hint": "sorry", "textAfter": "\nend\n\nend exlean -- hide", "height": 2, "editorText": "sorry", "lineOffset": 103, "name": "easy_mul", "statement": "(a b : \u2115) : \u2203 (x : \u2115),\n(a + 2 * b) * (2 * a + b) = 2 * a ^ 2 + x * a * b + 2 * b ^ 2"}, {"type": "lean", "content": "403", "hidden": true}]}, {"name": "", "problemIndex": 10, "objects": [{"type": "lean", "content": "404", "hidden": true}, {"type": "lean", "content": "405", "hidden": true}, {"type": "lean", "content": "406", "hidden": true}, {"type": "lean", "content": "407", "hidden": true}, {"type": "lean", "content": "408", "hidden": true}, {"type": "text", "content": "409"}, {"type": "text", "content": "410"}, {"type": "axiom", "content": "411", "name": "pow_O (n : \u2115) :", "sideBar": true}, {"type": "axiom", "content": "412", "name": "pow_S (m n : \u2115) :", "sideBar": true}, {"type": "text", "content": "413"}, {"type": "theorem", "text": "414", "lean": "theorem pow_one (m : \u2115) : m ^ S(O) = m :=\n", "sideBar": true, "firstProofLineNumber": 51, "lastProofLineNumber": 58, "textBefore": "import natural_numbers.easy_multiplication -- hide\n\nset_option pp.structure_projections false -- hide\n\nnamespace exlean -- hide\n\nopen_locale mynum -- hide\n\nopen mynat -- hide\n\n/-\n# Natural numbers\n\n## Level 16: Exponentiation. Raising to the first power\n-/\n\n/-\nLet $m$ be a natural number. We'll define raising $m$ to the (natural number) power $n$\nrecursively on $n$ so that $m^{\\mathsf O} := 1$ and $m^{\\mathsf S(n)} := (m ^ n) \\times m$.\n\nIn Lean, we write `m ^ n` for $m ^ n$. The defining equations of exponentiation are represented\nby the following theorems.\n\n`pow_O (n : \u2115) : n ^ O = S(O)`\n\n`pow_S (m n : \u2115) : m ^ S(n) = (m ^ n) * m`\n-/\n\n/- Axiom : pow_O (n : \u2115) :\nn ^ O = S(O)\n-/\n\n/- Axiom : pow_S (m n : \u2115) :\nm ^ S(n) = (m ^ n) * m\n-/\n\n\n/-\n## Task\n\nProve that $m ^ 1 = m$, for every natural number $m$. You *don't* need\ninduction.\n-/\n\n\n/- Theorem :\nFor all natural numbers $m$ and $n$, we have $mn = nm$.\n-/\ntheorem pow_one (m : \u2115) : m ^ S(O) = m :=\nbegin [pure_maths]\n", "proof": "  calc\n  m ^ S(O)  = m ^ O * m : by rw pow_S\n        ... = S(O) * m  : by rw pow_O\n        ... = m         : by rw one_mul,\n\n\n\n", "proof_hint": "sorry", "textAfter": "\nend\n\nend exlean -- hide", "height": 8, "editorText": "sorry", "lineOffset": 50, "name": "pow_one", "statement": "(m : \u2115) : m ^ S(O) = m"}, {"type": "lean", "content": "415", "hidden": true}]}, {"name": "", "problemIndex": 6, "objects": [{"type": "lean", "content": "416", "hidden": true}, {"type": "lean", "content": "417", "hidden": true}, {"type": "lean", "content": "418", "hidden": true}, {"type": "lean", "content": "419", "hidden": true}, {"type": "lean", "content": "420", "hidden": true}, {"type": "text", "content": "421"}, {"type": "theorem", "text": "422", "lean": "theorem one_pow (m : \u2115) : S(O) ^ m = S(O) :=\n", "sideBar": true, "firstProofLineNumber": 26, "lastProofLineNumber": 41, "textBefore": "import natural_numbers.pow_one -- hide\n\nset_option pp.structure_projections false -- hide\n\nnamespace exlean -- hide\n\nopen_locale mynum -- hide\n\nopen mynat -- hide\n\n/-\n# Natural numbers\n\n## Level 17: Powers of 1\n\n## Task\n\nProve that $1 ^ m = 1$, for every natural number $m$.\n-/\n\n/- Theorem :\n$1 ^ m = 1$, for every natural number $m$.\n-/\ntheorem one_pow (m : \u2115) : S(O) ^ m = S(O) :=\nbegin [pure_maths]\n", "proof": "  induction m,\n\n  case O :\n  { show S(O) ^ O = S(O), from rfl, },\n\n  case S : k h\n  { show S(O) ^ S(k) = S(O),\n    given h : S(O) ^ k = S(O),\n    calc\n    S(O) ^ S(k) = S(O) ^ k * S(O) : by rw pow_S\n            ... = S(O) * S(O)     : by rw h\n            ... = S(O)            : by rw mul_one, },\n\n\n\n", "proof_hint": "sorry", "textAfter": "\nend\n\nend exlean -- hide", "height": 16, "editorText": "sorry", "lineOffset": 25, "name": "one_pow", "statement": "(m : \u2115) : S(O) ^ m = S(O)"}, {"type": "lean", "content": "423", "hidden": true}]}, {"name": "", "problemIndex": 6, "objects": [{"type": "lean", "content": "424", "hidden": true}, {"type": "lean", "content": "425", "hidden": true}, {"type": "lean", "content": "426", "hidden": true}, {"type": "lean", "content": "427", "hidden": true}, {"type": "lean", "content": "428", "hidden": true}, {"type": "text", "content": "429"}, {"type": "theorem", "text": "430", "lean": "theorem pow_add (m a b : \u2115) : m ^ (a + b) = m ^ a * m ^ b :=\n", "sideBar": true, "firstProofLineNumber": 27, "lastProofLineNumber": 48, "textBefore": "import natural_numbers.one_pow -- hide\n\nset_option pp.structure_projections false -- hide\n\nnamespace exlean -- hide\n\nopen_locale mynum -- hide\n\nopen mynat -- hide\n\n/-\n# Natural numbers\n\n## Level 18: Raising to a power $a + b$\n\n## Task\n\nLet $m$ and $a$ be natural numbers. Prove, by induction on $b$,\nthat $m ^ {a + b} = m ^ a m ^ b$, for all natural numbers $b$.\n-/\n\n/- Theorem :\nFor all natural numbers $m$, $a$, and $b$, we have $m ^ {a + b} = m ^ a m ^ b$.\n-/\ntheorem pow_add (m a b : \u2115) : m ^ (a + b) = m ^ a * m ^ b :=\nbegin [pure_maths]\n", "proof": "  induction b,\n\n  case O :\n  { show m ^ (a + O) = m ^ a * m ^ O, calc\n    m ^ (a + O) = m ^ a             : by rw add_O\n            ... = (m ^ a) * (S O)   : by rw mul_one\n            ... = m ^ a * m ^ O     : by rw pow_O, },\n\n  case S : k h\n  { show m ^ (a + S(k)) = m ^ a * m ^ S(k),\n    given h : m ^ (a + k) = m ^ a * m ^ k,\n    calc\n    m ^ (a + S(k))  = m ^ (S(a + k))        : by rw add_S\n                ... = m ^ (a + k) * m       : by rw pow_S\n                ... = (m ^ a * m ^ k) * m   : by rw h\n                ... = m ^ a * (m ^ k * m)   : by rw mul_assoc\n                ... = m ^ a * (m ^ S(k))    : by rw pow_S, },\n\n\n\n\n", "proof_hint": "sorry", "textAfter": "\nend\n\nend exlean -- hide", "height": 22, "editorText": "sorry", "lineOffset": 26, "name": "pow_add", "statement": "(m a b : \u2115) : m ^ (a + b) = m ^ a * m ^ b"}, {"type": "lean", "content": "431", "hidden": true}]}, {"name": "", "problemIndex": 6, "objects": [{"type": "lean", "content": "432", "hidden": true}, {"type": "lean", "content": "433", "hidden": true}, {"type": "lean", "content": "434", "hidden": true}, {"type": "lean", "content": "435", "hidden": true}, {"type": "lean", "content": "436", "hidden": true}, {"type": "text", "content": "437"}, {"type": "theorem", "text": "438", "lean": "theorem pow_mul (m a b : \u2115) : m ^ (a * b) = (m ^ a) ^ b :=\n", "sideBar": true, "firstProofLineNumber": 27, "lastProofLineNumber": 44, "textBefore": "import natural_numbers.pow_add -- hide\n\nset_option pp.structure_projections false -- hide\n\nnamespace exlean -- hide\n\nopen_locale mynum -- hide\n\nopen mynat -- hide\n\n/-\n# Natural numbers\n\n## Level 19: Raising to a power $ab$\n\n## Task\n\nLet $m$ and $a$ be natural numbers. Prove, by induction on $b$,\nthat $m ^ {a b} = (m ^ a) ^ b$, for all natural numbers $b$.\n-/\n\n/- Theorem :\nFor all natural numbers $m$, $a$, and $b$, we have $m ^ {a b} = (m ^ a) ^ b$.\n-/\ntheorem pow_mul (m a b : \u2115) : m ^ (a * b) = (m ^ a) ^ b :=\nbegin [pure_maths]\n", "proof": "  induction b,\n\n  case O :\n  { refl, },\n\n  case S : k h\n  { show m ^ (a * S(k)) = (m ^ a) ^ S(k),\n    given h : m ^ (a * k) = (m ^ a) ^ k,\n    calc\n    m ^ (a * S(k))  = m ^ (a * k + a)           : by rw mul_S\n                ... = m ^ (a * k) * m ^ a       : by rw pow_add\n                ... = (m ^ a) ^ k * m ^ a       : by rw h\n                ... = (m ^ a) ^ S(k)            : by rw pow_S, },\n\n\n\n\n", "proof_hint": "sorry", "textAfter": "\nend\n\nend exlean -- hide", "height": 18, "editorText": "sorry", "lineOffset": 26, "name": "pow_mul", "statement": "(m a b : \u2115) : m ^ (a * b) = (m ^ a) ^ b"}, {"type": "lean", "content": "439", "hidden": true}]}, {"name": "", "problemIndex": 7, "objects": [{"type": "lean", "content": "440", "hidden": true}, {"type": "lean", "content": "441", "hidden": true}, {"type": "lean", "content": "442", "hidden": true}, {"type": "lean", "content": "443", "hidden": true}, {"type": "lean", "content": "444", "hidden": true}, {"type": "text", "content": "445"}, {"type": "hint", "content": "446", "title": "447"}, {"type": "theorem", "text": "448", "lean": "theorem mul_pow (a b m: \u2115) : (a * b) ^ m = (a ^ m) * (b ^ m) :=\n", "sideBar": true, "firstProofLineNumber": 33, "lastProofLineNumber": 53, "textBefore": "import natural_numbers.pow_mul -- hide\n\nset_option pp.structure_projections false -- hide\n\nnamespace exlean -- hide\n\nopen_locale mynum -- hide\n\nopen mynat -- hide\n\n/-\n# Natural numbers\n\n## Level 20: Powers of products\n\n## Task\n\nLet $a$ and $b$ be natural numbers. Prove that $(ab)^m = (a^m)(b^m)$,\nfor every natural number $m$.\n-/\n\n/- Hint : A time-saving tactic\nAt some point in the proof, you may find it helpful to use the `ac_refl` tactic \nor the `ring` tactic to easily show\na result that depends on commutativity and associativity of multiplication.\n-/\n\n/- Theorem :\nFor all natural numbers $a$, $b$, and $m$, we have $(ab)^m = (a^m)(b^m)$.\n-/\ntheorem mul_pow (a b m: \u2115) : (a * b) ^ m = (a ^ m) * (b ^ m) :=\nbegin [pure_maths]\n", "proof": "  induction m,\n\n  case O :\n  { show (a * b) ^ O = (a ^ O) * (b ^ O), from rfl, },\n\n  case S : k h\n  { show (a * b) ^ S(k) = (a ^ S(k)) * (b ^ S(k)),\n    given h : (a * b) ^ k = (a ^ k) * (b ^ k),\n    calc\n    (a * b) ^ S(k) = (a * b) ^ k * (a * b)  : by rw pow_S\n    ... = (a ^ k) * (b ^ k) * (a * b)       : by rw h\n    ... = ((a ^ k) * a) * ((b ^ k) * b)     : by ac_refl\n    ... = (a ^ S(k)) * (b ^ S(k))           : rfl },\n\n\n\n\n\n\n\n", "proof_hint": "sorry", "textAfter": "\nend\n\n\nend exlean -- hide", "height": 21, "editorText": "sorry", "lineOffset": 32, "name": "mul_pow", "statement": "(a b m: \u2115) : (a * b) ^ m = (a ^ m) * (b ^ m)"}, {"type": "lean", "content": "449", "hidden": true}]}, {"name": "", "problemIndex": 16, "objects": [{"type": "lean", "content": "450", "hidden": true}, {"type": "lean", "content": "451", "hidden": true}, {"type": "lean", "content": "452", "hidden": true}, {"type": "lean", "content": "453", "hidden": true}, {"type": "lean", "content": "454", "hidden": true}, {"type": "text", "content": "455"}, {"type": "lean", "content": "456", "hidden": true}, {"type": "lean", "content": "457", "hidden": false}, {"type": "text", "content": "458"}, {"type": "text", "content": "459"}, {"type": "axiom", "content": "460", "name": "fsum_O (f : \u2115 \u2192 \u2115) :", "sideBar": true}, {"type": "axiom", "content": "461", "name": "fsum_S (f : \u2115 \u2192 \u2115) (n : \u2115) :", "sideBar": true}, {"type": "text", "content": "462"}, {"type": "axiom", "content": "463", "name": "fsum_zero (n : \u2115) :", "sideBar": true}, {"type": "lean", "content": "464", "hidden": false}, {"type": "text", "content": "465"}, {"type": "theorem", "text": "466", "lean": "theorem fsum_const (c n : \u2115) : \u2211 i \u227a n, c = c * n :=\n", "sideBar": true, "firstProofLineNumber": 101, "lastProofLineNumber": 116, "textBefore": "import natural_numbers.mul_pow -- hide\n\nset_option pp.structure_projections false -- hide\n\nnamespace exlean -- hide\n\nopen_locale mynum -- hide\n\nopen mynat -- hide\n\n/-\n# Natural numbers\n\n## Level 21: Finite sums\n\nIn mathematics, the 'sigma' notation is used to represent sums. We may write\n$$\n\\sum_{i=0}^{10} i\n$$\nto represent the sum $0 + 1 + \\dots + 9 + 10$. Henceforth, as all our numbers are non-negative,\nwe'll omit the lower summation bound $0$.\n\nIn this book, we represent the same quantity as\n`\u2211 i \u227c 10, i`. Here, `\u2211` is typed `\\sum`, and `\u227c` is typed `\\preceq`.\n\nLikewise, the sum $\\sum_{i < 10} i$ is represented as `\u2211 i \u227a 10, i`, where `\u227a` is typed `\\prec`.\n\nFor example, one can prove (by reflexivity), that\n$$\\sum_{i \\le 4} i ^ 2 = 30.$$\n-/\n\nopen_locale fsum -- hide\n\nexample : \u2211 i \u227c 4, i ^ 2 = 30 :=\nbegin\n  from rfl,\nend\n\n/-\nMore generally, one can consider $\\sum_{i < n} f(i)$, for some function $f$. We'll define this by\ntwo principles: (1) $\\sum_{i < 0} f(i) := 0$ and (2)\n$\\sum_{i < \\mathsf S(n)} f(i) := \\sum_{i < n} f(i) + f(n)$.\n\nNote (2) may also be written as $\\sum_{i \\le n} f(i) := \\sum_{i < n} f(i) + f(n)$.\n-/\n\n\n/-\nThese definitions are available as the theorems `fsum_O` and `fsum_S`:\n\n`fsum_O (f : \u2115 \u2192 \u2115) : \u2211 i \u227a O, f(i) = O`\n\n`fsum_S (f : \u2115 \u2192 \u2115) (n : \u2115) : \u2211 i \u227c n, f(i) = \u2211 i \u227a n, f(i) + f(n)`\n-/\n\n/- Axiom : fsum_O (f : \u2115 \u2192 \u2115) :\n\u2211 i \u227a O, f(i) = O\n-/\n\n/- Axiom : fsum_S (f : \u2115 \u2192 \u2115) (n : \u2115) :\n\u2211 i \u227c n, f(i) = \u2211 i \u227a n, f(i) + f(n)\n-/\n\n/-\nUsing these theorems, we can prove $\\sum_{i < n} 0 = 0$, for all natural numbers $n$.\n-/\n\n\n/- Axiom : fsum_zero (n : \u2115) :\n\u2211 i \u227a n, 0 = 0\n-/\nlemma fsum_zero (n : \u2115) : \u2211 i \u227a n, 0 = 0 :=\nbegin [pure_maths]\n  induction n,\n\n  case O :\n  { show \u2211 i \u227a 0, 0 = 0, from rfl, },\n\n  case S : k h\n  { show \u2211 i \u227c k, 0 = 0,\n    given h : \u2211 i \u227a k, 0 = 0,\n    calc\n    \u2211 i \u227c k, 0  = \u2211 i \u227a k, 0 + 0 : by rw fsum_S\n            ... = 0 + 0           : by rw h\n            ... = 0               : rfl, },\nend\n\n/-\n\n## Task\n\nLet $c : \\mathbb N$ be a constant.\nBy induction on $n$, prove that $\\sum_{i < n} c = cn$, for every natural number $n$.\n-/\n\n/- Theorem :\n$\\sum_{i < n} c = cn$, for all natural numbers $c$ and $n$.\n-/\ntheorem fsum_const (c n : \u2115) : \u2211 i \u227a n, c = c * n :=\nbegin [pure_maths]\n", "proof": "  induction n,\n\n  case O :\n  { from rfl, },\n\n  case S : k h\n  { show \u2211 i \u227c k, c = c * S(k),\n    given h : \u2211 i \u227a k, c = c * k,\n    calc\n    \u2211 i \u227c k, c  = \u2211 i \u227a k, c + c : by rw fsum_S\n            ... = c * k + c       : by rw h\n            ... = c * S(k)        : by rw mul_S  },\n\n\n\n", "proof_hint": "sorry", "textAfter": "\nend\n\nattribute [simp] fsum_const -- hide\n\n\nend exlean -- hide", "height": 16, "editorText": "sorry", "lineOffset": 100, "name": "fsum_const", "statement": "(c n : \u2115) : \u2211 i \u227a n, c = c * n"}, {"type": "lean", "content": "467", "hidden": true}, {"type": "lean", "content": "468", "hidden": true}]}, {"name": "", "problemIndex": 11, "objects": [{"type": "lean", "content": "469", "hidden": true}, {"type": "lean", "content": "470", "hidden": true}, {"type": "lean", "content": "471", "hidden": true}, {"type": "lean", "content": "472", "hidden": true}, {"type": "lean", "content": "473", "hidden": true}, {"type": "text", "content": "474"}, {"type": "lean", "content": "475", "hidden": true}, {"type": "text", "content": "476"}, {"type": "hint", "content": "477", "title": "478"}, {"type": "hint", "content": "479", "title": "480"}, {"type": "hint", "content": "481", "title": "482"}, {"type": "theorem", "text": "483", "lean": "theorem triangle_sum (n : \u2115) : 2 * (\u2211 i \u227c n, i) = n * (n + 1) :=\n", "sideBar": true, "firstProofLineNumber": 66, "lastProofLineNumber": 84, "textBefore": "import natural_numbers.finite_sum -- hide\n\nset_option pp.structure_projections false -- hide\n\nnamespace exlean -- hide\n\nopen_locale mynum -- hide\n\nopen mynat -- hide\n\n/-\n# Natural numbers\n\n## Level 22: Triangular numbers\n-/\n\nopen_locale fsum -- hide\n\n\n/-\n\n## Task\n\nProve the formula for triangular numbers, that\n$$\n2\\left(\\sum_{i \\le n} i\\right) = n(n + 1),\n$$\nfor every natural number $n$.\n-/\n\n/- Hint : Cheap algebra\nRemember that the `ring` tactic can prove most equations.\n-/\n\n/- Hint : Converting from `S(k)` to `k + 1`\nThe equation `S(k) = k + 1` holds from `rfl`. Use this before\napplying the `ring` tactic.\n-/\n\n/- Hint : A proof template\nIf you're not sure how to get going, try the following proof template.\nFill in the `_` with an expression, add extra calculation lines and\ncomplete the final `sorry`.\n```\ninduction n,\n\ncase O :\n{ from rfl, },\n\ncase S : k h\n{ show 2 * (\u2211 i \u227c S(k), i) = S(k) * (S(k) + 1),\n  given h : 2 * (\u2211 i \u227c k, i) = k * (k + 1),\n  calc\n  2 * (\u2211 i \u227c S(k), i)\n      = 2 * (\u2211 i \u227c k, i + S(k))        : by rw fsum_S\n  ... = (k + 1) * ((k + 1) + 1)        : sorry, }\n```\n\n-/\n\n/- Theorem :\n$2(\\sum_{i \\le n} i) = n(n + 1)$, for every natural number $n$.\n-/\ntheorem triangle_sum (n : \u2115) : 2 * (\u2211 i \u227c n, i) = n * (n + 1) :=\nbegin [pure_maths]\n", "proof": "  induction n,\n\n  case O :\n  { from rfl, },\n\n  case S : k h\n  { show 2 * (\u2211 i \u227c S(k), i) = S(k) * (S(k) + 1),\n    given h : 2 * (\u2211 i \u227c k, i) = k * (k + 1),\n    calc\n    2 * (\u2211 i \u227c S(k), i)\n        = 2 * (\u2211 i \u227c k, i + S(k))        : by rw fsum_S\n    ... = 2 * (\u2211 i \u227c k, i) + 2 * S(k)    : by rw mul_add\n    ... = k * (k + 1) + 2 * S(k)         : by rw h\n    ... = k * (k + 1) + 2 * (k + 1)      : rfl\n    ... = (k + 1) * ((k + 1) + 1)        : by ring, }\n\n\n\n", "proof_hint": "sorry", "textAfter": "\nend\n\nend exlean -- hide", "height": 19, "editorText": "sorry", "lineOffset": 65, "name": "triangle_sum", "statement": "(n : \u2115) : 2 * (\u2211 i \u227c n, i) = n * (n + 1)"}, {"type": "lean", "content": "484", "hidden": true}]}, {"name": "", "problemIndex": 8, "objects": [{"type": "lean", "content": "485", "hidden": true}, {"type": "lean", "content": "486", "hidden": true}, {"type": "lean", "content": "487", "hidden": true}, {"type": "lean", "content": "488", "hidden": true}, {"type": "lean", "content": "489", "hidden": true}, {"type": "text", "content": "490"}, {"type": "lean", "content": "491", "hidden": true}, {"type": "text", "content": "492"}, {"type": "theorem", "text": "493", "lean": "theorem sums_of_squares (n : \u2115) :\n6 * (\u2211 i \u227c n, i ^ 2) = n * (n + 1) * (2 * n + 1) :=\n", "sideBar": false, "firstProofLineNumber": 37, "lastProofLineNumber": 60, "textBefore": "import natural_numbers.triangle_numbers -- hide\n\nset_option pp.structure_projections false -- hide\n\nnamespace exlean -- hide\n\nopen_locale mynum -- hide\n\nopen mynat -- hide\n\n/-\n# Natural numbers\n\n## Level 23: Sums of squares\n-/\n\nopen_locale fsum -- hide\n\n\n/-\n\n## Task\n\nProve the formula for sums of squares, that\n$$\n6\\left(\\sum_{i \\le n} i^2\\right) = n(n + 1)(2n + 1),\n$$\nfor every natural number $n$.\n-/\n\n/- Theorem : no-side-bar\n$6(\\sum_{i \\le n} i^2) = n(n + 1)(2n + 1)$, for every natural number $n$.\n-/\ntheorem sums_of_squares (n : \u2115) :\n6 * (\u2211 i \u227c n, i ^ 2) = n * (n + 1) * (2 * n + 1) :=\nbegin [pure_maths]\n", "proof": "  induction n,\n\n  case O :\n  { from rfl, },\n\n  case S : k h\n  { show 6 * (\u2211 i \u227c S(k), i ^ 2) = S(k) * (S(k) + 1) * (2 * S(k) + 1),\n    given h : 6 * (\u2211 i \u227c k, i ^ 2) = k * (k + 1) * (2 * k + 1),\n    calc\n    6 * (\u2211 i \u227c S(k), i ^ 2) \n        =  6 * (\u2211 i \u227c k, i ^ 2 + (S(k)) ^ 2)            : by rw fsum_S\n    ... = 6 * (\u2211 i \u227c k, i ^ 2) + 6 * (S(k) ^ 2)         : by rw mul_add\n    ... = k * (k + 1) * (2 * k + 1) + 6 * (S(k) ^ 2)    : by rw h\n    ... = k * (k + 1) * (2 * k + 1) + 6 * ((k + 1) ^ 2) : rfl\n    ... = (k + 1) * ((k + 1) + 1) * (2 * (k + 1) + 1)   : by ring }\n\n\n\n\n\n\n\n\n", "proof_hint": "sorry", "textAfter": "\nend\n\nend exlean -- hide", "height": 24, "editorText": "sorry", "lineOffset": 36, "name": "sums_of_squares", "statement": "(n : \u2115) :\n6 * (\u2211 i \u227c n, i ^ 2) = n * (n + 1) * (2 * n + 1)"}, {"type": "lean", "content": "494", "hidden": true}]}, {"name": "", "problemIndex": 10, "objects": [{"type": "lean", "content": "495", "hidden": true}, {"type": "lean", "content": "496", "hidden": true}, {"type": "lean", "content": "497", "hidden": true}, {"type": "lean", "content": "498", "hidden": true}, {"type": "lean", "content": "499", "hidden": true}, {"type": "text", "content": "500"}, {"type": "lean", "content": "501", "hidden": true}, {"type": "text", "content": "502"}, {"type": "text", "content": "503"}, {"type": "hint", "content": "504", "title": "505"}, {"type": "theorem", "text": "506", "lean": "theorem fsum_S' (f : \u2115 \u2192 \u2115) (n : \u2115) :\n\u2211 i \u227c n, f(i) = \u2211 i \u227a n, f(S(i)) + f(O) :=\n", "sideBar": true, "firstProofLineNumber": 62, "lastProofLineNumber": 92, "textBefore": "import natural_numbers.sums_of_squares -- hide\n\nset_option pp.structure_projections false -- hide\n\nnamespace exlean -- hide\n\nopen_locale mynum -- hide\n\nopen mynat -- hide\n\n/-\n# Natural numbers\n\n## Level 24: Change of index in a sum\n-/\n\nopen_locale fsum -- hide\n\n/-\nBy *definition*, we have\n$$\n\\sum_{i \\le n} f(i) = \\left(\\sum_{i < n} f(i)\\right) + f(n),\n$$\ncorresponding to the intuition\n$$\nf(0) + f(1) + \\dots + f(n) = (f(0) + \\dots + f(n-1)) + f(n).\n$$\nOne should expect also that\n$$\nf(0) + f(1) + \\dots + f(n)  = f(0) + (f(1) \\dots  + f(n)),\n$$\nwhich can be written as\n$$\n\\sum_{i \\le n} f(i) = \\sum_{i < n} f(i + 1) + f(0).\n$$\n\n\n\n-/\n\n/-\n\n## Task\n\nProve the claim above.\n-/\n\n/- Hint: A helpful result\nAt some point, you'll need to use a result of the form $(a + b) + c = (a + c) + b$.\nYou've proved a result that states exactly this earlier. Either use this theorem or use\none of the `ac_refl` or `ring` tactics.\n-/\n\n/- Theorem :\nFor any function $f : \\mathbb N \\to \\mathbb N$, we have \n$\\sum_{i \\le n} f(i) = \\sum_{i < n} f(i + 1) + f(0)$,\nfor every natural number $n$.\n-/\ntheorem fsum_S' (f : \u2115 \u2192 \u2115) (n : \u2115) :\n\u2211 i \u227c n, f(i) = \u2211 i \u227a n, f(S(i)) + f(O) :=\nbegin\n", "proof": "  induction n with k h,\n  { calc\n    \u2211 i \u227c O, f(i)\n        = \u2211 i \u227a O, f(i) + f(O)    : by rw fsum_S\n    ... = O + f(O)                : by rw fsum_O\n    ... = \u2211 i \u227a O, f(S(i)) + f(O) : by rw fsum_O,  },\n  { show \u2211 i \u227c S(k), f(i) = \u2211 i \u227a S(k), f(S(i)) + f(O),\n    given h : \u2211 i \u227c k, f(i) = \u2211 i \u227a k, f(S(i)) + f(O),\n    calc \n    \u2211 i \u227c S(k), f(i)\n        = \u2211 i \u227a S(k), f(i) + f(S(k))          : by rw fsum_S\n    ... = \u2211 i \u227a k, f(S(i)) + f(O) + f(S(k))   : by rw h\n    ... = (\u2211 i \u227a k, f(S(i)) + f(S(k))) + f(O) : by rw add_right_comm\n    ... = \u2211 i \u227a S(k), f(S(i)) + f(O)          : by rw fsum_S, },\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n", "proof_hint": "sorry", "textAfter": "\nend\n\nend exlean -- hide", "height": 31, "editorText": "sorry", "lineOffset": 61, "name": "fsum_S'", "statement": "(f : \u2115 \u2192 \u2115) (n : \u2115) :\n\u2211 i \u227c n, f(i) = \u2211 i \u227a n, f(S(i)) + f(O)"}, {"type": "lean", "content": "507", "hidden": true}]}, {"name": "", "problemIndex": 8, "objects": [{"type": "lean", "content": "508", "hidden": true}, {"type": "lean", "content": "509", "hidden": true}, {"type": "lean", "content": "510", "hidden": true}, {"type": "lean", "content": "511", "hidden": true}, {"type": "lean", "content": "512", "hidden": true}, {"type": "text", "content": "513"}, {"type": "lean", "content": "514", "hidden": true}, {"type": "text", "content": "515"}, {"type": "theorem", "text": "516", "lean": "theorem mul_fsum (f : \u2115 \u2192 \u2115) (x n : \u2115)  :\nx * \u2211 i \u227a n, f(i) = \u2211 i \u227a n, x * f(i) :=\n", "sideBar": true, "firstProofLineNumber": 38, "lastProofLineNumber": 56, "textBefore": "import natural_numbers.fsum_S_prime -- hide\n\nset_option pp.structure_projections false -- hide\n\nnamespace exlean -- hide\n\nopen_locale mynum -- hide\n\nopen mynat -- hide\n\n/-\n# Natural numbers\n\n## Level 25: Multiplying each term by a constant\n-/\n\nopen_locale fsum -- hide\n\n/-\n\n## Task\n\nFor any function $f : \\mathbb N \\to \\mathbb N$, for all natural numbers $x$ and $n$,\nprove that \n$$\nx\\sum_{i \\le n} f(i) = \\sum_{i < n} x f(i).\n$$\n-/\n\n/- Theorem :\nFor any function $f : \\mathbb N \\to \\mathbb N$, we have \n$x\\sum_{i \\le n} f(i) = \\sum_{i < n} x f(i)$,\nfor all natural numbers $x$ and $n$.\n-/\ntheorem mul_fsum (f : \u2115 \u2192 \u2115) (x n : \u2115)  :\nx * \u2211 i \u227a n, f(i) = \u2211 i \u227a n, x * f(i) :=\nbegin\n", "proof": "  induction n with k h,\n  { show x * \u2211 i \u227a O, f(i) = \u2211 i \u227a O, x * f(i), from rfl, },\n  { show x * \u2211 i \u227a S(k), f(i) = \u2211 i \u227a S(k), x * f(i),\n    given h : x * \u2211 i \u227a k, f(i) = \u2211 i \u227a k, x * f(i),\n    calc\n    x * \u2211 i \u227a S(k), f(i)\n        = x * (\u2211 i \u227a k, f(i) + f(k))        : by rw fsum_S\n    ... = x * \u2211 i \u227a k, f(i) + x * f(k)      : by rw mul_add\n    ... = \u2211 i \u227a k, x * f(i) + x * f(k)      : by rw h\n    ... = \u2211 i \u227a S(k), x * f(i)              : by rw fsum_S, },\n\n\n\n\n\n\n\n\n", "proof_hint": "sorry", "textAfter": "\nend\n\nend exlean -- hide", "height": 19, "editorText": "sorry", "lineOffset": 37, "name": "mul_fsum", "statement": "(f : \u2115 \u2192 \u2115) (x n : \u2115)  :\nx * \u2211 i \u227a n, f(i) = \u2211 i \u227a n, x * f(i)"}, {"type": "lean", "content": "517", "hidden": true}]}, {"name": "", "problemIndex": 8, "objects": [{"type": "lean", "content": "518", "hidden": true}, {"type": "lean", "content": "519", "hidden": true}, {"type": "lean", "content": "520", "hidden": true}, {"type": "lean", "content": "521", "hidden": true}, {"type": "lean", "content": "522", "hidden": true}, {"type": "text", "content": "523"}, {"type": "lean", "content": "524", "hidden": true}, {"type": "text", "content": "525"}, {"type": "theorem", "text": "526", "lean": "theorem fsum_add_distrib (f g : \u2115 \u2192 \u2115) (n : \u2115)  :\n\u2211 i \u227a n, (f(i) + g(i)) = \u2211 i \u227a n, f(i) + \u2211 i \u227a n, g(i) :=\n", "sideBar": true, "firstProofLineNumber": 40, "lastProofLineNumber": 71, "textBefore": "import natural_numbers.mul_fsum -- hide\n\nset_option pp.structure_projections false -- hide\n\nnamespace exlean -- hide\n\nopen_locale mynum -- hide\n\nopen mynat -- hide\n\n/-\n# Natural numbers\n\n## Level 26: Summing over sums\n-/\n\nopen_locale fsum -- hide\n\n/-\n\n## Task\n\nFor all functions $f$ and $g$ of type $\\mathbb N \\to \\mathbb N$,\nprove that \n$$\n\\sum_{i < n} (f(i) + g(i)) = \\sum_{i < n} f(i) + \\sum_{i < n} g(i),\n$$\nfor every natural number $n$.\n-/\n\n/- Theorem :\nFor all functions $f$ and $g$ of type $\\mathbb N \\to \\mathbb N$,\nwe have \n$\\sum_{i < n} (f(i) + g(i)) = \\sum_{i < n} f(i) + \\sum_{i < n} g(i),$\nfor all natural numbers $n$.\n-/\ntheorem fsum_add_distrib (f g : \u2115 \u2192 \u2115) (n : \u2115)  :\n\u2211 i \u227a n, (f(i) + g(i)) = \u2211 i \u227a n, f(i) + \u2211 i \u227a n, g(i) :=\nbegin\n", "proof": "  induction n with k h,\n\n  case O :\n  { show \u2211 i \u227a 0, (f(i) + g(i)) = \u2211 i \u227a 0, f(i) + \u2211 i \u227a 0, g(i), from rfl },\n\n  case S : k h\n  { show \u2211 i \u227a S(k), (f(i) + g(i)) = \u2211 i \u227a S(k), f(i) + \u2211 i \u227a S(k), g(i),\n    given h : \u2211 i \u227a k, (f(i) + g(i)) = \u2211 i \u227a k, f(i) + \u2211 i \u227a k, g(i),\n    calc\n    \u2211 i \u227a S(k), (f(i) + g(i))\n        = \u2211 i \u227a k, (f(i) + g(i)) + (f(k) + g(k))            : rfl\n    ... = (\u2211 i \u227a k, f(i) + \u2211 i \u227a k, g(i)) + (f(k) + g(k))   : by rw h\n    ... = (\u2211 i \u227a k, f(i) + f(k)) + (\u2211 i \u227a k, g(i) + g(k))   : by ac_refl\n    ... = \u2211 i \u227a S(k), f(i) + \u2211 i \u227a S(k), g(i)               : by rw [fsum_S, fsum_S], },\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n", "proof_hint": "sorry", "textAfter": "\nend\n\nend exlean -- hide", "height": 32, "editorText": "sorry", "lineOffset": 39, "name": "fsum_add_distrib", "statement": "(f g : \u2115 \u2192 \u2115) (n : \u2115)  :\n\u2211 i \u227a n, (f(i) + g(i)) = \u2211 i \u227a n, f(i) + \u2211 i \u227a n, g(i)"}, {"type": "lean", "content": "527", "hidden": true}]}, {"name": "", "problemIndex": 10, "objects": [{"type": "lean", "content": "528", "hidden": true}, {"type": "lean", "content": "529", "hidden": true}, {"type": "lean", "content": "530", "hidden": true}, {"type": "lean", "content": "531", "hidden": true}, {"type": "lean", "content": "532", "hidden": true}, {"type": "text", "content": "533"}, {"type": "lean", "content": "534", "hidden": true}, {"type": "text", "content": "535"}, {"type": "hint", "content": "536", "title": "537"}, {"type": "hint", "content": "538", "title": "539"}, {"type": "theorem", "text": "540", "lean": "theorem fsum_mul_fsum (f g : \u2115 \u2192 \u2115) (m n : \u2115)  :\n(\u2211 i \u227a m, f(i)) * (\u2211 j \u227a n, g(j)) = \u2211 i \u227a m, \u2211 j \u227a n, f(i) * g(j) :=\n", "sideBar": true, "firstProofLineNumber": 51, "lastProofLineNumber": 77, "textBefore": "import natural_numbers.fsum_add_distrib -- hide\n\nset_option pp.structure_projections false -- hide\n\nnamespace exlean -- hide\n\nopen_locale mynum -- hide\n\nopen mynat -- hide\n\n/-\n# Natural numbers\n\n## Level 27: Multiplying sums\n-/\n\nopen_locale fsum -- hide\n\n/-\n\n## Task\n\nFor all functions $f$ and $g$ of type $\\mathbb N \\to \\mathbb N$,\nprove that \n$$\n\\left(\\sum_{i < m} f(i)\\right) \\left(\\sum_{j < n} g(j)\\right)  =\n\\sum_{i < m} \\sum_{j < n} f(i)g(j)\n$$\nfor all natural numbers $m$ and $n$.\n-/\n\n/- Hint : Having trouble with the induction?\nThere's a painful way and an easy (or easier) way to prove this result. The \neasier way is to try induction on `m`, rather than induction on `n`.`\n-/\n\n/- Hint : A useful result\nAt some point in the proof, you'll need to use the results `mul_fsum` and `add_mul`.\n-/\n\n/- Theorem :\nFor all functions $f$ and $g$ of type $\\mathbb N \\to \\mathbb N$,\nwe have \n$\\left(\\sum_{i < m} f(i)\\right) \\left(\\sum_{j < n} g(j)\\right)  =\n\\sum_{i < m} \\sum_{j < n} f(i)g(j)$,\nfor all natural numbers $n$.\n-/\ntheorem fsum_mul_fsum (f g : \u2115 \u2192 \u2115) (m n : \u2115)  :\n(\u2211 i \u227a m, f(i)) * (\u2211 j \u227a n, g(j)) = \u2211 i \u227a m, \u2211 j \u227a n, f(i) * g(j) :=\nbegin\n", "proof": "  induction m with k h,\n\n  case O :\n  { show (\u2211 (i : \u2115) \u227a O, f i) * \u2211 (j : \u2115) \u227a n, g j = \u2211 (i : \u2115) \u227a O, \u2211 (j : \u2115) \u227a n, f i * g j,\n    rw [fsum_O, fsum_O, O_mul], },\n\n  case S : k h\n  { show (\u2211 i \u227a S(k), f(i)) * (\u2211 j \u227a n, g(j)) = \u2211 i \u227a S(k), \u2211 j \u227a n, f(i) * g(j),\n    given h : (\u2211 i \u227a k, f(i)) * (\u2211 j \u227a n, g(j)) = \u2211 i \u227a k, \u2211 j \u227a n, f(i) * g(j),\n    calc\n    (\u2211 i \u227a S(k), f(i)) * (\u2211 j \u227a n, g(j))\n        = (\u2211 i \u227a k, f(i) + f(k)) * (\u2211 j \u227a n, g(j))                      : by rw fsum_S\n    ... = (\u2211i \u227a k, f(i)) * (\u2211 j \u227a n, g(j)) + f(k) * (\u2211 j \u227a n, g(j))   : by rw add_mul\n    ... = \u2211 i \u227a k, \u2211 j \u227a n, f(i) * g(j) + f(k) * (\u2211 j \u227a n, g(j))      : by rw h\n    ... = \u2211 i \u227a k, \u2211 j \u227a n, f(i) * g(j) + \u2211 j \u227a n, f(k) * g(j)        : by rw mul_fsum\n    ... =  \u2211 i \u227a S(k), \u2211 j \u227a n, f(i) * g(j)                             : rfl, },\n\n\n\n\n\n\n\n\n\n\n", "proof_hint": "sorry", "textAfter": "\nend\n\n\n\n\nend exlean -- hide", "height": 27, "editorText": "sorry", "lineOffset": 50, "name": "fsum_mul_fsum", "statement": "(f g : \u2115 \u2192 \u2115) (m n : \u2115)  :\n(\u2211 i \u227a m, f(i)) * (\u2211 j \u227a n, g(j)) = \u2211 i \u227a m, \u2211 j \u227a n, f(i) * g(j)"}, {"type": "lean", "content": "541", "hidden": true}]}], "parents": [0]}, {"name": "542", "levels": [{"name": "", "problemIndex": 12, "objects": [{"type": "lean", "content": "543", "hidden": true}, {"type": "text", "content": "544"}, {"type": "axiom", "content": "545", "name": "and.elim_left (h : p \u2227 q) :", "sideBar": true}, {"type": "axiom", "content": "546", "name": "and.elim_right (h : p \u2227 q) :", "sideBar": true}, {"type": "lean", "content": "547", "hidden": false}, {"type": "text", "content": "548"}, {"type": "lean", "content": "549", "hidden": false}, {"type": "text", "content": "550"}, {"type": "lean", "content": "551", "hidden": false}, {"type": "tactic", "content": "552", "name": "cases", "sideBar": true}, {"type": "lean", "content": "553", "hidden": true}, {"type": "text", "content": "554"}, {"type": "theorem", "text": "555", "lean": "theorem decomposing_and (p q r : Prop) (h : (r \u2227 (p \u2227 q)) \u2227 r) :\nq :=\n", "sideBar": false, "firstProofLineNumber": 109, "lastProofLineNumber": 116, "textBefore": "import data.int.basic tactic.pure_maths -- hide\n\n/-\n# Propositional logic\n## Level 1: And elimination\n\nLet $p$ and $q$ be propositions (mathematical statements). The formal statement $p \\land q$\n(read '$p$ conjunction $q$')\ncorresponds to the informal statement '$p$ and $q$'.\n\nSuppose you are given a hypothesis `h : p \u2227 q`. Then\n\n1. [left and elimination] `h.left` is a proof of `p` and\n2. [right and elimination] `h.right` is a proof of `q`.\n\nHere, `h.left` is an abbreviation for `and.elim_left h`. Likewise for `h.right`.\n\n**Theorem**: Let $x$ be an integer. Supose $h : (x > 0) \\land (x ^ 2 = 16)$. Then $x ^ 2 = 16$.\n\n**Proof**: The result follows from right and elimination on $h$. \u220e\n\nThe Lean proof is below.\n\n**Notation**: the symbol `\u2227` in Lean is typed `\\and`.\n-/\n\n\n/- Axiom : and.elim_left (h : p \u2227 q) :\np\n-/\n\n/- Axiom : and.elim_right (h : p \u2227 q) :\nq\n-/\n\n\n\nexample (x : \u2124) (h : (x > 0) \u2227 (x * x = 16)) : x * x = 16 :=\nbegin\n  from h.right,\nend\n\n/-\nAlternatively, the `cases` tactic will decompose the `\u2227` into both the left and right sides.\nBelow `cases h with h\u2081 h\u2082` decomposes `h` into `h\u2081 : x > 0` and `h\u2082 : x * x = 16`.\n-/\n\nexample (x : \u2124) (h : (x > 0) \u2227 (x * x = 16)) : x * x = 16  :=\nbegin\n  cases h with h\u2081 h\u2082,  \n  show x * x = 16, from h\u2082,\nend\n\n\n\n/-\nFrequently, we consider the conjunction of several statements. \nWe can, for instance, derive $q$ given the assumption $p \\land (q \\land r).\n-/\n\nexample (p q r : Prop) (h : p \u2227 (q \u2227 r)) : q :=\nbegin\n  have h\u2082 : q \u2227 r, from h.right,\n  show q, from h\u2082.left,\nend\n\n\n/- Tactic : cases\n`cases` is a general-purpose elimination tactic. It it used to 'decompose' a hypothesis into\nits constituent parts.\n\n### Examples\n\n* Given `h : \u2203 (x : \u2124), x + 5 = y`, typing `cases h with m h\u2082` replaces `h` with `m : \u2124` and\n`h\u2082 : m + 5 = y`.\n\n* Given `h : p \u2227 q`, typing `cases h with hp hq` replaces `h` with `hp : p` and `hq : q`.\n\n* Given `h : p \u2228 q`, typing `cases h with hp hq` replaces the current goal with two goals\n(1) in which `h` is replaced with `hp : p` and (2) in which `h` is replaced with `hq : q`.\n\n* Given `x : \u2115`, typing `cases x with k` replaces the goal with two new goals: (1) a goal in which\nevery occurence of `x` is replaced with `0` and (2) a goal with a new variable `k : \u2115` and in \nwhich every occurrence of `x` is replaced with `succ k`.\n\n* Given `h : \u2203 (x : X), P(x)`, typing `cases h with y h\u2082` introduces a new variable `y : X`\nand replaces `h` with `h\u2082 : P(y)`.\n-/\n\n\nnamespace exlean -- hide\n\n/-\n## Tasks\n\n1. Replace `sorry` below with a Lean proof using `have` together with left and right and elimination.\nAdapt the proof of the example above.\n2. Write another Lean proof using `cases`.\n3. On a piece of paper, state and give a handwritten proof of this result.\n-/\n\n/- Theorem : no-side-bar\nLet $p$, $q$, and $r$ be propositions. Assuming $h : (r \\land (p \\land q)) \\land r$,\nwe have $q$.\n-/\ntheorem decomposing_and (p q r : Prop) (h : (r \u2227 (p \u2227 q)) \u2227 r) :\nq :=\nbegin\n", "proof": "  have h\u2082 : r \u2227 (p \u2227 q), from h.left,\n  have h\u2083 : p \u2227 q, from h\u2082.right,\n  show q, from h\u2083.right,\n\n\n\n\n", "proof_hint": "sorry", "textAfter": "\nend\n\nend exlean -- hide", "height": 8, "editorText": "sorry", "lineOffset": 108, "name": "decomposing_and", "statement": "(p q r : Prop) (h : (r \u2227 (p \u2227 q)) \u2227 r) :\nq"}, {"type": "lean", "content": "556", "hidden": true}]}, {"name": "", "problemIndex": 10, "objects": [{"type": "lean", "content": "557", "hidden": true}, {"type": "text", "content": "558"}, {"type": "lean", "content": "559", "hidden": false}, {"type": "text", "content": "560"}, {"type": "lean", "content": "561", "hidden": false}, {"type": "lean", "content": "562", "hidden": true}, {"type": "text", "content": "563"}, {"type": "tactic", "content": "564", "name": "split", "sideBar": true}, {"type": "axiom", "content": "565", "name": "and.intro (h\u2081 : p) (h\u2082 : q) :", "sideBar": true}, {"type": "lean", "content": "566", "hidden": true}, {"type": "theorem", "text": "567", "lean": "theorem and_intro_thm (h\u2081 : p) (h\u2082 : q) (h\u2083 : r) : r \u2227 q :=\n", "sideBar": false, "firstProofLineNumber": 70, "lastProofLineNumber": 74, "textBefore": "import tactic.pure_maths -- hide\n\n/-\n# Propositional logic\n## Level 2: And introduction\n\n## And introduction\n\nTo *prove* $p\\land q$ is to prove $p$ and to prove $q$.\n\nIn Lean, if `h\u2081 : p` is a proof of `p` and `h\u2082 : q` is a proof of `q`, then `and.intro h\u2081 h\u2082`\nis a proof of `p \u2227 q`.\n-/\n\nexample (p q : Prop) (h\u2081 : p) (h\u2082 : q) : p \u2227 q :=\nbegin\n  from and.intro h\u2081 h\u2082,\nend\n\n/-\nThe `split` tactic is an alternative (backward) proof technique. If the target is to prove `p \u2227 q`,\nthen `split` replaces the goal with two new goals: (1) to prove `p` and (2) to prove `q`.\n-/\n\nexample (p q : Prop) (h\u2081 : p) (h\u2082 : q) : p \u2227 q :=\nbegin\n  split,\n  { show p, from h\u2081, }, -- The first goal.\n  { show q, from h\u2082, }, -- The second goal.\nend\n\n\nnamespace exlean -- hide\n/-\n## Tasks\n\n1. Replace `sorry` below with a Lean proof using `and.intro`.\n2. Write another Lean proof using `split`.\n3. On a piece of paper, state and give a handwritten proof of this result.\n\n**Notation**: Recall that `h\u2081` is written `h\\1`.\n-/\n\n/- Tactic : split\n\nThe `split` tactic splits a 'compound' target into multiple goals. \n\n### Examples\n\n`split` turns the target `\u22a2 p \u2227 q` into two goals: (1) `\u22a2 p` and (2)  `\u22a2 q`.\n\nEqually, if the target is `\u22a2 p \u2194 q`, split creates the goals (1) to prove\n`p \u2192 q` and (2) to prove `q \u2192 p`.\n-/\n\n\n/- Axiom: and.intro (h\u2081 : p) (h\u2082 : q) :\np \u2227 q\n-/\n\nvariables (p q r : Prop) -- hide\n\n\n/- Theorem : no-side-bar\nLet $p$, $q$, and $r$ be propositions. Assuming $h_1 : p$, $h_2 : q$, and $h_3 : r$, we have\n$h : r \\land q$.\n-/\ntheorem and_intro_thm (h\u2081 : p) (h\u2082 : q) (h\u2083 : r) : r \u2227 q :=\nbegin\n", "proof": "  split,\n  { show r, from h\u2083, },\n  { show q, from h\u2082, },\n\n", "proof_hint": "sorry", "textAfter": "\nend\n\nend exlean -- hide", "height": 5, "editorText": "sorry", "lineOffset": 69, "name": "and_intro_thm", "statement": "(h\u2081 : p) (h\u2082 : q) (h\u2083 : r) : r \u2227 q"}, {"type": "lean", "content": "568", "hidden": true}]}, {"name": "", "problemIndex": 5, "objects": [{"type": "lean", "content": "569", "hidden": true}, {"type": "text", "content": "570"}, {"type": "lean", "content": "571", "hidden": true}, {"type": "lean", "content": "572", "hidden": true}, {"type": "text", "content": "573"}, {"type": "theorem", "text": "574", "lean": "theorem and.swap (h : p \u2227 q) : q \u2227 p :=\n", "sideBar": true, "firstProofLineNumber": 29, "lastProofLineNumber": 38, "textBefore": "import tactic.pure_maths -- hide\n\n/-\n# Propositional logic\n## Level 3: And swap\n\n-/\n\nnamespace exlean -- hide\n\nvariables {p q : Prop} -- hide\n\n/-\n## Task\n\nIntuitively, you'd expect that if you have $h : p \\land q$, then you can derive $q \\land p$.\nIn this level, you'll do just that!\n\nRecall you can:\n* use `cases`, or `.left` and `.right` for and elimination and\n* use `split` or `and.intro` for and introduction.\n-/\n\n/- Theorem :\nLet $p$ and $q$ be propositions. Assuming $h : p \\land q$, we have $h : q \\land p$.\n-/\ntheorem and.swap (h : p \u2227 q) : q \u2227 p :=\nbegin\n", "proof": "  split,\n  { show q, from h.right, },\n  { show p, from h.left, },\n\n\n\n\n\n\n", "proof_hint": "sorry", "textAfter": "\nend\n\nend exlean -- hide", "height": 10, "editorText": "sorry", "lineOffset": 28, "name": "and.swap", "statement": "(h : p \u2227 q) : q \u2227 p"}, {"type": "lean", "content": "575", "hidden": true}]}, {"name": "", "problemIndex": 8, "objects": [{"type": "lean", "content": "576", "hidden": true}, {"type": "text", "content": "577"}, {"type": "lean", "content": "578", "hidden": true}, {"type": "lean", "content": "579", "hidden": false}, {"type": "text", "content": "580"}, {"type": "lean", "content": "581", "hidden": false}, {"type": "lean", "content": "582", "hidden": true}, {"type": "text", "content": "583"}, {"type": "theorem", "text": "584", "lean": "theorem imp_elim_example (h\u2081 : p \u2192 q \u2227 r) (h\u2082 : p) : q :=\n", "sideBar": false, "firstProofLineNumber": 46, "lastProofLineNumber": 55, "textBefore": "import propositional_logic.and_swap -- hide\n\n/-\n# Propositional logic\n## Level 4: Implication elimination\n\nGiven proofs of $p \\to q$ ($p$ implies $q$) and $p$, you know $q$. This is *implication elimination*,\nsometimes called *modus ponens*.\n\nIn Lean, if `h\u2081 : p \u2192 q` is a proof of `p \u2192 q` and `h\u2082 : p` is a proof of `p`, then `h\u2081 h\u2082` is a proof\nof `q`.\n\n**Notation**: The symbol `\u2192` is typed `\\r`.\n-/\n\nvariables (p q r : Prop) -- hide\n\nexample (h\u2081 : p \u2192 q) (h\u2082 : p) : q :=\nbegin\n  from h\u2081 h\u2082\nend\n\n/-\nAs an example, we'll prove $r$ on the assumptions $h_1 : p \\to (q \\land r)$ and $h_2 : p$.\n-/\n\nexample (h\u2081 : p \u2192 (q \u2227 r)) (h\u2082 : p) : r :=\nbegin\n  have h\u2083 : q \u2227 r, from h\u2081 h\u2082,\n  show r, from h\u2083.right,\nend\n\nnamespace exlean -- hide\n/-\n## Task\n\nProve the following result in Lean.\n-/\n\n\n/- Theorem : no-side-bar\nLet $p$, $q$, and $r$ be propositions. Assuming $h_1 : p \\to q \\land r$ and $h_2 : p$, we have $q$.\n-/\ntheorem imp_elim_example (h\u2081 : p \u2192 q \u2227 r) (h\u2082 : p) : q :=\nbegin\n", "proof": "  have h\u2083 : q \u2227 r, from h\u2081 h\u2082,\n  show q, from h\u2083.left,\n\n\n\n\n\n\n\n", "proof_hint": "sorry", "textAfter": "\nend\n\nend exlean -- hide", "height": 10, "editorText": "sorry", "lineOffset": 45, "name": "imp_elim_example", "statement": "(h\u2081 : p \u2192 q \u2227 r) (h\u2082 : p) : q"}, {"type": "lean", "content": "585", "hidden": true}]}, {"name": "", "problemIndex": 14, "objects": [{"type": "lean", "content": "586", "hidden": true}, {"type": "text", "content": "587"}, {"type": "lean", "content": "588", "hidden": true}, {"type": "lean", "content": "589", "hidden": false}, {"type": "lean", "content": "590", "hidden": true}, {"type": "text", "content": "591"}, {"type": "axiom", "content": "592", "name": "id {p} :", "sideBar": true}, {"type": "lean", "content": "593", "hidden": true}, {"type": "lean", "content": "594", "hidden": false}, {"type": "lean", "content": "595", "hidden": true}, {"type": "lean", "content": "596", "hidden": true}, {"type": "text", "content": "597"}, {"type": "lean", "content": "598", "hidden": false}, {"type": "text", "content": "599"}, {"type": "theorem", "text": "600", "lean": "theorem imp_intro_example : (p \u2227 q) \u2192 p :=\n", "sideBar": false, "firstProofLineNumber": 71, "lastProofLineNumber": 76, "textBefore": "import propositional_logic.imp_elim -- hide\n\n/-\n# Propositional logic\n## Level 5: Implication introduction\n\nTo prove $p \\to q$ it to assume $p$ and derive $q$.\n\nIn Lean, if the target is `p \u2192 q`, typing `assume h : p` introduces `h : p` into the context\nand replaces the target with one of proving `q`.\n\nHere, we prove $(p \\land q) \\to p$.\n-/\n\nvariables (p q : Prop) -- hide\n\nexample : (p \u2227 q) \u2192 p :=\nbegin\n  assume h : p \u2227 q,\n  show p, from h.left,\nend\n\nnamespace hidden -- hide\n\n/-\nA useful result, `id` asserts that `s \u2192 s`, for any `s`.\n-/\n\n/- Axiom : id {p} :\np \u2192 p\n-/\n\nvariable (s : Prop) -- hide\n\nlemma id : s \u2192 s :=\nbegin\n  assume h : s,\n  show s, from h,\nend\n\n\nend hidden -- hide\n\nnamespace exlean -- hide\n\n/-\nIn the fun example below, we prove $p \\to (q \\to p)$.\n-/\n\nexample : p \u2192 (q \u2192 p) :=\nbegin\n  assume h\u2081 : p,\n  show q \u2192 p,\n  assume h\u2082 : q,\n  show p, from h\u2081,\nend\n\n\n/-\n## Task\n\nProve the following result in Lean.\n-/\n\n\n/- Theorem : no-side-bar\nLet $p$ and $q$ be propositions. Then $(p \\land q) \\to p$.\n-/\ntheorem imp_intro_example : (p \u2227 q) \u2192 p :=\nbegin\n", "proof": "  assume h : p \u2227 q,\n  show p, from h.left,\n\n\n\n", "proof_hint": "sorry", "textAfter": "\nend\n\nend exlean -- hide", "height": 6, "editorText": "sorry", "lineOffset": 70, "name": "imp_intro_example", "statement": "(p \u2227 q) \u2192 p"}, {"type": "lean", "content": "601", "hidden": true}]}, {"name": "", "problemIndex": 9, "objects": [{"type": "lean", "content": "602", "hidden": true}, {"type": "text", "content": "603"}, {"type": "lean", "content": "604", "hidden": true}, {"type": "lean", "content": "605", "hidden": true}, {"type": "axiom", "content": "606", "name": "not_not_intro (p : Prop)", "sideBar": true}, {"type": "lean", "content": "607", "hidden": false}, {"type": "text", "content": "608"}, {"type": "lean", "content": "609", "hidden": false}, {"type": "text", "content": "610"}, {"type": "theorem", "text": "611", "lean": "theorem mt : (p \u2192 q) \u2192 (\u00acq \u2192 \u00acp) :=\n", "sideBar": false, "firstProofLineNumber": 69, "lastProofLineNumber": 82, "textBefore": "import propositional_logic.imp_intro -- hide\n\n/-\n# Propositional logic\n## Level 6: Proving negations\n\nGiven a proposition $p$, we write $\\neg p$ to mean 'not $p$'. Thus, $\\neg (x = 5)$ is the same as\n$x \\ne 5$. Formally, $\\neg p$ is an abbreviation for $p\\to\\bot$, where $\\bot$ is read 'false'\nor 'contradiction'.\n\nWe've seen that to prove $p \\to q$ is to assume $p$ and derive $q$. Thus, to prove $\\neg p$ is to\nassume $p$ and derive $\\bot$.\n\n**Notation**: The symbol `\u00ac` is typed `\\n` or `\\not`. The mathematical symbol $\\bot$ is written\n`false` in Lean.\n\nUsing these ideas, we'll prove $p \\to \\neg\\neg p$.\n-/\n\nnamespace exlean -- hide\n\nvariables {p q r : Prop} -- hide\n\n/- Axiom : not_not_intro (p : Prop)\np \u2192 \u00ac\u00acp\n-/\nlemma not_not_intro : p \u2192 \u00ac\u00acp :=\nbegin \n  assume h\u2081 : p,\n  show \u00ac\u00acp,\n  show \u00acp \u2192 false,\n  assume h\u2082 : \u00acp, -- So h\u2082 : p \u2192 false\n  show false, from h\u2082 h\u2081,\nend\n\n/-\nImplication elimination is used in the last line of the proof above. Lean permits *backward*\nimplication elimination via the `apply` tactic.\nIf the target is to prove `q` and if `h : p \u2192 q`, then typing `apply h`, transforms\nthe target to one of proving `p`.\n\nBelow, we prove $r$ on the assumptions $h_1 : (p \\land q) \\to r)$, $h_2 : p$ and $h_3 : q$.\nThe first step is to realise that $r$ is the 'conclusion' of $h_1$, whence `apply h\u2081` transforms\nthe goal to one of proving $p \\land q$.\n-/\n\nexample (h\u2081 : (p \u2227 q) \u2192 r) (h\u2082 : p) (h\u2083 : q) : r :=\nbegin\n  apply h\u2081,\n  show p \u2227 q, from and.intro h\u2082 h\u2083,\nend\n\n/-\n## Task\n\nProve the logical principle that $\\neg q \\to \\neg p$ follows from $p \\to q$. This is\nsometimes called *modus tollens*.\n\nYou'll need to perform implication introduction three times and implication elimination twice.\nFor fun, try both formward and backward implication elimination.\n-/\n\n\n/- Theorem : no-side-bar\nLet $p$ and $q$ be propositions. Then $(p \\to q) \\to (\\neg q \\to \\neg p)$.\n-/\ntheorem mt : (p \u2192 q) \u2192 (\u00acq \u2192 \u00acp) :=\nbegin\n", "proof": "  assume h\u2081 : p \u2192 q,\n  show \u00acq \u2192 \u00ac p,\n  assume h\u2082 : \u00acq, -- So h\u2082 : q \u2192 false\n  show \u00acp,\n  show p \u2192 false,\n  assume h\u2083 : p,\n  show false,\n  have h\u2084 : q, from h\u2081 h\u2083,\n  show false, from h\u2082 h\u2084,\n/-   apply h\u2082,\n  show q, from h\u2081 h\u2083,\n -/\n\n", "proof_hint": "sorry", "textAfter": "\nend\n\nend exlean -- hide", "height": 14, "editorText": "sorry", "lineOffset": 68, "name": "mt", "statement": "(p \u2192 q) \u2192 (\u00acq \u2192 \u00acp)"}, {"type": "lean", "content": "612", "hidden": true}]}, {"name": "", "problemIndex": 18, "objects": [{"type": "lean", "content": "613", "hidden": true}, {"type": "text", "content": "614"}, {"type": "lean", "content": "615", "hidden": true}, {"type": "lean", "content": "616", "hidden": true}, {"type": "lean", "content": "617", "hidden": false}, {"type": "lean", "content": "618", "hidden": true}, {"type": "lean", "content": "619", "hidden": false}, {"type": "text", "content": "620"}, {"type": "lean", "content": "621", "hidden": false}, {"type": "axiom", "content": "622", "name": "or.inl", "sideBar": true}, {"type": "axiom", "content": "623", "name": "or.inr", "sideBar": true}, {"type": "tactic", "content": "624", "name": "left", "sideBar": true}, {"type": "tactic", "content": "625", "name": "right", "sideBar": true}, {"type": "text", "content": "626"}, {"type": "lean", "content": "627", "hidden": false}, {"type": "text", "content": "628"}, {"type": "lean", "content": "629", "hidden": false}, {"type": "text", "content": "630"}, {"type": "theorem", "text": "631", "lean": "theorem or_intro_example (h : q) : (p \u2228 q) \u2228 r :=\n", "sideBar": false, "firstProofLineNumber": 99, "lastProofLineNumber": 104, "textBefore": "import propositional_logic.proving_negation -- hide\n\n/-\n# Propositional logic\n## Level 7: Or introduction\n\nThe proposition $p \\lor q$ has the informal meaning '$p$ or $q$'. To prove $p \\lor q$ is:\n1. [left or introduction] to prove $p$ or`\n2. [right or introduction] to prove $q$.\n\nIn Lean, suppose `h\u2081 : p` is a proof of `p` and `h\u2082 : q` is a proof of `q`. Then\n`or.inl h\u2081` is a proof of `p \u2228 q` and `or.inr h\u2082` is a proof of `p \u2228 q`.\n\n**Notation**: `\u2228` is typed `\\or`.\n-/\n\nnamespace exlean -- hide\n\nvariables {p q r : Prop} -- hide\n\nexample (h\u2081 : p) : p \u2228 q :=\nbegin\n  from or.inl h\u2081,\nend\n\n-- hide\n\nexample (h\u2082 : q) : p \u2228 q :=\nbegin\n  from or.inr h\u2082,\nend\n\n\n/-\nFor example, we'll prove `p \u2228 (q \u2227 r)` given `h : p`.\n-/\nexample (h : p) : p \u2228 (q \u2227 r) :=\nbegin\n  from or.inl h,\nend\n\n/- Axiom: or.inl\n  (h : p) : p \u2228 q\n-/\n\n/- Axiom: or.inr\n  (h : q) : p \u2228 q\n-/\n\n\n/- Tactic : left\n`left` changes a goal of proving `p \u2228 q` into a goal of proving `p`.\n-/\n\n/- Tactic : right\n`right` changes a goal of proving `p \u2228 q` into a goal or proving `q`.\n-/\n\n/-\nAs a backward alternative, if the target is to prove `p \u2228 q`, the `left` tactic replaces the target\nwith one of proving `p`. Likewise for the `right` tactic.\n\nHere is a backward proof that $q \\lor (p \\lor r)$ follows from $h : p$.\n-/\n\nexample (h : p) : q \u2228 (p \u2228 r) :=\nbegin \n  show q \u2228 (p \u2228 r),\n  right,\n  show p \u2228 r,\n  left,\n  show p, from h,\nend\n\n/-\nTo prove the same result forward involves the introduction of hypotheses.\n-/\n\nexample (h : p) : q \u2228 (p \u2228 r) :=\nbegin\n  have h\u2082 : p \u2228 r, from or.inl h,\n  show q \u2228 (p \u2228 r), from or.inr h\u2082,\nend\n\n\n/-\n## Task\n\nProve the following in Lean and by hand.\n-/\n\n\n/- Theorem : no-side-bar\nLet $p$, $q$ and $r$ be propositions. Then $(p \\lor q) \\lor r$ follows from the assumption\n$h : q$.\n-/\ntheorem or_intro_example (h : q) : (p \u2228 q) \u2228 r :=\nbegin\n", "proof": "  have h\u2082 : p \u2228 q, from or.inr h,\n  show (p \u2228 q) \u2228 r, from or.inl h\u2082,\n\n\n\n", "proof_hint": "sorry", "textAfter": "\nend\n\nend exlean -- hide", "height": 6, "editorText": "sorry", "lineOffset": 98, "name": "or_intro_example", "statement": "(h : q) : (p \u2228 q) \u2228 r"}, {"type": "lean", "content": "632", "hidden": true}]}, {"name": "", "problemIndex": 7, "objects": [{"type": "lean", "content": "633", "hidden": true}, {"type": "text", "content": "634"}, {"type": "lean", "content": "635", "hidden": true}, {"type": "lean", "content": "636", "hidden": true}, {"type": "axiom", "content": "637", "name": "or.swap (h : p \u2228 q)", "sideBar": true}, {"type": "lean", "content": "638", "hidden": false}, {"type": "text", "content": "639"}, {"type": "theorem", "text": "640", "lean": "theorem or_elim_example (h : (p \u2227 q) \u2228 (r \u2227 p)) : p :=\n", "sideBar": false, "firstProofLineNumber": 59, "lastProofLineNumber": 72, "textBefore": "import propositional_logic.or_introduction -- hide\n\n/-\n# Propositional logic\n## Level 8: Or elimination\n\nSuppose you are given $h : p \\lor q$. To prove $r$ is to\n1. Assume $p$ and derive $r$ and (separately) to\n2. assume $q$ and derive $r$.\n\nThis is (backward) *or elimination*.\n\nFor example, we prove $q \\lor p$ on the assumption $h : p \\lor q$.\n\n**Proof**:\n1. Assume $h_2 : p$. We must show $q \\lor p$. This follows from right or introduction on $h_2$.\n2. Assume $h_3 : q$. We must show $q \\lor p$. This follows from left or introduction on $h_3$.\n\n\nIn Lean, the `cases` tactic performs backward or elimination. With hypotheses as above,\n`cases h with h\u2082 h\u2083` creates two new goals:\n1. to prove `r` under the assumption `h\u2082 : p` and, separately\n2. to prove `r` under the assumption `h\u2083 : q`.\n\nHere is a Lean proof of the result above.\n-/\n\nnamespace exlean -- hide\n\nvariables {p q r : Prop} -- hide\n\n/- Axiom : or.swap (h : p \u2228 q)\nq \u2228 p\n-/\nlemma or.swap (h : p \u2228 q) : q \u2228 p :=\nbegin\n  cases h with h\u2082 h\u2083,\n  { given h\u2082 : p,\n    show q \u2228 p, from or.inr h\u2082, },\n  { given h\u2083 : q,\n    show q \u2228 p, from or.inl h\u2083, },\nend\n\n\n/-\n## Task\n\nProve the following in Lean and by hand. For the adventurous, see the end of this level for discussion\nof *forward* or elimination. Come back and try a forward argument of this result.\n-/\n\n\n/- Theorem : no-side-bar\nLet $p$, $q$ and $r$ be propositions. Then $p$ follows from the assumption\n$h : (p \\land q) \\lor (r \\land p)$.\n-/\ntheorem or_elim_example (h : (p \u2227 q) \u2228 (r \u2227 p)) : p :=\nbegin\n", "proof": "  cases h with h\u2082 h\u2083,\n  { given h\u2082 : p \u2227 q,\n    show p, from h\u2082.left, },\n  { given h\u2083 : r \u2227 p,\n    show p, from h\u2083.right, },\n\n\n\n\n\n\n\n\n", "proof_hint": "sorry", "textAfter": "\nend\n\n\n/-\n## Forward or elimination\n\nI find it simplest to use or elimination in its backward form. For the sake of completeness, I\ninclude the forward version.\n\nLet $h : p \\lor q$ be a proof of $p \\lor q$, $h_1 : p \\to r$ a proof of $p \\to r$ and let $h_2 : q \\to r$ be a proof of $q \\to r$.\nThen (forward) *or elimination* applied to $h$, $h_1$, and $h_2$ is a proof of $r$.\n\nThe Lean name of the formard or elimination result is `or.elim`. Below, we use it to re-prove `or.swap`.\n-/\n\n/- Axiom : or.elim (h : p \u2228 q) (h\u2081 : p \u2192 r) (h\u2082 : q \u2192 r) :\nr\n-/\n\nexample  (h : p \u2228 q) : q \u2228 p :=\nbegin\n  have h\u2081 : p \u2192 (q \u2228 p),\n  { assume k : p,\n    show q \u2228 p, from or.inr k, },\n  -- hide\n  have h\u2082 : q \u2192 (q \u2228 p),\n  { assume k : q,\n    show q \u2228 p, from or.inl k,  },\n  -- hide\n  show q \u2228 p, from or.elim h h\u2081 h\u2082,\nend\n\nend exlean -- hide", "height": 14, "editorText": "sorry", "lineOffset": 58, "name": "or_elim_example", "statement": "(h : (p \u2227 q) \u2228 (r \u2227 p)) : p"}, {"type": "text", "content": "641"}, {"type": "axiom", "content": "642", "name": "or.elim (h : p \u2228 q) (h\u2081 : p \u2192 r) (h\u2082 : q \u2192 r) :", "sideBar": true}, {"type": "lean", "content": "643", "hidden": false}, {"type": "lean", "content": "644", "hidden": true}, {"type": "lean", "content": "645", "hidden": false}, {"type": "lean", "content": "646", "hidden": true}, {"type": "lean", "content": "647", "hidden": false}, {"type": "lean", "content": "648", "hidden": true}]}, {"name": "", "problemIndex": 11, "objects": [{"type": "lean", "content": "649", "hidden": true}, {"type": "text", "content": "650"}, {"type": "axiom", "content": "651", "name": "iff.elim_left (h : p \u2194 q) :", "sideBar": true}, {"type": "axiom", "content": "652", "name": "iff.elim_right (h : p \u2194 q) :", "sideBar": true}, {"type": "lean", "content": "653", "hidden": true}, {"type": "lean", "content": "654", "hidden": true}, {"type": "text", "content": "655"}, {"type": "lean", "content": "656", "hidden": false}, {"type": "text", "content": "657"}, {"type": "lean", "content": "658", "hidden": false}, {"type": "text", "content": "659"}, {"type": "theorem", "text": "660", "lean": "theorem iff_elim_example1 (h : p \u2194 (q \u2227 r)) (k : p) : q :=\n", "sideBar": false, "firstProofLineNumber": 73, "lastProofLineNumber": 82, "textBefore": "import propositional_logic.or_elimination -- hide\n\n/-\n# Propositional logic\n## Level 9: Iff elimination\n\nThe proposition $p \\leftrightarrow q$ represents the informal notation '$p$ if and only if $q$'.\n\nSuppose you are given `h : p \u2194 q` Then\n1. [left iff elimination] `h.mp` is a proof of `p \u2192 q` and\n2. [right iff elimination] `h.mpr` is a proof of `q \u2192 p`.\n\nHere, `h.left` is an abbreviation of `iff.elim_left`. Likewise for `h.right`.\n\n**Notation**: `\u2194` is typed `\\iff`.\n\nUsing this, we'll prove $p$ on the assumptions $h_1 : p \\leftrightarrow q$ and $h_2 : q$.\n\n**Proof**:\nWe have $h_3 : q \\to p$ by right iff elimination on $h_1$.\nFrom $h_3$, it suffices to show $q$, which follows from $h_2$.\n-/\n\n/- Axiom : iff.elim_left (h : p \u2194 q) :\np \u2192 q\n-/\n\n/- Axiom : iff.elim_right (h : p \u2194 q) :\nq \u2192 p\n-/\nnamespace exlean -- hide\n\nvariables {p q r : Prop} -- hide\n\n/-\nThe same result may be proved in Lean.\n-/\n\nexample (h\u2081 : p \u2194 q) (h\u2082 : q) : p :=\nbegin\n  have h\u2083 : q \u2192 p, from iff.elim_right h\u2081,\n  apply h\u2083,\n  show q, from h\u2082,\nend\n\n\n/-\nAlternatively, the `cases` tactic (much as for and elimination) decomposes `h : p \u2194 q` into proofs\nof `p \u2192 q` and `q \u2192 p`. We use this below and also \n-/\n\nexample (h\u2081 : p \u2194 q) (h\u2082 : q) : p :=\nbegin\n  cases h\u2081 with k h\u2083,\n  given h\u2083 : q \u2192 p,\n  apply h\u2083,\n  show q, from h\u2082,\nend\n\n/-\n## Task\n\nProve the following in Lean and by hand. Use either forward or backward iff elimination.\n-/\n\n\n/- Theorem : no-side-bar\nLet $p$, $q$ and $r$ be propositions. Then $q$ follows from the assumptions\n$h : p \\leftrightarrow (q \\land r)$ and $k : p$.\n-/\ntheorem iff_elim_example1 (h : p \u2194 (q \u2227 r)) (k : p) : q :=\nbegin\n", "proof": "  cases h with h\u2081 h\u2082,\n  given h\u2081 : p \u2192 q \u2227 r,\n  have h\u2082 : q \u2227 r, from h\u2081 k,\n  show q, from h\u2082.left,\n\n\n\n\n\n", "proof_hint": "sorry", "textAfter": "\nend\n\nend exlean -- hide", "height": 10, "editorText": "sorry", "lineOffset": 72, "name": "iff_elim_example1", "statement": "(h : p \u2194 (q \u2227 r)) (k : p) : q"}, {"type": "lean", "content": "661", "hidden": true}]}, {"name": "", "problemIndex": 12, "objects": [{"type": "lean", "content": "662", "hidden": true}, {"type": "text", "content": "663"}, {"type": "axiom", "content": "664", "name": "iff.intro (h\u2081 : p \u2192 q) (h\u2082 : q \u2192 p) :", "sideBar": true}, {"type": "lean", "content": "665", "hidden": true}, {"type": "lean", "content": "666", "hidden": true}, {"type": "lean", "content": "667", "hidden": false}, {"type": "text", "content": "668"}, {"type": "axiom", "content": "669", "name": "and.comm :", "sideBar": true}, {"type": "lean", "content": "670", "hidden": false}, {"type": "text", "content": "671"}, {"type": "lean", "content": "672", "hidden": false}, {"type": "text", "content": "673"}, {"type": "theorem", "text": "674", "lean": "theorem or.comm {p q : Prop} : p \u2228 q \u2194 q \u2228 p :=\n", "sideBar": true, "firstProofLineNumber": 68, "lastProofLineNumber": 76, "textBefore": "import propositional_logic.iff_elimination -- hide\n\n/-\n# Propositional logic\n## Level 10: Iff introduction\n\nTo *prove* $p\\leftrightarrow q$ is to prove $p \\to q$ and to prove $q \\to p$.\n\nIn Lean, if `h\u2081 : p \u2192 q` is a proof of `p \u2192 q` and `h\u2082 : q \u2192 p` is a proof of `q \u2192 p`, then\n`iff.intro h\u2081 h\u2082` is a proof of `p \u2194 q`.\n\nNote the similarities between `\u2227` and `\u2194`.\n-/\n\n/- Axiom : iff.intro (h\u2081 : p \u2192 q) (h\u2082 : q \u2192 p) :\np \u2194 q\n-/\n\nnamespace exlean -- hide\n\nvariables {p q r : Prop} -- hide\n\nexample (p q : Prop) (h\u2081 : p \u2192 q) (h\u2082 : q \u2192 p) : p \u2194 q :=\nbegin\n  from iff.intro h\u2081 h\u2082,\nend\n\n\n/-\nRecall we earlier proved `and.swap` which gives `q \u2227 p` from `p \u2227 q`.\nWe'll use this to prove `(a \u2227 b) \u2194 (b \u2227 a)`.\n-/\n\n/- Axiom : and.comm :\na \u2227 b \u2194 b \u2227 a \n-/\nlemma and.comm {a b : Prop} : (a \u2227 b) \u2194 (b \u2227 a) :=\nbegin\n  have h\u2081 : a \u2227 b \u2192 b \u2227 a, from and.swap,\n  have h\u2082 : b \u2227 a \u2192 a \u2227 b, from and.swap,\n  show a \u2227 b \u2194 b \u2227 a, from iff.intro h\u2081 h\u2082,\nend\n\n\n/-\nAs with `\u2227` introduction, the `split` tactic changes a goal of proving `p \u2194 q` into two\nnew goals: (1) to prove `p \u2192 q` and (2) to prove `q \u2192 p`. This is backward iff introduction.\n-/\n\nexample {a b : Prop} : (a \u2227 b) \u2194 (b \u2227 a) :=\nbegin\n  split,\n  { show (a \u2227 b) \u2192 (b \u2227 a), from and.swap, },\n  { show (b \u2227 a) \u2192 (a \u2227 b), from and.swap, }, \nend\n/-\n## Task\n\nProve the commutativity of `\u2228` in Lean and by hand.\n-/\n\n\n/- Theorem :\nLet $p$ and $q$ be propositions. Then $(p \\lor q) \\leftrightarrow (q \\lor p)$.\n-/\ntheorem or.comm {p q : Prop} : p \u2228 q \u2194 q \u2228 p :=\nbegin\n", "proof": "  split,\n  { show (p \u2228 q) \u2192 (q \u2228 p), from or.swap, },\n  { show (q \u2228 p) \u2192 (p \u2228 q), from or.swap, },\n\n\n\n\n\n", "proof_hint": "sorry", "textAfter": "\nend\n\nend exlean -- hide", "height": 9, "editorText": "sorry", "lineOffset": 67, "name": "or.comm", "statement": "{p q : Prop} : p \u2228 q \u2194 q \u2228 p"}, {"type": "lean", "content": "675", "hidden": true}]}, {"name": "", "problemIndex": 10, "objects": [{"type": "lean", "content": "676", "hidden": true}, {"type": "text", "content": "677"}, {"type": "axiom", "content": "678", "name": "trivial :", "sideBar": true}, {"type": "lean", "content": "679", "hidden": false}, {"type": "text", "content": "680"}, {"type": "axiom", "content": "681", "name": "false.elim (h : false) :", "sideBar": true}, {"type": "lean", "content": "682", "hidden": true}, {"type": "lean", "content": "683", "hidden": false}, {"type": "lean", "content": "684", "hidden": true}, {"type": "text", "content": "685"}, {"type": "theorem", "text": "686", "lean": "def absurd {p : Prop} {q : Sort u} (h\u2081 : p) (h\u2082 : \u00acp) : q :=\n", "sideBar": false, "firstProofLineNumber": 58, "lastProofLineNumber": 62, "textBefore": "import propositional_logic.iff_introduction -- hide\n\n/-\n# Propositional logic\n## Level 11: True and false\n\nWe have two propositional constants, $\\top$ and $\\bot$, written as \n`true` and `false` in Lean.\n\nThere's not much to say about $\\top$. It's always true. The proof of this is `trivial`, also called\n*true introduction*.\n-/\n\n/- Axiom : trivial :\ntrue\n-/\n\nexample : true :=\nbegin\n  from trivial,\nend\n\n/-\nFalse ($\\bot$) is more interesting! The single governing principle of `false` is that\n*anything follows from false*, a principle called *false elimination* or *exfalso sequitur quodlibet*.\n\nIn Lean, if `h : false` is a proof of `false` and if `p` is *anything*, then `false.elim h` is\na proof / construction of `p`.\n-/\n\n/- Axiom : false.elim (h : false) :\np\n-/\n\nuniverse u -- hide\n\nexample (p : Sort u) (h : false) : p :=\nbegin\n  from false.elim h,\nend\n\nnamespace exlean -- hide\n\n/-\n## Task\n\nRecall that $\\neg p$ is shorthand for $p \\to \\bot$ (or `p \u2192 false` in Lean notation).\n\nUse this to prove that anything follows from the assumptions of $p$ and $\\neg p$.\n-/\n\n/- Theorem : no-side-bar\nLet $p$ and $q$ be propositions. Then $q$ follows from $h_1 : p$ and\n$h_2 : \\neg p$.\n-/\ndef absurd {p : Prop} {q : Sort u} (h\u2081 : p) (h\u2082 : \u00acp) : q :=\nbegin\n", "proof": "  have h : false, from h\u2082 h\u2081,\n  show q, from false.elim h,\n\n\n", "proof_hint": "sorry", "textAfter": "\nend\n\nend exlean -- hide", "height": 5, "editorText": "sorry", "lineOffset": 57, "name": "absurd", "statement": "{p : Prop} {q : Sort u} (h\u2081 : p) (h\u2082 : \u00acp) : q"}, {"type": "lean", "content": "687", "hidden": true}]}, {"name": "", "problemIndex": 18, "objects": [{"type": "lean", "content": "688", "hidden": true}, {"type": "text", "content": "689"}, {"type": "axiom", "content": "690", "name": "em (p : Prop):", "sideBar": true}, {"type": "lean", "content": "691", "hidden": true}, {"type": "lean", "content": "692", "hidden": false}, {"type": "text", "content": "693"}, {"type": "axiom", "content": "694", "name": "false.elim (h : false) :", "sideBar": true}, {"type": "lean", "content": "695", "hidden": false}, {"type": "lean", "content": "696", "hidden": true}, {"type": "lean", "content": "697", "hidden": true}, {"type": "text", "content": "698"}, {"type": "axiom", "content": "699", "name": "by_cases (h\u2081 : p \u2192 q) (h\u2082 : \u00acp \u2192 q) :", "sideBar": true}, {"type": "lean", "content": "700", "hidden": false}, {"type": "tactic", "content": "701", "name": "by_cases", "sideBar": true}, {"type": "text", "content": "702"}, {"type": "lean", "content": "703", "hidden": false}, {"type": "text", "content": "704"}, {"type": "tactic", "content": "705", "name": "by_contra", "sideBar": true}, {"type": "theorem", "text": "706", "lean": "theorem by_contra (h : \u00acp \u2192 false) : p :=\n", "sideBar": true, "firstProofLineNumber": 121, "lastProofLineNumber": 131, "textBefore": "import propositional_logic.true_and_false tactic.localized -- hide\n\n/-\n# Propositional logic\n## Level 12: Law of the excluded middle, proof by cases, proof by contradiction\n\nGiven a proposition $p$, the law of the excluded middle is the assertion $p \\lor \\neg p$.\n\nIn Lean, if `p : Prop`, then `em p` is the assertion `p \u2228 \u00acp`.\n-/\n\n/- Axiom : em (p : Prop):\np \u2228 \u00acp\n-/\n\nopen_locale classical -- hide\n\nexample (p : Prop) : p \u2228 \u00acp :=\nbegin\n  from em p,\nend\n\n/-\nFalse ($\\bot$) is more interesting! The single governing principle of `false` is that\n*anything follows from false*, a principle called *false elimination* or *exfalso sequitur quodlibet*.\n\nIn Lean, if `h : false` is a proof of `false` and if `p` is *anything*, then `false.elim h` is\na proof / construction of `p`.\n-/\n\n/- Axiom : false.elim (h : false) :\np\n-/\n\nexample (p : Type*) (h : false) : p :=\nbegin\n  from false.elim h,\nend\n\nnamespace exlean -- hide\n\nvariables {p q : Prop} -- hide\n\n/-\nFrom the law of the excluded middle, we derive a proof method called 'proof by cases'.\nNamely, to prove $q$, it suffices to prove $p \\to q$ and $\\neg p \\to q$.\n\nThe first step of the proof is to deduce $h : p \\lor \\neg p$, by the law of the\nexcluded middle. The rest of the proof follows by or elimination on $h$.\n\n-/\n\n/- Axiom : by_cases (h\u2081 : p \u2192 q) (h\u2082 : \u00acp \u2192 q) :\nq\n-/\n\ntheorem by_cases (h\u2081 : p \u2192 q) (h\u2082 : \u00acp \u2192 q) : q :=\nbegin\n  have k : p \u2228 \u00acp, from em p,\n  cases k with k\u2081 k\u2082,\n  { given k\u2081 : p,\n    show q, from h\u2081 k\u2081, },\n  { given k\u2082 : \u00acp,\n    show q, from h\u2082 k\u2082, },\nend\n\n/- Tactic : by_cases\n\nWe call `by_cases` with the name of a proposition `p` and a tag for the resulting hypotheses.\nFor example, if you write `by_cases h : p`, then Lean creates two new goals\n(1) to prove the target under the assumption\n`h : p` and (2) separately to prove the target under the assumption `h : \u00acp`.\n\n-/\n\n/-\nThis is such a useful theorem that Lean provides a `by_cases` tactic to help write\nbackward proofs by cases. It's best illustrated by example.\n\nWe call `by_cases` with the name of a proposition `p` and a tag for the resulting hypotheses\n(here, we used `k`). The tactic creates two new goals (1) to prove the target under the assumption\n`k : p` and (2) separately to prove the target under the assumption `k : \u00acp`.\n-/\n\nexample (h\u2081 : p \u2192 q) (h\u2082 : \u00acp \u2192 q) : q :=\nbegin\n  by_cases k : p,\n  { given k : p,\n    show q, from h\u2081 k, },\n  { given k : \u00acp,\n    show q, from h\u2082 k, },\nend\n\n/-\n## Tasks\n\nProof by contradiction asserts that to prove $p$, it suffices to show that $\\neg p$ leads to a\ncontradiction. Equally, to prove $(\\neg p \\to \\bot) \\to p$.\n\n1. Your first task is to complete the result below, the principle of 'proof by contradiction',\nusing any of the methods shown above (law of the excluded middle, the proof by cases theorem or the proof\nby cases tactic).\n2. Lean offers a `by_contra` tactic to help write backward proofs by contradiction.\nProve the theorem below by starting with `by_contra k`. This introduces the hypothesis `k : \u00acp`\nand makes proving `false` the target.\n\n-/\n\n/- Tactic : by_contra\n\nProof by contradiction. If the target is to prove `p`, using the tactic `by_contra h` will introduce the hypothesis `h : p`\nand change the target to one of proving `false`. \n-/\n\n\n/- Theorem :\nProof by contradiction. Given a proposition $p$, we have $\\neg \\neg p \\to \\bot$.\n-/\ntheorem by_contra (h : \u00acp \u2192 false) : p :=\nbegin\n", "proof": "  show p,\n  have k : p \u2228 \u00acp, from em p,\n  cases k with k\u2081 k\u2082,\n  { given k\u2081 : p,\n    show p, from k\u2081, },\n  { given k\u2082 : \u00acp,\n    show p, from absurd k\u2082 h, }\n\n\n\n", "proof_hint": "sorry", "textAfter": "\nend\n\nend exlean -- hide", "height": 11, "editorText": "sorry", "lineOffset": 120, "name": "by_contra", "statement": "(h : \u00acp \u2192 false) : p"}, {"type": "lean", "content": "707", "hidden": true}]}, {"name": "", "problemIndex": 11, "objects": [{"type": "lean", "content": "708", "hidden": true}, {"type": "text", "content": "709"}, {"type": "lean", "content": "710", "hidden": true}, {"type": "lean", "content": "711", "hidden": true}, {"type": "text", "content": "712"}, {"type": "text", "content": "713"}, {"type": "lean", "content": "714", "hidden": false}, {"type": "text", "content": "715"}, {"type": "axiom", "content": "716", "name": "not_not {p : Prop} :", "sideBar": true}, {"type": "lean", "content": "717", "hidden": false}, {"type": "text", "content": "718"}, {"type": "theorem", "text": "719", "lean": "theorem prop_ext_example : q \u2227 \u00ac\u00ac(r \u2228 p) \u2192 (p \u2228 r) \u2227 q :=\n", "sideBar": true, "firstProofLineNumber": 77, "lastProofLineNumber": 91, "textBefore": "import propositional_logic.lem -- hide\n\n/-\n# Propositional logic\n## Level 13: Propositional extensionality\n\nLet $\\alpha$ and $\\beta$ be propositions. Suppose $\\alpha\\leftrightarrow\\beta$. Then anything that holds for $\\alpha$ holds for $\\beta$\nand vice-versa. This is called *propositional extensionality*.\n\nUsing propositional extensionality is similar to using `rw` to write backward proofs in the\nequation world.\n-/\n\nnamespace exlean -- hide\n\nvariables {p q r : Prop} -- hide\n\n/-\nWe prove $p \\lor (q\\land r) \\to p \\lor (r \\land q)$ by propositional extensionality.\n\n**Proof**:\n$$\n\\begin{align}\n&& p \\lor (q\\land r) \\to (r \\land q) \\lor p& &  \\\\\\\\\n&\\iff & p \\lor (r\\land q) \\to (r \\land q) \\lor p & & \\text{[by commutativity of $\\land$]} \\\\\\\\\n&\\iff & (r \\land q) \\lor p \\to (r \\land q) \\lor p. & & \\text{[by commutativity of $\\lor$]} \\\\\\\\\n\\end{align}\n$$\nThe last line follows by reflexivity of $\\to$. \u220e\n-/\n\n\n/-\nThe same proof is given below in Lean.\n-/\n\nexample : p \u2228 (q \u2227 r) \u2192 (r \u2227 q) \u2228 p :=\nbegin\n  show p \u2228 (q \u2227 r) \u2192 (r \u2227 q) \u2228 p, rw and.comm,\n  show p \u2228 (r \u2227 q) \u2192 (r \u2227 q) \u2228 p, rw or.comm,\n  show (r \u2227 q) \u2228 p \u2192 (r \u2227 q) \u2228 p, from id,\nend\n\n/-\nBefore moving on to the task for this level, we'll prove a helpful\nequivalence, that $\\neg\\neg p \\leftrightarrow p$.\n-/\n\n/- Axiom : not_not {p : Prop} :\n\u00ac\u00acp \u2194 p\n-/\n\nlemma not_not {p : Prop} : \u00ac\u00acp \u2194 p :=\nbegin\n  have h\u2081 : \u00ac\u00acp \u2192 p, from by_contra,\n  have h\u2082 : p \u2192 \u00ac\u00acp, from not_not_intro,\n  show \u00ac\u00acp \u2194 p, from iff.intro h\u2081 h\u2082,\nend\n\n\n/-\n## Tasks\n1. Prove the result below in Lean using propositional extensionality. Follow the idea\nof the proof above.\n2. If you're feeling adventurous, try proving the result *without* using propositional\nextensionality.\n\n-/\n\n\n/- Theorem :\nLet $p$, $q$, and $r$ be propositions. Then\n$q \\land \\neg\\neg(r \\lor p) \\to (p \\lor r) \\land q$.\n-/\ntheorem prop_ext_example : q \u2227 \u00ac\u00ac(r \u2228 p) \u2192 (p \u2228 r) \u2227 q :=\nbegin\n", "proof": "  show q \u2227 \u00ac\u00ac(r \u2228 p) \u2192 (p \u2228 r) \u2227 q, rw not_not,\n  show q \u2227 (r \u2228 p) \u2192 (p \u2228 r) \u2227 q,   rw and.comm,\n  show (r \u2228 p) \u2227 q \u2192 (p \u2228 r) \u2227 q,   rw or.comm,\n  show (p \u2228 r) \u2227 q \u2192 (p \u2228 r) \u2227 q,   from id,\n/-   assume h : q \u2227 \u00ac\u00ac(r \u2228 p),\n  split,\n  { cases h with h\u2081 h\u2082,\n    have h\u2083 : r \u2228 p, from by_contra h\u2082,\n    cases h\u2083 with k\u2081 k\u2082,\n    { from or.inr k\u2081, },\n    { from or.inl k\u2082, }, },\n  { from h.left,  }, -/\n\n\n", "proof_hint": "sorry", "textAfter": "\nend\n\nend exlean -- hide", "height": 15, "editorText": "sorry", "lineOffset": 76, "name": "prop_ext_example", "statement": "q \u2227 \u00ac\u00ac(r \u2228 p) \u2192 (p \u2228 r) \u2227 q"}, {"type": "lean", "content": "720", "hidden": true}]}, {"name": "", "problemIndex": 4, "objects": [{"type": "lean", "content": "721", "hidden": true}, {"type": "text", "content": "722"}, {"type": "lean", "content": "723", "hidden": true}, {"type": "text", "content": "724"}, {"type": "theorem", "text": "725", "lean": "theorem or.neg_resolve_left {p q : Prop} : (\u00acp \u2228 q) \u2192 (p \u2192 q) :=\n", "sideBar": true, "firstProofLineNumber": 23, "lastProofLineNumber": 35, "textBefore": "import propositional_logic.prop_ext -- hide\n\n/-\n# Propositional logic\n## Level 14: Implication redux, part 1\n\nThe aim of this level and the next is to prove $p \\to q$ is equivalent to $\\neg p \\lor q$.\n-/\n\nnamespace exlean -- hide\n\n/-\n## Task\nProve in Lean that $(\\neg p \\lor q) \\to (p \\to q)$.\n-/\n\n/- Theorem :\nLet $p$ and $q$ be propositions. Then $(\\neg p \\lor q) \\to (p \\to q)$.\n-/\n\ntheorem or.neg_resolve_left {p q : Prop} : (\u00acp \u2228 q) \u2192 (p \u2192 q) :=\nbegin\n", "proof": "  assume h : \u00acp \u2228 q,\n  show p \u2192 q,\n  assume k : p,\n  show q,  \n  cases h with h\u2081 h\u2082,\n  { given h\u2081 : \u00acp,\n    show q, from absurd k h\u2081, },\n  { given h\u2082 : q,\n    show q, from h\u2082, },\n\n\n\n", "proof_hint": "sorry", "textAfter": "\nend\n\nend exlean -- hide", "height": 13, "editorText": "sorry", "lineOffset": 22, "name": "or.neg_resolve_left", "statement": "{p q : Prop} : (\u00acp \u2228 q) \u2192 (p \u2192 q)"}, {"type": "lean", "content": "726", "hidden": true}]}, {"name": "", "problemIndex": 6, "objects": [{"type": "lean", "content": "727", "hidden": true}, {"type": "text", "content": "728"}, {"type": "lean", "content": "729", "hidden": true}, {"type": "text", "content": "730"}, {"type": "hint", "content": "731", "title": "732"}, {"type": "hint", "content": "733", "title": "734"}, {"type": "theorem", "text": "735", "lean": "theorem not_or_of_imp {p q : Prop} : (p \u2192 q) \u2192 (\u00acp \u2228 q):=\n", "sideBar": true, "firstProofLineNumber": 42, "lastProofLineNumber": 57, "textBefore": "import propositional_logic.implication_redux1 -- hide\n\n/-\n# Propositional logic\n## Level 15: Implication redux, part 2\n\nIn this level, we prove the converse of the result of the previous level.\n-/\n\nnamespace exlean -- hide\n\n/-\n## Task\nProve in Lean that $(p \\to q) \\to (\\neg p \\lor q)$.\n-/\n\n/- Hint : Suggested approach\nFor this result, you'll need to use a non-constructive proof method\n(law of the excluded middle, proof by contradiction, proof by cases, and so forth).\nI suggest proof by cases on `p`.\n-/\n\n/- Hint : A proof template\nIf you get stuck, try the following template.\n```\nassume h : p \u2192 q,\nshow \u00acp \u2228 q,\nby_cases k : p,\n{ given k : p,\n  sorry, },\n{ given k : \u00acp,\n  sorry, },\n```\n\n-/\n\n/- Theorem :\nLet $p$ and $q$ be propositions. Then $(p \\to q) \\to (\\neg p \\lor q)$.\n-/\ntheorem not_or_of_imp {p q : Prop} : (p \u2192 q) \u2192 (\u00acp \u2228 q):=\nbegin\n", "proof": "  assume h : p \u2192 q,\n  show \u00acp \u2228 q,\n  by_cases k : p,\n  { given k : p,\n    show \u00acp \u2228 q, right,\n    show q, from h k, },\n  { given k : \u00acp,\n    show \u00acp \u2228 q, from or.inl k, },\n\n\n\n\n\n\n\n", "proof_hint": "sorry", "textAfter": "\nend\n\nend exlean -- hide", "height": 16, "editorText": "sorry", "lineOffset": 41, "name": "not_or_of_imp", "statement": "{p q : Prop} : (p \u2192 q) \u2192 (\u00acp \u2228 q)"}, {"type": "lean", "content": "736", "hidden": true}]}, {"name": "", "problemIndex": 5, "objects": [{"type": "lean", "content": "737", "hidden": true}, {"type": "text", "content": "738"}, {"type": "lean", "content": "739", "hidden": true}, {"type": "text", "content": "740"}, {"type": "hint", "content": "741", "title": "742"}, {"type": "theorem", "text": "743", "lean": "theorem not_and_of_not_or_not {p q : Prop} : (\u00acp \u2228 \u00acq) \u2192 \u00ac(p \u2227 q) :=\n", "sideBar": true, "firstProofLineNumber": 34, "lastProofLineNumber": 49, "textBefore": "import propositional_logic.implication_redux2 -- hide\n\n/-\n# Propositional logic\n## Level 16: De Morgan's laws 1\n\nDe Morgan's laws state:\n* $\\neg(p \\land q) \\leftrightarrow (\\neg p \\lor \\neg q)$ and\n* $\\neg(p \\lor q) \\leftrightarrow (\\neg p \\land \\neg q)$.\n\nIn this series of levels, you will prove the four implications that\ntogether constitute these laws.\n-/\n\nnamespace exlean -- hide\n\n/-\n## Task\nProve in Lean that $(\\neg p \\lor \\neg q) \\to \\neg(p \\land q)$. \n-/\n\n/- Hint : Suggested approach\nYou need to prove an implication. Thus, you should start by assuming\nthe left hand side of the implication.\n\nAt some point, you will need to decompose an or statement.\n-/\n\n/- Theorem :\nLet $p$ and $q$ be propositions. Then $(\\neg p \\lor \\neg q) \\to \\neg(p \\land q)$.\n-/\ntheorem not_and_of_not_or_not {p q : Prop} : (\u00acp \u2228 \u00acq) \u2192 \u00ac(p \u2227 q) :=\nbegin\n", "proof": "  assume h\u2081 : \u00acp \u2228 \u00acq,\n  assume h\u2082 : p \u2227 q,\n  have k\u2081 : p, from h\u2082.left,\n  have k\u2082 : q, from h\u2082.right,\n  cases h\u2081 with h\u2083 h\u2084,\n  { given h\u2083 : \u00acp,\n    contradiction, },\n  { given h\u2084 : \u00acq,\n    contradiction, },\n\n\n\n\n\n\n", "proof_hint": "sorry", "textAfter": "\nend\n\nend exlean -- hide", "height": 16, "editorText": "sorry", "lineOffset": 33, "name": "not_and_of_not_or_not", "statement": "{p q : Prop} : (\u00acp \u2228 \u00acq) \u2192 \u00ac(p \u2227 q)"}, {"type": "lean", "content": "744", "hidden": true}]}, {"name": "", "problemIndex": 5, "objects": [{"type": "lean", "content": "745", "hidden": true}, {"type": "text", "content": "746"}, {"type": "lean", "content": "747", "hidden": true}, {"type": "text", "content": "748"}, {"type": "hint", "content": "749", "title": "750"}, {"type": "theorem", "text": "751", "lean": "theorem not_or_of_not_and_not {p q : Prop} : (\u00acp \u2227 \u00acq) \u2192 \u00ac(p \u2228 q) :=\n", "sideBar": true, "firstProofLineNumber": 32, "lastProofLineNumber": 49, "textBefore": "import propositional_logic.de_morgan1 -- hide\n\n/-\n# Propositional logic\n## Level 17: De Morgan's laws 2\n\nWe continue our examination of De Morgan's laws by proving the\n'backward' direction of \n\n$\\neg(p \\lor q) \\leftrightarrow (\\neg p \\land \\neg q)$.\n-/\nnamespace exlean -- hide\n\n/-\n## Task\nProve in Lean that $(\\neg p \\land \\neg q) \\to \\neg(p \\lor q)$. \n-/\n\n/- Hint : Suggested approach\nYou need to prove an implication. Thus, you should start by assuming\nthe left hand side of the implication.\n\nAt some point, you will need to decompose an or statement and an\nand statement.\n-/\n\n/- Theorem :\nLet $p$ and $q$ be propositions. Then $(\\neg p \\lor \\neg q) \\to \\neg(p \\land q)$.\n-/\ntheorem not_or_of_not_and_not {p q : Prop} : (\u00acp \u2227 \u00acq) \u2192 \u00ac(p \u2228 q) :=\nbegin\n", "proof": "  assume h\u2081 : \u00acp \u2227 \u00acq,\n  assume h\u2082 : p \u2228 q,\n  have k\u2081 : \u00acp, from h\u2081.left,\n  have k\u2082 : \u00acq, from h\u2081.right,\n  cases h\u2082 with h\u2083 h\u2084,\n  { given h\u2083 : p,\n    contradiction, },\n  { given h\u2084 : q,\n    contradiction, },\n\n\n\n\n\n\n\n\n", "proof_hint": "sorry", "textAfter": "\nend\n\nend exlean -- hide", "height": 18, "editorText": "sorry", "lineOffset": 31, "name": "not_or_of_not_and_not", "statement": "{p q : Prop} : (\u00acp \u2227 \u00acq) \u2192 \u00ac(p \u2228 q)"}, {"type": "lean", "content": "752", "hidden": true}]}, {"name": "", "problemIndex": 5, "objects": [{"type": "lean", "content": "753", "hidden": true}, {"type": "text", "content": "754"}, {"type": "lean", "content": "755", "hidden": true}, {"type": "text", "content": "756"}, {"type": "hint", "content": "757", "title": "758"}, {"type": "theorem", "text": "759", "lean": "theorem not_and_not_of_not_or {p q : Prop} : \u00ac(p \u2228 q) \u2192 (\u00acp \u2227 \u00acq) :=\n", "sideBar": true, "firstProofLineNumber": 30, "lastProofLineNumber": 49, "textBefore": "import propositional_logic.de_morgan2 -- hide\n\n/-\n# Propositional logic\n## Level 18: De Morgan's laws 3\n\nWe now prove the forward direction of:\n$\\neg(p \\lor q) \\leftrightarrow (\\neg p \\land \\neg q)$.\n-/\n\nnamespace exlean -- hide\n\n/-\n## Task\nProve in Lean that $\\neg(p \\lor q) \\to (\\neg p \\land \\neg q)$. \n-/\n\n/- Hint : Suggested approach\nYou need to prove an implication. Thus, you should start by assuming\nthe left hand side of the implication.\n\nYou then have to prove an `\u2227` statement. What should you do?\n-/\n\n/- Theorem :\nLet $p$ and $q$ be propositions. Then $(\\neg p \\lor \\neg q) \\to \\neg(p \\land q)$.\n-/\ntheorem not_and_not_of_not_or {p q : Prop} : \u00ac(p \u2228 q) \u2192 (\u00acp \u2227 \u00acq) :=\nbegin\n", "proof": "  assume h\u2081 : \u00ac(p \u2228 q),\n  split,\n  { show \u00acp,\n    assume h\u2082 : p,\n    apply h\u2081,\n    left,\n    from h\u2082,  },\n  { show \u00acq,\n    assume h\u2082 : q,\n    apply h\u2081,\n    right,\n    from h\u2082,  },\n\n\n\n\n\n\n\n", "proof_hint": "sorry", "textAfter": "\nend\n\nend exlean -- hide", "height": 20, "editorText": "sorry", "lineOffset": 29, "name": "not_and_not_of_not_or", "statement": "{p q : Prop} : \u00ac(p \u2228 q) \u2192 (\u00acp \u2227 \u00acq)"}, {"type": "lean", "content": "760", "hidden": true}]}, {"name": "", "problemIndex": 7, "objects": [{"type": "lean", "content": "761", "hidden": true}, {"type": "text", "content": "762"}, {"type": "lean", "content": "763", "hidden": true}, {"type": "axiom", "content": "764", "name": "imp_iff_not_or {p q : Prop}", "sideBar": true}, {"type": "lean", "content": "765", "hidden": false}, {"type": "text", "content": "766"}, {"type": "hint", "content": "767", "title": "768"}, {"type": "theorem", "text": "769", "lean": "theorem not_or_not_of_not_and_of {p q : Prop} : \u00ac(p \u2227 q) \u2192 (\u00acp \u2228 \u00acq) :=\n", "sideBar": true, "firstProofLineNumber": 59, "lastProofLineNumber": 76, "textBefore": "import propositional_logic.de_morgan3 -- hide\n\n/-\n# Propositional logic\n## Level 19: De Morgan's laws 4\n\nWe continue our examination of De Morgan's laws by proving the\n'forward' direction of \n\n$\\neg(p \\land q) \\leftrightarrow (\\neg p \\lor \\neg q)$.\n\n\nFor this level, it will be helpful to have a proof of\n$\\neg(p \\to q) \\leftrightarrow (\u00acp \\lor q)$.\n\nWe prove this by combining two results from previous levels:\n-/\n\nnamespace exlean -- hide\n\n/- Axiom : imp_iff_not_or {p q : Prop}\n(p \u2192 q) \u2194 (\u00acp \u2228 q)\n-/\nlemma imp_iff_not_or {p q : Prop} : (p \u2192 q) \u2194 (\u00acp \u2228 q) :=\nbegin\n  have h\u2081 : (p \u2192 q) \u2192 (\u00acp \u2228 q), from not_or_of_imp,\n  have h\u2082 : (\u00acp \u2228 q) \u2192 (p \u2192 q), from or.neg_resolve_left,\n  show (p \u2192 q) \u2194 (\u00acp \u2228 q), from iff.intro h\u2081 h\u2082,\nend\n\n/-\n## Task\nProve in Lean that $\\neg(p \\land q) \\to (\\neg p \\lor \\neg q)$. \n-/\n\n/- Hint : Suggested approach\n\nAt some point in your proof, you will have a target of the form `\u00aca \u2228 b`.\n\nTo prove this kind of statement requires 'classical reasoning'. That is,\nyou'll need to use something like the law of the excluded middle,\nproof by cases, proof by contradiction, or a result that uses one of\nthose principles.\n\nPerhaps the simplest approach is to use the lemma `imp_iff_not_or` above.\n\nUsing this lemma, you can turn the target (of the form `\u00aca \u2228 b`) into\na statement of the form `a \u2192 b`. To do this, rewrite\nfrom the left, typing\n\n`rw \u2190imp_iff_not_or`\n-/\n\n/- Theorem :\nLet $p$ and $q$ be propositions. Then $(\\neg p \\lor \\neg q) \\to \\neg(p \\land q)$.\n-/\ntheorem not_or_not_of_not_and_of {p q : Prop} : \u00ac(p \u2227 q) \u2192 (\u00acp \u2228 \u00acq) :=\nbegin\n", "proof": "  assume h\u2081 : \u00ac(p \u2227 q),\n  show \u00acp \u2228 \u00acq,\n  rw \u2190imp_iff_not_or,\n  assume h\u2082 : p,\n  assume h\u2083 : q,\n  apply h\u2081,\n  split,\n  { assumption, },\n  { assumption, },\n\n\n\n\n\n\n\n\n", "proof_hint": "sorry", "textAfter": "\nend\n\nend exlean -- hide", "height": 18, "editorText": "sorry", "lineOffset": 58, "name": "not_or_not_of_not_and_of", "statement": "{p q : Prop} : \u00ac(p \u2227 q) \u2192 (\u00acp \u2228 \u00acq)"}, {"type": "lean", "content": "770", "hidden": true}]}], "parents": [1]}, {"name": "771", "levels": [{"name": "", "problemIndex": 8, "objects": [{"type": "lean", "content": "772", "hidden": true}, {"type": "text", "content": "773"}, {"type": "lean", "content": "774", "hidden": false}, {"type": "text", "content": "775"}, {"type": "lean", "content": "776", "hidden": false}, {"type": "tactic", "content": "777", "name": "specialize", "sideBar": true}, {"type": "lean", "content": "778", "hidden": true}, {"type": "text", "content": "779"}, {"type": "theorem", "text": "780", "lean": "theorem forall_elim_example (f : \u2115 \u2192 \u2115)\n(h : \u2200 (x : \u2115), f(x) = f(x + 1)) : f(5) = f(5 + 1) :=\n", "sideBar": false, "firstProofLineNumber": 82, "lastProofLineNumber": 85, "textBefore": "import data.nat.basic propositional_logic.de_morgan4 -- hide\n\n/-\n# Predicate logic\n## Level 1: For all elimination\n\nSuppose $P : X \\to \\mathsf{Prop}$ is a predicate on a type $X$.\nGiven $h : \\forall (x : X),\\ P(x)$ and given $y : X$, the *for all\nelimination rule* applied to $h$ and $y$ gives a proof of $P(y)$.\n\nAs an example, let $h$ be a proof that\n$\\forall (n : \\mathbb N),\\ (n + 1)^2 = n ^ 2 + 2n + 1$.\n\nThen 'for all elimination', applied to $h$ and $ab$ (for natural \nnumbers $a$ and $b$) gives a proof of\n$(ab + 1)^2 = (ab)^2 + 2(ab) + 1$.\n\nIn Lean, if `h : \u2200 (x : X), P(x)` and if `y : X`, then the\nexpression `h(y)` is a proof of `P(y)`.\n\nThe symbol `\u2200` is typed `\\all`.\n\nHere follows a Lean translation of the above example.\n-/\n\nexample (a b : \u2115) (h : \u2200 (n : \u2115), (n + 1)^2 = n^2 + 2 * n + 1)\n: (a * b + 1) ^ 2 = (a * b)^2 + 2 * (a * b) + 1 :=\nbegin\n  from h (a * b),\nend\n\n\n/-\nAn alternative approach is to use the `specialize` tactic.\nGiven a hypothesis `h : \u2200 (x : X), P(x)` and given a term `y : X`,\ntyping `specialize h y` replaces `h` with `h : P(y)`.\n\nThat is, the general statment `\u2200 (x : X), P(x)` is replaced with\nits specialisation to `y`.\n\nHere is the same result as above, proved using the `specialize` tactic.\nAfter the first line, the hypothesis `h` changes to\n`h : (a * b + 1) ^ 2 = (a * b) ^ 2 + 2 * (a * b) + 1`\n\nIt is used directly in the last line to conclude the proof.\n-/\n\nexample (a b : \u2115) (h : \u2200 (n : \u2115), (n + 1)^2 = n^2 + 2 * n + 1)\n: (a * b + 1) ^ 2 = (a * b)^2 + 2 * (a * b) + 1 :=\nbegin\n  specialize h (a * b),\n  from h,\nend\n\n/- Tactic : specialize\n`specialize` changes a proof of a `\u2200` statement to its specialisation at a particular value.\n\n### Example\n\nGiven `h : \u2200 (x : \u2124), f(x) = 10`, typing `specialize h 3` replaces `h` with\n`h : f(3) = 10`.\n-/\n\n\nnamespace exlean -- hide\n\n/-\n## Tasks\n\n1. Prove the result below using for all elimination.\n2. Prove the result below using the `specialize` tactic.\n-/\n\n/- Theorem : no-side-bar\nLet $f : \\mathbb N \\to \\mathbb N$ be a function such that\n$\\forall (x : \\mathbb N),\\ f(x) = f(x + 1)$.\nThen $f(5) = f(5 + 1)$.\n-/\ntheorem forall_elim_example (f : \u2115 \u2192 \u2115)\n(h : \u2200 (x : \u2115), f(x) = f(x + 1)) : f(5) = f(5 + 1) :=\nbegin\n", "proof": "  from h 5,\n\n\n", "proof_hint": "sorry", "textAfter": "\nend\n\nend exlean -- hide", "height": 4, "editorText": "sorry", "lineOffset": 81, "name": "forall_elim_example", "statement": "(f : \u2115 \u2192 \u2115)\n(h : \u2200 (x : \u2115), f(x) = f(x + 1)) : f(5) = f(5 + 1)"}, {"type": "lean", "content": "781", "hidden": true}]}, {"name": "", "problemIndex": 6, "objects": [{"type": "lean", "content": "782", "hidden": true}, {"type": "text", "content": "783"}, {"type": "lean", "content": "784", "hidden": true}, {"type": "lean", "content": "785", "hidden": false}, {"type": "lean", "content": "786", "hidden": true}, {"type": "text", "content": "787"}, {"type": "theorem", "text": "788", "lean": "theorem forall_intro_example1\n(h : \u2200 (z : B), P(z)) : \u2200 (b : B), Q(b) \u2228 P(b) :=\n", "sideBar": false, "firstProofLineNumber": 57, "lastProofLineNumber": 62, "textBefore": "import predicate_logic.forall_elimination -- hide\n\n/-\n# Predicate logic\n## Level 2: For all introduction\n\nSuppose $P : X \\to \\mathsf{Prop}$ is a predicate on a type $X$.\nTo *prove* a statement $\\forall (x : X),\\ P(x)$ is to assume $y$\nis a term of type $X$ and to prove $P(y)$. This is the *for all\nintroduction* rule.\n\nIn this rule, there's nothing special about the name of the variable\n$y$ or the variable $x$.\n\n\n\nAs an example, suppose $P$ and $Q$ are predicates on a type $B$.\nWe'll prove $\\forall (b : B),\\ Q(b)$, given\n$h : \\forall (z : B),\\ P(z) \\land Q(z)$.\n\n**Proof** Assume $y : B$. We must show $Q(y)$.\nBy for all elimination on $h$ and $y$, we have $h_2 : P(y) \\land Q(y)$.\nWe show $Q(y)$ by right and elimination on $h_2$. \u220e\n\n*Note*: we don't explictly refer to the 'for all introduction' rule\nwhen proving a for all statement.\n-/\n\nvariables (B : Type*) (P Q : B \u2192 Prop) -- hide\n\nexample (h : \u2200 (z : B), P(z) \u2227 Q(z)) : \u2200 (b : B), Q(b) :=\nbegin\n  assume y : B,\n  show Q(y),\n  have h\u2082 : P(y) \u2227 Q(y), from h y,\n  show Q(y), from h\u2082.right,\nend\n\n\nnamespace exlean -- hide\n\n/-\n## Tasks\n\n1. Prove the result below in Lean.\n2. Prove the result below by hand.\n-/\n\n/- Theorem : no-side-bar\nLet $P$ and $Q$ be predicates on a type $B$. Suppose\n$h : \\forall (z : B),\\ P(z)$,\nthen $\\forall (b : B),\\ Q(b) \\lor P(b)$.\n-/\ntheorem forall_intro_example1\n(h : \u2200 (z : B), P(z)) : \u2200 (b : B), Q(b) \u2228 P(b) :=\nbegin\n", "proof": "  assume y : B,\n  show Q(y) \u2228 P(y),\n  have h\u2082 : P(y), from h y,\n  show Q(y) \u2228 P(y), from or.inr h\u2082,\n\n", "proof_hint": "sorry", "textAfter": "\nend\n\nend exlean -- hide", "height": 6, "editorText": "sorry", "lineOffset": 56, "name": "forall_intro_example1", "statement": "(h : \u2200 (z : B), P(z)) : \u2200 (b : B), Q(b) \u2228 P(b)"}, {"type": "lean", "content": "789", "hidden": true}]}, {"name": "", "problemIndex": 7, "objects": [{"type": "lean", "content": "790", "hidden": true}, {"type": "text", "content": "791"}, {"type": "text", "content": "792"}, {"type": "tactic", "content": "793", "name": "linarith", "sideBar": true}, {"type": "lean", "content": "794", "hidden": false}, {"type": "lean", "content": "795", "hidden": true}, {"type": "text", "content": "796"}, {"type": "theorem", "text": "797", "lean": "theorem forall_practice1 (f : \u2115 \u2192 \u2115)\n(h : \u2200 (a : \u2115), f(a) + f(a + 1) = f(a + 2)) :\n\u2200 (m : \u2115), 2 * f(m + 2) = f(m) + f(m + 3) :=\n", "sideBar": false, "firstProofLineNumber": 67, "lastProofLineNumber": 75, "textBefore": "import predicate_logic.forall_intro tactic.linarith -- hide\n\n/-\n# Predicate logic\n## Level 3: For all practice\n\n**Theorem**: Let $g : \\mathbb N \\to \\mathbb N$ be a function such\nthat $h : \\forall (n : \\mathbb N),\\ g(n + 1) = 2g(n)$. Then\n$\\forall (m : \\mathbb N),\\ g(m + 2) = 4g(m)$.\n\n**Proof**: Assume $m : \\mathbb N$. We must show $g(m + 2) = 4g(m)$.\nNow,\n$$\n\\begin{align}\ng(m + 2) &= g((m + 1) + 1) & & \\text{[by arithmetic]} \\\\\\\\\n&= 2 g(m + 1) & &\\text{[by $h$, specialised at $m + 1$]} \\\\\\\\\n&= 2 (2 g(m)) & &\\text{[by $h$, specialised at $m$]} \\\\\\\\\n&= 4g(m). & & \\text{[by arithmetic]}\n\\end{align}\n$$\n \u220e\n-/\n\n/-\nThe handwritten proof above can be written in Lean. \nThe `linarith` tactic roughly corresponds to the English phrase\n'by arithemtic'. In particular, `linarith` proves many linear\nequations and inequalities.\n-/\n\n/- Tactic : linarith\nProves many linear equations and inequalities.\n-/\n\nexample (g : \u2115 \u2192 \u2115)\n(h : \u2200 (n : \u2115), g(n + 1) = 2 * g(n)) :\n\u2200 (m : \u2115), g(m + 2) = 4 * g(m) :=\nbegin\n  assume m : \u2115,\n  show g(m + 2) = 4 * g(m),\n  calc\n  g(m + 2)  = g((m + 1) + 1)  : by linarith\n        ... = 2 * g(m + 1)    : by rw h (m + 1)\n        ... = 2 * (2 * g(m))  : by rw h m\n        ... = 4 * g(m)        : by linarith\nend\n\nnamespace exlean -- hide\n\n/-\n## Tasks\n\n1. Prove the result below in Lean, using the same basic structure as\nthe proof above.\n2. Prove the result below by hand.\n-/\n\n/- Theorem : no-side-bar\nLet $f : \\mathbb N \\to \\mathbb N$ be a function such that\n$\\forall (a : \\mathbb N),\\ f(a) + f(a + 1) = f(a + 2)$. Then\n$\\forall (m : \\mathbb N),\\ 2 f(m + 2) = f(m) + f(m + 3)$.\n-/\ntheorem forall_practice1 (f : \u2115 \u2192 \u2115)\n(h : \u2200 (a : \u2115), f(a) + f(a + 1) = f(a + 2)) :\n\u2200 (m : \u2115), 2 * f(m + 2) = f(m) + f(m + 3) :=\nbegin\n", "proof": "  assume m : \u2115,\n  show 2 * f(m + 2) = f(m) + f(m + 3),\n  calc\n  2 * f(m + 2) =  f(m + 2) + f(m + 2)      : by linarith\n        ... = (f(m) + f(m + 1)) + f(m + 2) : by rw h m\n        ... = f(m) + (f(m + 1) + f(m + 2)) : by linarith\n        ... = f(m) + f(m + 3)              : by rw h (m + 1) \n\n", "proof_hint": "sorry", "textAfter": "\nend\n\nend exlean -- hide", "height": 9, "editorText": "sorry", "lineOffset": 66, "name": "forall_practice1", "statement": "(f : \u2115 \u2192 \u2115)\n(h : \u2200 (a : \u2115), f(a) + f(a + 1) = f(a + 2)) :\n\u2200 (m : \u2115), 2 * f(m + 2) = f(m) + f(m + 3)"}, {"type": "lean", "content": "798", "hidden": true}]}, {"name": "", "problemIndex": 8, "objects": [{"type": "lean", "content": "799", "hidden": true}, {"type": "text", "content": "800"}, {"type": "axiom", "content": "801", "name": "Exists.intro (y : X) (h : P(y)) :", "sideBar": true}, {"type": "lean", "content": "802", "hidden": false}, {"type": "text", "content": "803"}, {"type": "lean", "content": "804", "hidden": false}, {"type": "lean", "content": "805", "hidden": true}, {"type": "text", "content": "806"}, {"type": "theorem", "text": "807", "lean": "theorem exists_intro1 :\n\u2203 (m : \u2115), (m > 5) \u2227 (m ^ 2 + 40 = 14 * m) :=\n", "sideBar": false, "firstProofLineNumber": 87, "lastProofLineNumber": 97, "textBefore": "import predicate_logic.forall_practice -- hide\n\n/-\n# Predicate logic\n## Level 4: Exists introduction 1\n\nThe symbol $\\exists$ is real 'there exists' and is called the\nexistential quantifier.\n\nSuppose $P : X \\to \\mathsf{Prop}$ is a predicate on a type $X$.\nTo prove $\\exists (x : X),\\ P(x)$ is to exhibit a term $y : X$\nand a proof of $P(y)$. This is called *exists introduction*.\n\nAs an example, we'll prove an existentially quantified statement.\n\n**Theorem**: $\\exists (m : \\mathbb N),\\ m^2 + 2 = 3 m$.\n\nThe idea of the proof is to find an natural number $x$ together\nwith a proof that $x^2 + 2 = 3x$. How we *find* such a natural\nnumber is not relevant to the proof. In this case, you might\ntry to find an $x$ by rearranging the equation $x^2 + 2 = 3x$ into\n$(x - 2)(x - 1) = 0$, from which it is clear that $2$ or $1$ could\nbe taken as values for $x$.\n\n**Proof**: We have $h : 2^2 + 2 = 3 \\times 2$, by arithmetic.\nWe show $\\exists (m : \\mathbb N),\\ m^2 + 2 = 3 m$ by\nexists introduction on $2$ and $h$. \u220e\n\nIn Lean, `\u2203` is typed `\\exists`. The exists introduction rule is\ncalled `Exists.intro`. Given `y : X` and a proof `h : P(y)`,\n`Exists.intro y h` is a proof of `\u2203 (x : X), P(x)`.\n-/\n\n/- Axiom : Exists.intro (y : X) (h : P(y)) :\n\u2203 (x : X), P(x)\n-/\n\nexample : \u2203 (m : \u2115), m ^ 2 + 2 = 3 * m :=\nbegin\n  have h : 2 ^ 2 + 2 = 3 * 2, linarith,\n  from Exists.intro 2 h,\nend\n\n/-\nOur next example involves a more complicated predicate.\n\n**Theorem**: $\\exists (m : \\mathbb N),\\ (m < 2) \\land (m^2 + 2 = 3 m)$.\n\n**Proof**:\nWe have $h : (1 < 2) \\land (1 ^ 2 + 2 = 3 \\times 1)$ as\n1. $1 < 2$ by arithmetic and\n2. 1 ^ 2 + 2 = 3 \\times 1 by arithmetic.\n\nWe show $\\exists (m : \\mathbb N),\\ (m < 2) \\land (m^2 + 2 = 3 m)$\nfrom exists introduction on $1$ and $h$. \u220e\n\nIn the Lean proof below, we use the `split` tactic to prove the\n`\u2227` statement (recall this is backward and introduction).\n-/\n\nexample : \u2203 (m : \u2115), (m < 2) \u2227 (m ^ 2 + 2 = 3 * m) :=\nbegin\n  have h : (1 < 2) \u2227 (1 ^ 2 + 2 = 3 * 1),\n  { split,\n      show 1 < 2, linarith,\n      show 1 ^ 2 + 2 = 3 * 1, linarith, },\n  from Exists.intro 1 h,\nend\n\n\nnamespace exlean -- hide\n\n/-\n## Tasks\n\n1. Prove the result below in Lean, using the same basic structure as\nthe proof above.\n2. Prove the result below by hand.\n-/\n\n/- Theorem : no-side-bar\n$\\exists (m : \\mathbb N),\\ (m > 5) \u2227 (m ^ 2 + 40 = 14 m)$\n-/\ntheorem exists_intro1 :\n\u2203 (m : \u2115), (m > 5) \u2227 (m ^ 2 + 40 = 14 * m) :=\nbegin\n", "proof": "  have h : (10 > 5) \u2227 (10 ^ 2 + 40 = 14 * 10),\n  { split,\n      show 10 > 5, linarith,\n      show 10 ^ 2 + 40 = 14 * 10, linarith, },\n  show \u2203 (x : \u2115), (x > 5) \u2227 (x ^ 2 + 40 = 14 * x),\n  from Exists.intro 10 h,\n\n\n\n\n", "proof_hint": "sorry", "textAfter": "\nend\n\nend exlean -- hide", "height": 11, "editorText": "sorry", "lineOffset": 86, "name": "exists_intro1", "statement": "\u2203 (m : \u2115), (m > 5) \u2227 (m ^ 2 + 40 = 14 * m)"}, {"type": "lean", "content": "808", "hidden": true}]}, {"name": "", "problemIndex": 8, "objects": [{"type": "lean", "content": "809", "hidden": true}, {"type": "text", "content": "810"}, {"type": "tactic", "content": "811", "name": "use", "sideBar": true}, {"type": "lean", "content": "812", "hidden": false}, {"type": "text", "content": "813"}, {"type": "lean", "content": "814", "hidden": false}, {"type": "lean", "content": "815", "hidden": true}, {"type": "text", "content": "816"}, {"type": "theorem", "text": "817", "lean": "theorem exists_intro2 :\n\u2203 (m : \u2115), (m < 5) \u2227 (m ^ 2 + 18 = 9 * m \u2228 m ^ 2 + 35 = 12 * m) :=\n", "sideBar": false, "firstProofLineNumber": 86, "lastProofLineNumber": 95, "textBefore": "import predicate_logic.exists_intro -- hide\n\n/-\n# Predicate logic\n## Level 5: Exists introduction 2\n\nIn the previous level, we saw that if `y : X` and if `h : P(y)`,\nthen `Exists.intro y h` is a proof of `\u2203 (x : X), P(x)`.\n\nThis is a 'forward' approach to the proof. Often, it is more\nnatural to give a 'backward' proof. Here a handwritten example.\n\n**Theorem**: $\\exists (m : \\mathbb N),\\ m^2 + 2 = 3 m$.\n\n**Proof**: Take $m$ to be $2$. It suffices to prove $2^2 + 2 = 3\\times 2$.\nBut this holds by arithmetic. \u220e\n\nIn Lean, we type `use 2` in place of the handwritten, 'Take $m$\nto be $2$'.\n-/\n\n/- Tactic : use\n\nThe `use` tactic is used to prove `\u2203` statements.\nIf the target is to prove `\u2203 (x : X), P(x)` and if `y : X`, then\n`use y` changes the target to one of proving `P(y)`.\n\n### Example\n\nThe tactic `use 2` can be employed in the first line of the\nproof of $\\exists (m : \\mathbb N) : m ^ 2 + 2 = 3m$. It\nchanges the target to one of proving $2^2 + 2 = 3 \\times 2$.\n\n```\nexample :\n\u2203 (m : \u2115), m ^ 2 + 2 = 3 * m :=\nbegin\n  use 2,\n  show 2 ^ 2 + 2 = 3 * 2,\n  linarith,\nend\n```\n-/\n\nexample : \u2203 (m : \u2115), m ^ 2 + 2 = 3 * m :=\nbegin\n  use 2,\n  show 2 ^ 2 + 2 = 3 * 2, linarith,\nend\n\n/-\n**Theorem**: $\\exists (m : \\mathbb N),\\ (m < 2) \\land (m^2 + 2 = 3 m)$.\n\n**Proof**:\nLet $m$ be $1$. We'll show $(1 < 2) \\land (1 ^ 2 + 2 = 3 \\times 1)$.\nBut\n1. $1 < 2$ by arithmetic and\n2. 1 ^ 2 + 2 = 3 \\times 1 by arithmetic. \u220e\n-/\n\nexample : \u2203 (m : \u2115), (m < 2) \u2227 (m ^ 2 + 2 = 3 * m) :=\nbegin\n  use 1,\n  show (1 < 2) \u2227 (1 ^ 2 + 2 = 3 * 1),\n  split,\n    show 1 < 2, linarith,\n    show 1 ^ 2 + 2 = 3 * 1, linarith, \nend\n\n\nnamespace exlean -- hide\n\n/-\n## Tasks\n\nProve the result below in Lean, via the `use` tactic.\n-/\n\n/- Theorem : no-side-bar\n$\\exists (m : \\mathbb N),\\ (m < 5) \\land\n((m ^ 2 + 18 = 9 m) \\lor (m ^ 2 + 35 = 12 m))$\n-/\ntheorem exists_intro2 :\n\u2203 (m : \u2115), (m < 5) \u2227 (m ^ 2 + 18 = 9 * m \u2228 m ^ 2 + 35 = 12 * m) :=\nbegin\n", "proof": "  use 3,\n  split,\n  { show 3 < 5, linarith, },\n  { show 3 ^ 2 + 18 = 9 * 3 \u2228 3 ^ 2 + 35 = 12 * 3,\n    left,\n    show 3 ^ 2 + 18 = 9 * 3, linarith, }\n\n\n\n", "proof_hint": "sorry", "textAfter": "\nend\n\nend exlean -- hide", "height": 10, "editorText": "sorry", "lineOffset": 85, "name": "exists_intro2", "statement": "\u2203 (m : \u2115), (m < 5) \u2227 (m ^ 2 + 18 = 9 * m \u2228 m ^ 2 + 35 = 12 * m)"}, {"type": "lean", "content": "818", "hidden": true}]}, {"name": "", "problemIndex": 9, "objects": [{"type": "lean", "content": "819", "hidden": true}, {"type": "text", "content": "820"}, {"type": "text", "content": "821"}, {"type": "axiom", "content": "822", "name": "exists.elim (h\u2081 : \u2203 (x : X), P x) (h\u2082 : \u2200 (y : X), (P y \u2192 q))", "sideBar": true}, {"type": "text", "content": "823"}, {"type": "text", "content": "824"}, {"type": "lean", "content": "825", "hidden": false}, {"type": "lean", "content": "826", "hidden": true}, {"type": "text", "content": "827"}, {"type": "theorem", "text": "828", "lean": "theorem exists_exlim1 (f : \u2115 \u2192 \u2115)\n(h : \u2203 (x : \u2115), f(5 * x) = 10 * x) :\n\u2203 (m : \u2115), f(m) = 2 * m :=\n", "sideBar": false, "firstProofLineNumber": 94, "lastProofLineNumber": 110, "textBefore": "import predicate_logic.exists_intro2 -- hide\n\n/-\n# Predicate logic\n## Level 6: Exists elimination 1\n\nWe've seen how to prove existentially-quantified statements.\nHow do we *use* an existentially-quantified statement?\n\nLet's begin with an informal argument.\n\n**Theorem**: Suppose\n$h : \\exists (m : \\mathbb Z),\\ 32m ^ 5 + 160 m ^ 4 = 5184$.\nThen $\\exists (n : \\mathbb Z),\\ n^5 + 10n^4 = 5184$.\n\n**Proof**: From $h$, we have an integer $x$ such that\n$h_2 : 32 x ^ 5 + 160 x ^ 4$ = 5184$.\n\nTake $n$ to be $2x$. It suffices to prove $(2x)^5 + 10 (2x)^4 = 5184$,\nbut this follows by arithmetic.\n\u220e\n\n-/\n\n\n\n\n/-\nMore formally, the *exists elimination* rule produces a proof\nof a proposition $q$ if it is given a proof of\n$\\exists (x : X), P(x)$ and a proof of\n$\\forall (y : X), (P(y) \\to q)$.\n-/\n\n/- Axiom : exists.elim (h\u2081 : \u2203 (x : X), P x) (h\u2082 : \u2200 (y : X), (P y \u2192 q))\nq\n-/\n\n/-\nWe prove the result above using exists elimination. Recall we \nare given $h : \\exists (m : \\mathbb Z),\\ 32m ^ 5 + 160 m ^ 4 = 5184$\nand we are to prove $\\exists (n : \\mathbb Z),\\ n^5 + 10n^4 = 5184$.\n\n**Proof**: We have $h_2 : \\forall (y : \\mathbb Z),\\\n  ( 32 y ^ 5 + 160 y ^ 4 = 5184  \\to\n    \\exists (n : \\mathbb Z), n ^ 5 + 10 n ^ 4 = 5184 )$ as follows:\n> Assume $y : \\mathbb Z$.\n> Assume $h : 32 y ^ 5 + 160 y ^ 4 = 5184$.\n> We must show $\\exists (n : \\mathbb Z), n ^ 5 + 10 n ^ 4 = 5184$. \n> Take $n$ to be $2y$.\n> We must show $(2y)^5 + 10(2y)^4 = 5184$. This follows by\n> arithmetic.\n\nThe result follows by exists elimination on $h$ and $h_2$. \u220e\n\n-/\n\n/-\nIn the proof below, `exists.elim` is the Lean version of the\nexists elimination rule.\n-/\n\nexample (h : \u2203 (m : \u2124), 32 * m ^ 5 + 160 * m ^ 4 = 5184) :\n\u2203 (n : \u2124), n ^ 5 + 10 * n ^ 4 = 5184  :=\nbegin\n  have h\u2082 : \u2200 (y : \u2124),\n  (32 * y ^ 5 + 160 * y ^ 4 = 5184 \u2192 \u2203 (n : \u2124), n ^ 5 + 10 * n ^ 4 = 5184),\n  { assume y : \u2124,\n    assume h\u2083 : 32 * y ^ 5 + 160 * y ^ 4 = 5184,\n    show \u2203 (n : \u2124), n ^ 5 + 10 * n ^ 4 = 5184,\n    use 2 * y,\n    show (2 * y) ^ 5 + 10 * (2 * y) ^ 4 = 5184, linarith, },\n  from exists.elim h h\u2082,\nend\n\n\nnamespace exlean -- hide\n\n/-\n## Tasks\n\nProve the result below in Lean using `exists.elim`.\n-/\n\n/- Theorem : no-side-bar\nLet $f : \\mathbb N \\to \\mathbb N$ be a function.\nGiven $h : \\exists (x : \\mathbb N),\\ f(5x) = 10x$, prove\n$\\exists (m : \\mathbb N),\\ f(m) = 2m$.\n-/\ntheorem exists_exlim1 (f : \u2115 \u2192 \u2115)\n(h : \u2203 (x : \u2115), f(5 * x) = 10 * x) :\n\u2203 (m : \u2115), f(m) = 2 * m :=\nbegin\n", "proof": "  have h\u2082 : \u2200 (y : \u2115), \n  f(5 * y) = 10 * y \u2192 \u2203 (m : \u2115), f(m) = 2 * m,\n  { assume y : \u2115,\n    assume h\u2083 : f(5 * y) = 10 * y,\n    show \u2203 (m : \u2115), f(m) = 2 * m,\n    use 5 * y,\n    show f(5 * y) = 2 * (5 * y),\n    linarith, },\n  from exists.elim h h\u2082,\n\n\n\n\n\n\n\n", "proof_hint": "sorry", "textAfter": "\nend\n\nend exlean -- hide", "height": 17, "editorText": "sorry", "lineOffset": 93, "name": "exists_exlim1", "statement": "(f : \u2115 \u2192 \u2115)\n(h : \u2203 (x : \u2115), f(5 * x) = 10 * x) :\n\u2203 (m : \u2115), f(m) = 2 * m"}, {"type": "lean", "content": "829", "hidden": true}]}, {"name": "", "problemIndex": 7, "objects": [{"type": "lean", "content": "830", "hidden": true}, {"type": "text", "content": "831"}, {"type": "text", "content": "832"}, {"type": "lean", "content": "833", "hidden": true}, {"type": "lean", "content": "834", "hidden": false}, {"type": "lean", "content": "835", "hidden": true}, {"type": "text", "content": "836"}, {"type": "theorem", "text": "837", "lean": "theorem exists_elim2 (P Q : X \u2192 Prop) (h : \u2203 (x : X), P(x) \u2227 Q(x)) :\n\u2203 (z : X), P(z) \u2228 Q(z) :=\n", "sideBar": false, "firstProofLineNumber": 63, "lastProofLineNumber": 76, "textBefore": "import predicate_logic.exists_elim1 -- hide\n\n/-\n# Predicate logic\n## Level 7: Exists elimination 2\n\nThe exists elimination rule can be tricky to use. In this level,\nwe introduce a Lean tactic that simulates the informal style\nof proof we showed at the beginning of the previous level.\n\nHere is a theorem statement and an informal proof.\n\n**Theorem**: Let $P$ and $Q$ be predicates on a type $X$.\nSuppose $h : \\exists (x : X), P(x) \\land Q(x)$.\nThen $\\exists (z : X),\\ Q(z)$.\n\n**Proof**: From $h$, we have a term $y : X$ such that\n$h_2 : P(y) \\land Q(y)$.\n\nTake $z$ to be $y$. We must show $Q(y)$. But this follows by\nright and elimination on $h_2$. \u220e\n\n-/\n\n/-\nIn Lean, we decompose a given `\u2203` statement using the `cases`\ntactic (much as we do for `\u2228` statements).\n\nIn the proof below `cases h with x h\u2082` introduces a new\nvariable `x : \u2124` together with a proof\n`h\u2082 : P(y) \u2227 Q(y)`. The optional `given`\nstatement is there to indicate to the reader what `h\u2082` asserts.\n-/\n\nvariable (X : Type) -- hide\n\nexample (P Q : X \u2192 Prop) (h : \u2203 (x : X), P(x) \u2227 Q(x)) :\n\u2203 (z : X), Q(z) :=\nbegin\n  cases h with y h\u2082,\n  given h\u2082 : P(y) \u2227 Q(y),\n  use y,\n  show Q(y), from h\u2082.right,\nend\n\n\nnamespace exlean -- hide\n\n/-\n## Tasks\n\nProve the result below in Lean, via the `cases` tactic.\n-/\n\n/- Theorem : no-side-bar\nLet $P$ and $Q$ be predicates on a type $X$.\nSuppose $h : \\exists (x : X), P(x) \\land Q(x)$.\nThen $\\exists (z : X),\\ P(z) \\lor Q(z)$.\n-/\ntheorem exists_elim2 (P Q : X \u2192 Prop) (h : \u2203 (x : X), P(x) \u2227 Q(x)) :\n\u2203 (z : X), P(z) \u2228 Q(z) :=\nbegin\n", "proof": "  cases h with y h\u2082,\n  given h\u2082 : P(y) \u2227 Q(y),\n  use y,\n  show P(y) \u2228 Q(y),\n  right,\n  show Q(y),\n  from h\u2082.right,\n\n\n\n\n\n\n", "proof_hint": "sorry", "textAfter": "\nend\n\nend exlean -- hide", "height": 14, "editorText": "sorry", "lineOffset": 62, "name": "exists_elim2", "statement": "(P Q : X \u2192 Prop) (h : \u2203 (x : X), P(x) \u2227 Q(x)) :\n\u2203 (z : X), P(z) \u2228 Q(z)"}, {"type": "lean", "content": "838", "hidden": true}]}, {"name": "", "problemIndex": 21, "objects": [{"type": "lean", "content": "839", "hidden": true}, {"type": "text", "content": "840"}, {"type": "tactic", "content": "841", "name": "ext", "sideBar": true}, {"type": "text", "content": "842"}, {"type": "lean", "content": "843", "hidden": true}, {"type": "lean", "content": "844", "hidden": true}, {"type": "lean", "content": "845", "hidden": false}, {"type": "text", "content": "846"}, {"type": "lean", "content": "847", "hidden": false}, {"type": "lean", "content": "848", "hidden": true}, {"type": "text", "content": "849"}, {"type": "lean", "content": "850", "hidden": true}, {"type": "lean", "content": "851", "hidden": false}, {"type": "text", "content": "852"}, {"type": "lean", "content": "853", "hidden": false}, {"type": "lean", "content": "854", "hidden": true}, {"type": "text", "content": "855"}, {"type": "text", "content": "856"}, {"type": "hint", "content": "857", "title": "858"}, {"type": "lean", "content": "859", "hidden": true}, {"type": "lean", "content": "860", "hidden": false}, {"type": "theorem", "text": "861", "lean": "theorem pred_extensionality :\n(P = Q) \u2228 (P = R) :=\n", "sideBar": false, "firstProofLineNumber": 145, "lastProofLineNumber": 156, "textBefore": "import predicate_logic.exists_elim2 -- hide\n\n/-\n# Predicate logic\n## Level 8: Extensionality of predicates\n\nConsider the predicates $P$ and $Q$ on the type of natural numbers\ngiven by $P(x) := x < 5$ and $Q(y) := 2y < 10$.\n\nOn the one hand, $P$ and $Q$ are clearly different. They\nhave different meanings. The proposition\n$Q(y)$ involves a multiplication by $2$. The definition of $Q$\nseems to involve a variables $y$ whereas that of $P$ seems to\ninvolve a variable $x$.\n\nBut, on the other hand, $P$ and $Q$ are clearly the same predicate.\nIndeed, for every integer $m$, $P(m)$ holds if and only if\n$Q(m)$ holds.\n\nThe principle of extensionality of predicates asserts that\ntwo predicates $P$ and $Q$ on a type $X$ are equal given that\n$\\forall (x : X),\\ P(x) \\leftrightarrow Q(x)$.\n\nThis principle cannot be *proved*. It is something we accept as\nan axiom.\n-/\n\n/- Tactic : ext\n\nThe `ext` (short for 'extensionality') tactic is used to prove\ntwo mathematical objects are extensionally equal. This is typically\nused for sets, functions, and predicates.\n\n## Example\nSuppose `P` and `Q` are predicates on a type `B`. If the target is\nto prove `P = Q`, then using `ext b` changes the target to one of proving\n`P(b) \u2194 Q(b)`.\n-/\n\n/-\nBelow, we give a Lean proof of the statement above. Initially,\nthe target is to show equality of the predicates `P` and `Q`\n(defined as above).\n\nBy using the `ext` tactic, the target is changed to one of proving\n`(x < 5) \u2194 (2 * x < 10)`, for a newly introduced variable `x : \u2115`.\n-/\n\nnamespace exlean -- hide\n\nnamespace pred_ext1 -- hide\n\ndef P(m : \u2115) := m < 5\n\ndef Q(n : \u2115) := 2 * n < 10\n\n/-\n\n-/\n\nexample :\nP = Q :=\nbegin\n  ext x,\n  show (x < 5) \u2194 (2 * x < 10),\n  split,\n  { assume h : x < 5,\n    show 2 * x < 10, linarith, },\n  { assume h : 2 * x < 10,\n    show x < 5, linarith,  },\nend\n\nend pred_ext1 -- hide\n\n/-\nFor a more interesting example, let $f : \\mathbb Z \u2192 \\mathbb Z$ be \na function and let $P$ and $Q$ be predicates on $\\mathbb Z$ defined\nby $P(m) := f(m) = 5$ and $Q(n) := 2 = f(n) - 3$. We'll show $P = Q$.\n-/\n\nnamespace pred_ext2 -- hide\n\nconstant f : \u2124 \u2192 \u2124\n\ndef P(m : \u2124) := f(m) = 5\ndef Q(n : \u2124) := 2 = f(n) - 3\n\n/-\n\n-/\n\nexample : P = Q :=\nbegin\n  ext x,\n  show (f(x) = 5) \u2194 (2 = f(x) - 3),\n  split,\n  { assume h : f(x) = 5,\n    show 2 = f(x) - 3, linarith, },\n  { assume h : 2 = f(x) - 3,\n    show f(x) = 5, linarith,  },\nend\n\nend pred_ext2 -- hide\n\n/-\nExtensionality of predicates will feature heavily later in this\ngame when we explore equality of sets.\n\n-/\n\n/-\n## Tasks\n\nHere, you are given a function $f : \\mathbb N \\to \\mathbb N$ and\nthree predicates on $\\mathbb N$,\n* $P(m) := f(m) = 6$,\n* $Q(n) := f(3n) = 18$, and\n* $R(k) := 3f(k) 18$.\n\nYou are asked to prove $(P = Q) \\lor (P = R)$.\n-/\n\n/- Hint: Starting the proof\nYou should first determine whether you think `P = Q` is true of\n`P = R` is true. Then either use the `left` tactic or the\n`right` tactic, respectively.\n-/\n\nnamespace pred_ext3 -- hide\n\nconstant f : \u2115 \u2192 \u2115\n\ndef P(m : \u2115) := f(m) = 6\n\ndef Q(n : \u2115) := f(3 * n) = 18\n\ndef R(k : \u2115) := 3 * f(k) = 18\n\n/- Theorem : no-side-bar\n$(P = Q) \\lor (P = R)$.\n-/\ntheorem pred_extensionality :\n(P = Q) \u2228 (P = R) :=\nbegin\n", "proof": "  right,\n  ext x,\n  show (f(x) = 6) \u2194 (3 * f(x) = 18),\n  split,\n  { assume h : f(x) = 6,\n    show 3 * f(x) = 18, linarith, },\n  { assume h : 3 * f(x) = 18,\n    show f(x) = 6, linarith, },\n\n\n\n", "proof_hint": "sorry", "textAfter": "\nend\n\nend pred_ext3 -- hide\n\nend exlean -- hide", "height": 12, "editorText": "sorry", "lineOffset": 144, "name": "pred_extensionality", "statement": "(P = Q) \u2228 (P = R)"}, {"type": "lean", "content": "862", "hidden": true}, {"type": "lean", "content": "863", "hidden": true}]}, {"name": "", "problemIndex": 10, "objects": [{"type": "lean", "content": "864", "hidden": true}, {"type": "text", "content": "865"}, {"type": "text", "content": "866"}, {"type": "lean", "content": "867", "hidden": true}, {"type": "lean", "content": "868", "hidden": false}, {"type": "text", "content": "869"}, {"type": "lean", "content": "870", "hidden": false}, {"type": "text", "content": "871"}, {"type": "lean", "content": "872", "hidden": false}, {"type": "text", "content": "873"}, {"type": "theorem", "text": "874", "lean": "theorem even1 :\n\u2200 (n : \u2124), even(n) \u2192 even(n ^ 2) :=\n", "sideBar": false, "firstProofLineNumber": 80, "lastProofLineNumber": 94, "textBefore": "import tactic.modded predicate_logic.pred_extensionality -- hide\n\n/-\n# Predicate logic\n## Level 9: Even integers\n\nAs a practical example, define the predicate\n$\\mathsf{even}$ on $\\mathbb Z$ by\n$\\mathsf{even}(n) := \\exists (m : \\mathbb Z),\\ n = 2m$.\n\nTo prove $\\mathsf{even}(10)$ is to prove $\\exists (m : \\mathbb Z),\\ 10 = 2m$.\n\n**Proof**: take $m$ to be $5$. Then indeed $10 = 2 \\times 5$.\n-/\n\n/-\nHere is a Lean definition of the `even` predicate.\n-/\n\n\nnamespace exlean -- hide\n\ndef even (n : \u2124) := \u2203 (m : \u2124), n = 2 * m\n\n/-\nIn the Lean proof below, I use the slightly odd construction\n`(10 : \u2124) = 2 * 5` rather than `10 = 2 * 5`. This is to ensure\nLean inteprets the quantities as integers rather than as\nnatural numbers.\n-/\n\nexample : even(10) :=\nbegin\n  use 5,\n  show (10 : \u2124) = 2 * 5, linarith,\nend\n\n/-\n**Theorem**: for all integers $n$, if $n$ is even, then $4n$ is even.\n\nMore formally, we are to prove\n$\\forall (n : \\mathbb Z),\\ \\mathsf{even}(n) \\to \\mathsf{even}(4n)$.\n\n**Proof**: Assume $n : \\mathbb Z$. Assume $h : \\mathsf{even}(n)$.\nThat is, $h : \\exists (m : \\mathbb Z),\\ n = 2m$.\nDecomposing this we have $x : \\mathbb Z$ for which $h_2 : n = 2x$.\nWe must show $\\mathsf{even}(4n)$. That is, $\\exists (m : \\mathbb Z),\\ 4n = 2m$.\nTake $m$ to be $4x$. We must show $4n = 2(4x)$.\nBy $h_2$, we must show $4(2x) = 2(4x)$. This holds by arithmetic.\n-/\n\nexample : \u2200 (n : \u2124), even(n) \u2192 even(4 * n) :=\nbegin\n  assume n : \u2124,\n  assume h : even(n),\n  given h : \u2203 (m : \u2124), n = 2 * m,\n  cases h with x h\u2082,\n  given h\u2082 : n = 2 * x,\n  show \u2203 (m : \u2124), 4 * n = 2 * m, \n  use 4 * x,\n  rw h\u2082,\n  show 4 * (2 * x) = 2 * (4 * x), linarith,\nend\n\n\n/-\n## Task\n\nProve the result below in Lean, adapting the proof above.\n-/\n\n\n\n/- Theorem : no-side-bar\n$\\forall (n : \\mathbb Z),\\ \\mathsf{even}(n) \\to \\mathsf{even}(n ^ 2)$.\n-/\ntheorem even1 :\n\u2200 (n : \u2124), even(n) \u2192 even(n ^ 2) :=\nbegin\n", "proof": "  assume n : \u2124,\n  assume h : even (n),\n  change \u2203 (m : \u2124), n = 2 * m at h,\n  cases h with x h\u2082,\n  given h\u2082 : n = 2 * x,\n  show \u2203 (m : \u2124), n ^ 2 = 2 * m,\n  use 2 * x ^ 2,\n  rw h\u2082,\n  linarith,\n\n\n\n\n\n", "proof_hint": "sorry", "textAfter": "\nend\n\nend exlean -- hide", "height": 15, "editorText": "sorry", "lineOffset": 79, "name": "even1", "statement": "\u2200 (n : \u2124), even(n) \u2192 even(n ^ 2)"}, {"type": "lean", "content": "875", "hidden": true}]}, {"name": "", "problemIndex": 9, "objects": [{"type": "lean", "content": "876", "hidden": true}, {"type": "text", "content": "877"}, {"type": "text", "content": "878"}, {"type": "text", "content": "879"}, {"type": "lean", "content": "880", "hidden": false}, {"type": "text", "content": "881"}, {"type": "lean", "content": "882", "hidden": false}, {"type": "lean", "content": "883", "hidden": true}, {"type": "text", "content": "884"}, {"type": "theorem", "text": "885", "lean": "theorem multiple_quantifiers1 (P Q : X \u2192 Prop)\n(h : \u2200 (x : X), \u2200 (y : X), P(x) \u2228 Q(y)) :\n\u2200 (m : X), \u2200 (n : X), Q(n) \u2228 P(m)  :=\n", "sideBar": false, "firstProofLineNumber": 94, "lastProofLineNumber": 104, "textBefore": "import predicate_logic.even1 -- hide\n\n/-\n# Predicate logic\n## Level 10: Multiple quantifiers 1\n\nMany statements in mathematics involve more than one quantifier.\nThe commutitivity of addition of natural numbers can be stated\nas\n$\\forall (m : \\mathbb N),\\ \\forall (n : \\mathbb N),\\ m + n = n + m$.\n-/\n\n/-\nStatements such as this are to be read from left-to-right.\nIf we let $P$ be the predicate on $\\mathbb N$ given by\n$P(m) := \\forall (n : \\mathbb N),\\ m + n = n + m$, then\nthe above statement can be shortened to\n$\\forall (m : \\mathbb N),\\ P(m)$.\n\n-/\n\n\n/-\n**Theorem**: Let $P$ and $Q$ be predicates on a type $X$. Suppose\n$h : \\forall (x : X), \\forall (y : X),\\ P(x) \\land Q(y)$.\nThen $\\forall (m : X), \\forall (n : X),\\ Q(n) \\land P(m)$.\n\n**Proof**: Assume $m : X$ and $n : X$.\nWe have $h_2 : P(m) \\land Q(n)$ by $h$ specialised at $m$ and $n$.\nWe must show $Q(n) \\land P(m)$. By commutativity of $\\land$, this\nis the same as proving $P(m) \\land Q(n)$, which follows from $h_2$. \u220e\n\n-/\n\nvariable (X : Type)\n\nexample (P Q : X \u2192 Prop)\n(h : \u2200 (x : X), \u2200 (y : X), P(x) \u2227 Q(y)) :\n\u2200 (m : X), \u2200 (n : X), Q(n) \u2227 P(m) :=\nbegin\n  assume (m n : X),\n  have h\u2082 : (P m) \u2227 (Q n), from h m n,\n  show Q(n) \u2227 P(m),\n  rw and_comm,\n  show P(m) \u2227 Q(n), from h\u2082,\nend\n\n/-\nThe proof above uses for all introduction and for all elimination.\nA more natural proof uses propositional extensionality to rewrite\nthe commutativity of $\\land$ through the universal quantifier.\n\nAgain, we'll prove that\n$\\forall (m : X), \\forall (n : X),\\ Q(n) \\land P(m)$ follows from\n$h : \\forall (x : X), \\forall (y : X),\\ P(x) \\land Q(y)$.\n\n**Proof**: By commutativity of $\\land$, it suffices to prove\n$\\forall (m : X), \\forall (n : X),\\ P(m) \\land Q(m)$. This follows\nfrom $h$. \u220e\n\nIn Lean, we use the `simp` tactic to rewrite through\nquantifiers, as below.\n-/\n\nexample (P Q : X \u2192 Prop)\n(h : \u2200 (x : X), \u2200 (y : X), P(x) \u2227 Q(y)) :\n\u2200 (m : X), \u2200 (n : X), Q(n) \u2227 P(m) :=\nbegin\n  simp [and_comm],\n  show \u2200 (m : X), \u2200 (n : X), P(m) \u2227 Q(n), from h,\nend\n\n\nnamespace exlean -- hide\n\n/-\n## Tasks\n1. Prove the result below in the style of the first proof above.\n2. Prove the result below using `simp` to rewrite through\nthe quantifiers.\n\n-/\n\n\n/- Theorem : no-side-bar\nSuppose $P$ and $Q$ are predicates on a type $X$. \nSuppose $h : \\forall (x : X),\\ \\forall (y : X),\\ P(x) \\land Q(y)$.\nThen $\\forall (m : X),\\ \\forall (n : X),\\ Q(n) \\lor P(m)$.\n-/\ntheorem multiple_quantifiers1 (P Q : X \u2192 Prop)\n(h : \u2200 (x : X), \u2200 (y : X), P(x) \u2228 Q(y)) :\n\u2200 (m : X), \u2200 (n : X), Q(n) \u2228 P(m)  :=\nbegin\n", "proof": "  assume (m n : X),\n  have h\u2082 : P(m) \u2228 Q(n), from h m n,\n  show Q(n) \u2228 P(m),\n  rw or_comm,\n  show P(m) \u2228 Q(n), from h\u2082,\n\n\n\n\n\n", "proof_hint": "sorry", "textAfter": "\nend\n\nend exlean -- hide", "height": 11, "editorText": "sorry", "lineOffset": 93, "name": "multiple_quantifiers1", "statement": "(P Q : X \u2192 Prop)\n(h : \u2200 (x : X), \u2200 (y : X), P(x) \u2228 Q(y)) :\n\u2200 (m : X), \u2200 (n : X), Q(n) \u2228 P(m)"}, {"type": "lean", "content": "886", "hidden": true}]}, {"name": "", "problemIndex": 6, "objects": [{"type": "lean", "content": "887", "hidden": true}, {"type": "text", "content": "888"}, {"type": "text", "content": "889"}, {"type": "lean", "content": "890", "hidden": false}, {"type": "lean", "content": "891", "hidden": true}, {"type": "text", "content": "892"}, {"type": "theorem", "text": "893", "lean": "theorem multiple_quantifiers2 :\n\u2200 (m : \u2124), \u2203 (n : \u2124), m * n + n - 1 = m * (m + 2) :=\n", "sideBar": false, "firstProofLineNumber": 44, "lastProofLineNumber": 53, "textBefore": "import predicate_logic.multiple_quantifiers1 -- hide\n\n/-\n# Predicate logic\n## Level 11: Multiple quantifiers 2\n\n-/\n\n\n/-\n**Theorem**: $\\forall (x : \\mathbb Z), \\exists (y : \\mathbb Z),\\ x = y + 5$.\n\n**Proof**: Assume $x : \\mathbb Z$. Take $y$ to be $x - 5$.\nIt remains to show $x = (x - 5) + 5$, but this holds by arithmetic. \u220e\n\nThe handwritten proof above translates easily to a Lean proof.\n-/\n\nexample : \u2200 (x : \u2124), \u2203 (y : \u2124), x = y + 5 :=\nbegin\n  assume x : \u2124,\n  use (x - 5),\n  show x = (x - 5) + 5, linarith,\nend\n\nnamespace exlean -- hide\n\n/-\n## Tasks\nProve the result below.\n\n-/\n\n\n/- Theorem : no-side-bar\nShow that\n$\n\\forall (m : \\mathbb Z),\\ \\exists (n : \\mathbb Z),\\ m n + n - 1 = m (m + 2)\n$\n-/\ntheorem multiple_quantifiers2 :\n\u2200 (m : \u2124), \u2203 (n : \u2124), m * n + n - 1 = m * (m + 2) :=\nbegin\n", "proof": "  assume m : \u2124,\n  use m + 1,\n  show m * (m + 1) + (m + 1) - 1 = m * (m + 2),\n  linarith,\n\n\n\n\n\n", "proof_hint": "sorry", "textAfter": "\nend\n\nend exlean -- hide", "height": 10, "editorText": "sorry", "lineOffset": 43, "name": "multiple_quantifiers2", "statement": "\u2200 (m : \u2124), \u2203 (n : \u2124), m * n + n - 1 = m * (m + 2)"}, {"type": "lean", "content": "894", "hidden": true}]}, {"name": "", "problemIndex": 8, "objects": [{"type": "lean", "content": "895", "hidden": true}, {"type": "text", "content": "896"}, {"type": "text", "content": "897"}, {"type": "hint", "content": "898", "title": "899"}, {"type": "text", "content": "900"}, {"type": "lean", "content": "901", "hidden": false}, {"type": "lean", "content": "902", "hidden": true}, {"type": "text", "content": "903"}, {"type": "theorem", "text": "904", "lean": "theorem multiple_quantifiers3 :\n\u2203 (x : \u2115), \u2203 (y : \u2115), x * y + 21 = 7 * x + 3 * y :=\n", "sideBar": false, "firstProofLineNumber": 66, "lastProofLineNumber": 74, "textBefore": "import predicate_logic.multiple_quantifiers2 -- hide\n\n/-\n# Predicate logic\n## Level 12: Multiple quantifiers 3\n\n-/\n\n\n/-\n**Theorem**: $\\exists (x : \\mathbb N),\\ \\exists (y : \\mathbb N),\\\n x^2 + 3xy + 66 = 4 y ^2$.\n\nFor the proof below, it isn't relevant *how* you find $x$ and $y$\nsuch that the above equation is satisfied. \n-/\n\n\n/- Hint: But how do I find the solutions?\n\nThough it's not relevant at this stage of your mathematical journey,\none way to find solutions to this equation is to treat the\nequation as a quadratic in $x$ and to solve for $x$ in terms of $y$.\nAs we are looking for natural number solutions, we require the\ndiscriminant of the equation to be a perfect square. In this case,\nthat means you need $25y^2 - 264 = m^2$, for some integer $m$.\nThere are only finitely many solutions to this equation amongst\nthe integers.\n-/\n\n/-\n\n**Proof**: Take $x$ to be $2$. Take $y$ to be $5$. We must\nshow $2^2 + 3 \\times 2 \\times 4 + 66 = 4 \\times 5 ^2 $.\nBut this holds by arithmetic. \u220e\n\nBelow is a Lean proof of this result.\n-/\n\nexample :\n\u2203 (x : \u2115), \u2203 (y : \u2115), x ^ 2 + 3 * x * y + 66 = 4 * y ^ 2 :=\nbegin\n  use 2,\n  use 5,\n  show 2 ^ 2 + 3 * 2 * 5 + 66 = 4 * 5 ^ 2, linarith,\nend\n\nnamespace exlean -- hide\n\n/-\n## Tasks\nProve the result below. In this case, there are infinitely many\nsolutions for $x$ and $y$. You just need to find one solution.\n\n-/\n\n\n/- Theorem : no-side-bar\nShow that\n$\\exists (x : \\mathbb N),\\ \\exists (y : \\mathbb N),\\\n x  y + 21 = 7  x + 3  y$.\n-/\ntheorem multiple_quantifiers3 :\n\u2203 (x : \u2115), \u2203 (y : \u2115), x * y + 21 = 7 * x + 3 * y :=\nbegin\n", "proof": "  use 3,\n  use 0,\n  show 3 * 0 + 21 = 7 * 3 + 3 * 0, linarith,\n\n\n\n\n\n", "proof_hint": "sorry", "textAfter": "\nend\n\nend exlean -- hide", "height": 9, "editorText": "sorry", "lineOffset": 65, "name": "multiple_quantifiers3", "statement": "\u2203 (x : \u2115), \u2203 (y : \u2115), x * y + 21 = 7 * x + 3 * y"}, {"type": "lean", "content": "905", "hidden": true}]}, {"name": "", "problemIndex": 6, "objects": [{"type": "lean", "content": "906", "hidden": true}, {"type": "text", "content": "907"}, {"type": "text", "content": "908"}, {"type": "lean", "content": "909", "hidden": false}, {"type": "lean", "content": "910", "hidden": true}, {"type": "text", "content": "911"}, {"type": "theorem", "text": "912", "lean": "theorem multiple_quantifiers4 :\n\u2203 (x : \u2124), \u2200 (y : \u2124), (y - 1) ^ 2 = y ^ 2 - x * y + 1 :=\n", "sideBar": false, "firstProofLineNumber": 46, "lastProofLineNumber": 54, "textBefore": "import predicate_logic.multiple_quantifiers3 -- hide\n\n/-\n# Predicate logic\n## Level 13: Multiple quantifiers 4\n\n-/\n\n\n/-\n**Theorem**: $\\exists (x : \\mathbb Z),\\ \\forall (y : \\mathbb Z),\\\n x + y = y$.\n\n**Proof**: Take $x$ to be $0$. We must show\n$\\forall (y : \\mathbb Z),\\ 0 + y = y$.\nAssume $y : \\mathbb Z$. We must show $0 + y = y$.\nBut this holds by arithmetic. \u220e\n\nBelow is a Lean proof of this result.\n-/\n\nexample : \u2203 (x : \u2124), \u2200 (y : \u2124), x + y = y :=\nbegin\n  use 0,\n  assume y : \u2124,\n  show 0 + y = y, linarith,\nend\n\nnamespace exlean -- hide\n\n/-\n## Tasks\nProve the result below.\n\n-/\n\n\n/- Theorem : no-side-bar\nShow that\n$\\exists (x : \\mathbb Z),\\ \\forall (y : \\mathbb Z),\\\n (y - 1)^2 = y^2 - xy + 1$.\n-/\ntheorem multiple_quantifiers4 :\n\u2203 (x : \u2124), \u2200 (y : \u2124), (y - 1) ^ 2 = y ^ 2 - x * y + 1 :=\nbegin\n", "proof": "  use 2,\n  assume y : \u2124,\n  show (y - 1) ^ 2 = y ^ 2 - 2 * y + 1, linarith,\n\n\n\n\n\n", "proof_hint": "sorry", "textAfter": "\nend\n\nend exlean -- hide", "height": 9, "editorText": "sorry", "lineOffset": 45, "name": "multiple_quantifiers4", "statement": "\u2203 (x : \u2124), \u2200 (y : \u2124), (y - 1) ^ 2 = y ^ 2 - x * y + 1"}, {"type": "lean", "content": "913", "hidden": true}]}, {"name": "", "problemIndex": 4, "objects": [{"type": "lean", "content": "914", "hidden": true}, {"type": "text", "content": "915"}, {"type": "text", "content": "916"}, {"type": "lean", "content": "917", "hidden": true}, {"type": "theorem", "text": "918", "lean": "theorem even2 :\n\u2203 (a : \u2124), \u2200 (b : \u2124), even (a * b) :=\n", "sideBar": false, "firstProofLineNumber": 25, "lastProofLineNumber": 35, "textBefore": "import tactic.modded predicate_logic.multiple_quantifiers4 -- hide\n\n/-\n# Predicate logic\n## Level 14: Even integers 2\n\n-/\n\n\n/-\n## Task\n\nProve the result below in Lean.\n-/\n\n\nnamespace exlean -- hide\n\n/- Theorem : no-side-bar\n$\\exists (a : \\mathbb Z),\\ \\forall (b : \\mathbb Z),\\ \\mathsf{even}(ab)$.\n-/\ntheorem even2 :\n\u2203 (a : \u2124), \u2200 (b : \u2124), even (a * b) :=\nbegin\n", "proof": "  use 0,\n  assume b : \u2124,\n  use 0,\n  show 0 * b = 2 * 0,\n  linarith,\n\n\n\n\n\n", "proof_hint": "sorry", "textAfter": "\nend\n\nend exlean -- hide", "height": 11, "editorText": "sorry", "lineOffset": 24, "name": "even2", "statement": "\u2203 (a : \u2124), \u2200 (b : \u2124), even (a * b)"}, {"type": "lean", "content": "919", "hidden": true}]}, {"name": "", "problemIndex": 8, "objects": [{"type": "lean", "content": "920", "hidden": true}, {"type": "text", "content": "921"}, {"type": "text", "content": "922"}, {"type": "text", "content": "923"}, {"type": "tactic", "content": "924", "name": "push_neg", "sideBar": true}, {"type": "lean", "content": "925", "hidden": false}, {"type": "lean", "content": "926", "hidden": true}, {"type": "text", "content": "927"}, {"type": "theorem", "text": "928", "lean": "theorem negating_quantifiers1 :\n\u00ac(\u2200 (x : \u2115), x ^ 2 + 2 * x = 3 * x) :=\n", "sideBar": false, "firstProofLineNumber": 73, "lastProofLineNumber": 81, "textBefore": "import predicate_logic.multiple_quantifiers4 -- hide\n\n/-\n# Predicate logic\n## Level 15: Negating quantifiers 1\n\n-/\n\n\n/-\nAs we'll soon see, the proposition $\\neg (\\forall (x : X),\\ P(x))$\nis equal (materially equivalent to) the proposition\n$\\exists (x : X),\\ \\neg P(x)$.\n\nLikewise, the proposition $\\neg (\\exists (x : X),\\ P(x))$ is equal\nto the proposition $\\forall (x : X),\\ \\neg P(x)$.\n\n**Theorem**: Prove that $\\neg (\\forall (x : \\mathbb N),\\ x + 2 = 5)$.\n\nIn words, we'll prove it's not the case that for every natural\nnumber $x$, $x + 2 = 5$.\n\n**Proof**: We must show $\\exists (x : \\mathbb N),\\ \\neg(x + 2 = 5)$.\nThat is, to show $\\exists (x : \\mathbb N),\\ x + 2 \\ne 5$.\n\nTake $x$ to be $0$. We must show $0 + 2 \\ne 5$. This holds by\narithmetic. \u220e\n-/\n\n/-\nIn the Lean proof below, `push_neg` is the tactic that converts the\nnegation of a universally quantified statement into an \nexistentially quantified statement.\n\nThe symbol `\u2260` is typed `\\ne`.\n-/\n\n/- Tactic : push_neg\n\nThe `push_neg` tactic 'pushes' negations inside\nquantifiers. For example, it changes a target `\u2200 (x : X), P(x)`\ninto `\u2203 (x : X), \u00acP(x)`. If `P(x)` is itself a quantified\nstatement, then `push_neg` will recursively push the negation\ninto `P(x)`.\n\nThus, `push_neg` converts `\u00ac(\u2200 (x : X), \u2203 (y : Y), P x y)` into\n`\u2203 (x : X), \u2200 (y : Y), \u00ac(P x y)`.\n-/\n\nexample : \u00ac(\u2200 (x : \u2115), x + 2 = 5) :=\nbegin\n  push_neg,\n  show \u2203 (x : \u2115), x + 2 \u2260 5,\n  use 0,\n  show 0 + 2 \u2260 5, linarith,\nend\n\nnamespace exlean -- hide\n\n/-\n## Tasks\nProve the result below. Remember that `\u2260` is typed as `\\ne`.\n\n-/\n\n\n/- Theorem : no-side-bar\n$\\neg(\\forall (x : \\mathbb N),\\ x ^ 2 + 2  x = 3  x)$.\n-/\ntheorem negating_quantifiers1 :\n\u00ac(\u2200 (x : \u2115), x ^ 2 + 2 * x = 3 * x) :=\nbegin\n", "proof": "  push_neg,\n  show \u2203 (x : \u2115), x ^ 2 + 2 * x \u2260 3 * x,\n  use 2,\n  linarith,\n\n\n\n\n", "proof_hint": "sorry", "textAfter": "\nend\n\nend exlean -- hide", "height": 9, "editorText": "sorry", "lineOffset": 72, "name": "negating_quantifiers1", "statement": "\u00ac(\u2200 (x : \u2115), x ^ 2 + 2 * x = 3 * x)"}, {"type": "lean", "content": "929", "hidden": true}]}, {"name": "", "problemIndex": 6, "objects": [{"type": "lean", "content": "930", "hidden": true}, {"type": "text", "content": "931"}, {"type": "text", "content": "932"}, {"type": "lean", "content": "933", "hidden": false}, {"type": "lean", "content": "934", "hidden": true}, {"type": "text", "content": "935"}, {"type": "theorem", "text": "936", "lean": "theorem negating_quantifiers2 :\n\u00ac(\u2203 (x : \u2115), 2 * x = 4 * x + 1) :=\n", "sideBar": false, "firstProofLineNumber": 45, "lastProofLineNumber": 53, "textBefore": "import predicate_logic.negating_quantifiers -- hide\n\n/-\n# Predicate logic\n## Level 16: Negating quantifiers 2\n\n-/\n\n\n/-\n\n**Theorem**: Prove that $\\neg (\\exists (x : \\mathbb N),\\ x + 2 = 0)$.\n\nIn words, we'll prove it's not the case that there exists a natural\nnumber $x$ such that $x + 2 = 0$.\n\n**Proof**: We must show $\\forall (x : \\mathbb N),\\ x + 2 \\ne 0$.\nAssume $x : \\mathbb N$. We must show $x + 2 \\ne 0$. \nThis holds by arithmetic. \u220e\n-/\n\nexample : \u00ac(\u2203 (x : \u2115), x + 2 = 0) :=\nbegin\n  push_neg,\n  show \u2200 (x : \u2115), x + 2 \u2260 0,\n  assume x : \u2115,\n  show x + 2 \u2260 0, linarith,\nend\n\nnamespace exlean -- hide\n\n/-\n## Tasks\nProve the result below. Remember that `\u2260` is typed as `\\ne`.\n\n-/\n\n\n/- Theorem : no-side-bar\n$\\neg (\\exists (x : \\mathbb N),\\ 2x = 4x + 1)$.\n-/\ntheorem negating_quantifiers2 :\n\u00ac(\u2203 (x : \u2115), 2 * x = 4 * x + 1) :=\nbegin\n", "proof": "  push_neg,\n  show \u2200 (x : \u2115), 2 * x \u2260 4 * x + 1,\n  assume x : \u2115,\n  linarith,\n\n\n\n\n", "proof_hint": "sorry", "textAfter": "\nend\n\nend exlean -- hide", "height": 9, "editorText": "sorry", "lineOffset": 44, "name": "negating_quantifiers2", "statement": "\u00ac(\u2203 (x : \u2115), 2 * x = 4 * x + 1)"}, {"type": "lean", "content": "937", "hidden": true}]}, {"name": "", "problemIndex": 7, "objects": [{"type": "lean", "content": "938", "hidden": true}, {"type": "text", "content": "939"}, {"type": "text", "content": "940"}, {"type": "lean", "content": "941", "hidden": false}, {"type": "lean", "content": "942", "hidden": true}, {"type": "text", "content": "943"}, {"type": "lean", "content": "944", "hidden": false}, {"type": "theorem", "text": "945", "lean": "theorem negating_quantifiers3 :\n\u00ac(\u2203 (x : \u2115), \u2200 (y : \u2115), 3 * x * y = x * (y^2) + y) :=\n", "sideBar": false, "firstProofLineNumber": 68, "lastProofLineNumber": 81, "textBefore": "import predicate_logic.negating_quantifiers2 -- hide\n\n/-\n# Predicate logic\n## Level 17: Negating quantifiers 3\n\n-/\n\n\n/-\n\n**Theorem**: Prove that\n$\\neg (\\exists (x : \\mathbb N),\\ \\forall (y : \\mathbb N),\\ xy = x + y)$.\n\nIn proving this theorem, we need to push the negation through two\nquantifiers. After pushing the negation through the existential quantifier,\nthe target is to prove\n$\n\\forall (x : \\mathbb N),\\ \\neg(\\forall (y : \\mathbb N),\\ xy = x + y).\n$\n\nWe then push the negation through the inner quantifier, making the\ntarget\n$\n\\forall (x : \\mathbb N),\\ \\exists (y : \\mathbb N),\\ xy \\ne x + y).\n$\n\n**Proof**: We must show\n$\\forall (x : \\mathbb N),\\ \\exists (y : \\mathbb N),\\ xy \\ne x + y$.\nAssume $x : \\mathbb N$. We must show\n$\\exists (y : \\mathbb N),\\ xy \\ne x + y$. Take $y$ to be $1$. We\nmust show $x\\times 1 \u2260 x + 1$. This holds by arithmetic. \u220e\n-/\n\nexample : \u00ac(\u2203 (x : \u2115), \u2200 (y : \u2115), x * y = x + y) :=\nbegin\n  push_neg,\n  show \u2200 (x : \u2115), \u2203 (y : \u2115), x * y \u2260 x + y,\n  assume x : \u2115,\n  show \u2203 (y : \u2115), x * y \u2260 x + y,\n  use 1,\n  show x * 1 \u2260 x + 1, linarith,\nend\n\nnamespace exlean -- hide\n\n/-\n## Tasks\nProve the result below.\n\n-/\n\n\nexample : \u00ac(\u2203 (x : \u2115), \u2200 (y : \u2115), 3 * x * y = x * (y^2) + y) :=\nbegin\n  push_neg,\n  assume x : \u2115,\n  use 3,\n  linarith,\nend\n\n/- Theorem : no-side-bar\n$\\neg (\\exists (x : \\mathbb N),\\ \\forall (y : \\mathbb N),\\ 3xy = xy^2 + y)$.\n-/\ntheorem negating_quantifiers3 :\n\u00ac(\u2203 (x : \u2115), \u2200 (y : \u2115), 3 * x * y = x * (y^2) + y) :=\nbegin\n", "proof": "  push_neg,\n  show \u2200 (x : \u2115), \u2203 (y : \u2115), 3 * x * y \u2260 x * (y ^ 2) + y,\n  assume x : \u2115,\n  show \u2203 (y : \u2115), 3 * x * y \u2260 x * (y ^ 2) + y,\n  use 3,\n  show 3 * x * 3 \u2260 x * (3 ^ 2) + 3, linarith,\n\n\n\n\n\n\n\n", "proof_hint": "sorry", "textAfter": "\nend\n\nend exlean -- hide", "height": 14, "editorText": "sorry", "lineOffset": 67, "name": "negating_quantifiers3", "statement": "\u00ac(\u2203 (x : \u2115), \u2200 (y : \u2115), 3 * x * y = x * (y^2) + y)"}, {"type": "lean", "content": "946", "hidden": true}]}, {"name": "", "problemIndex": 6, "objects": [{"type": "lean", "content": "947", "hidden": true}, {"type": "text", "content": "948"}, {"type": "lean", "content": "949", "hidden": true}, {"type": "text", "content": "950"}, {"type": "hint", "content": "951", "title": "952"}, {"type": "lean", "content": "953", "hidden": true}, {"type": "theorem", "text": "954", "lean": "theorem neg_exists_of_all_neg (P : X \u2192 Prop) :\n(\u2200 (x : X), \u00acP(x)) \u2192 \u00ac(\u2203 (x : X), P(x)):=\n", "sideBar": false, "firstProofLineNumber": 39, "lastProofLineNumber": 53, "textBefore": "import tactic.no_push_neg --hide\n\n/-\n# Predicate logic\n## Level 18: Negating quantifiers theorem 1\n\nThe next few levels are for the experts. We'll prove the equivalences\n* $\\neg (\\forall (x : X),\\ P(x)) \\leftrightarrow \\exists (x : X),\\ \\neg P(x)$ and\n* $\\neg (\\exists (x : X),\\ P(x)) \\leftrightarrow \\forall (x : X),\\ \\neg P(x)$.\n\n-/\n\n\n\nnamespace exlean -- hide\n\n/-\n## Tasks\nProve the result below. You cannot use `push_neg` for this level.\n\n-/\n\n/- Hint : Proving `false`\nRecall that if `h\u2081 : p` and `h\u2082 : \u00acp`, then `h\u2082 h\u2081` is a proof of\n`false`.\n\nAlternatively, remember that `absurd h\u2081 h\u2082` gives a proof of anything.\n-/\n\n\nvariable (X : Type) -- hide\n\n/- Theorem : no-side-bar\n$(\\forall (x : X),\\ \\neg P(x)) \\to \\neg(\\exists (x : X),\\ P(x))$.\n-/\ntheorem neg_exists_of_all_neg (P : X \u2192 Prop) :\n(\u2200 (x : X), \u00acP(x)) \u2192 \u00ac(\u2203 (x : X), P(x)):=\nbegin\n", "proof": "  assume h : \u2200 (x : X), \u00acP(x),\n  assume h\u2082 : \u2203 (x : X), P(x),\n  cases h\u2082 with y h\u2083,\n  given h\u2083 : P(y),\n  have h\u2084 : \u00acP(y), from h y,\n  show false, from h\u2084 h\u2083,\n\n\n\n\n\n\n\n\n", "proof_hint": "sorry", "textAfter": "\nend\n\nend exlean -- hide", "height": 15, "editorText": "sorry", "lineOffset": 38, "name": "neg_exists_of_all_neg", "statement": "(P : X \u2192 Prop) :\n(\u2200 (x : X), \u00acP(x)) \u2192 \u00ac(\u2203 (x : X), P(x))"}, {"type": "lean", "content": "955", "hidden": true}]}, {"name": "", "problemIndex": 6, "objects": [{"type": "lean", "content": "956", "hidden": true}, {"type": "text", "content": "957"}, {"type": "lean", "content": "958", "hidden": true}, {"type": "text", "content": "959"}, {"type": "hint", "content": "960", "title": "961"}, {"type": "lean", "content": "962", "hidden": true}, {"type": "theorem", "text": "963", "lean": "theorem all_neg_of_neg_exists (P : X \u2192 Prop) :\n\u00ac(\u2203 (x : X), P(x)) \u2192 (\u2200 (x : X), \u00acP(x)) :=\n", "sideBar": false, "firstProofLineNumber": 39, "lastProofLineNumber": 54, "textBefore": "import predicate_logic.negating_quantifiers_thm1 --hide\n\n/-\n# Predicate logic\n## Level 19: Negating quantifiers theorem 2\n\n-/\n\n\n\nnamespace exlean -- hide\n\n/-\n## Tasks\nProve the result below. You cannot use `push_neg` for this level.\n\n-/\n\n/- Hint : Using negated hypotheses\n\nSuppose the context contains `h : \u00acp`, for some proposition `p`.\nSuppose also that the target is to prove `false`.\nAs `h : p \u2192 false`, it suffice to prove `p` and then use\nimplication elimination.\n\nRecall that Lean permits an (easier?) backward version of\nimplication elimination. By typing `apply h`, you change the\ntarget to one of proving `p`.\n-/\n\nvariable (X : Type) -- hide\n\n/- Theorem : no-side-bar\n$\\neg(\\exists (x : X),\\ P(x)) \\to (\\forall (x : X),\\ \\neg P(x))$.\n-/\ntheorem all_neg_of_neg_exists (P : X \u2192 Prop) :\n\u00ac(\u2203 (x : X), P(x)) \u2192 (\u2200 (x : X), \u00acP(x)) :=\nbegin\n", "proof": "  assume h : \u00ac(\u2203 (x : X), P(x)),\n  assume x : X,\n  assume h\u2082 : P(x),\n  apply h,\n  use x,\n  from h\u2082,\n\n\n\n\n\n\n\n\n\n", "proof_hint": "sorry", "textAfter": "\nend\n\nend exlean -- hide", "height": 16, "editorText": "sorry", "lineOffset": 38, "name": "all_neg_of_neg_exists", "statement": "(P : X \u2192 Prop) :\n\u00ac(\u2203 (x : X), P(x)) \u2192 (\u2200 (x : X), \u00acP(x))"}, {"type": "lean", "content": "964", "hidden": true}]}, {"name": "", "problemIndex": 6, "objects": [{"type": "lean", "content": "965", "hidden": true}, {"type": "text", "content": "966"}, {"type": "lean", "content": "967", "hidden": true}, {"type": "text", "content": "968"}, {"type": "hint", "content": "969", "title": "970"}, {"type": "lean", "content": "971", "hidden": true}, {"type": "theorem", "text": "972", "lean": "theorem neg_all_of_exists_neg (P : X \u2192 Prop) :\n(\u2203 (x : X), \u00acP(x)) \u2192 \u00ac(\u2200 (x : X), P(x)) :=\n", "sideBar": false, "firstProofLineNumber": 34, "lastProofLineNumber": 45, "textBefore": "import predicate_logic.negating_quantifiers_thm2 -- hide\n\n/-\n# Predicate logic\n## Level 20: Negating quantifiers theorem 3\n-/\n\n\n\nnamespace exlean -- hide\n\n/-\n## Tasks\nProve the result below. You cannot use `push_neg` in this level.\n\n-/\n\n/- Hint : Dealing with the existentially-quantified statement\n\nAt some point in your proof, you will have introduced an\nexistentially-quantified statement into the context.\nRemember that you can decompose such a statement using the `cases`\ntactic.\n-/\n\nvariable (X : Type) -- hide\n\n/- Theorem : no-side-bar\n$\\exists (x : X),\\ \\neg P(x) \\to \\neg(\\forall (x : X),\\ P(x))$.\n-/\ntheorem neg_all_of_exists_neg (P : X \u2192 Prop) :\n(\u2203 (x : X), \u00acP(x)) \u2192 \u00ac(\u2200 (x : X), P(x)) :=\nbegin [no_push_neg]\n", "proof": "  assume h : \u2203 (x : X), \u00acP(x),\n  assume h\u2082 : \u2200 (x : X), P(x),\n  cases h with x h,\n  given h : \u00acP x,\n  have h\u2083 : P x, from h\u2082 x,\n  show false, from h h\u2083,\n\n\n\n\n\n", "proof_hint": "sorry", "textAfter": "\nend\n\nend exlean -- hide", "height": 12, "editorText": "sorry", "lineOffset": 33, "name": "neg_all_of_exists_neg", "statement": "(P : X \u2192 Prop) :\n(\u2203 (x : X), \u00acP(x)) \u2192 \u00ac(\u2200 (x : X), P(x))"}, {"type": "lean", "content": "973", "hidden": true}]}, {"name": "", "problemIndex": 7, "objects": [{"type": "lean", "content": "974", "hidden": true}, {"type": "text", "content": "975"}, {"type": "lean", "content": "976", "hidden": true}, {"type": "text", "content": "977"}, {"type": "hint", "content": "978", "title": "979"}, {"type": "lean", "content": "980", "hidden": true}, {"type": "lean", "content": "981", "hidden": true}, {"type": "theorem", "text": "982", "lean": "theorem exists_neg_of_neg_all (P : X \u2192 Prop) :\n\u00ac(\u2200 (x : X), P(x)) \u2192 (\u2203 (x : X), \u00acP(x)) :=\n", "sideBar": false, "firstProofLineNumber": 40, "lastProofLineNumber": 56, "textBefore": "import predicate_logic.negating_quantifiers_thm3 tactic.localized --hide\n\n/-\n# Predicate logic\n## Level 21: Negating quantifiers theorem 4\n\n-/\n\n\n\nnamespace exlean -- hide\n\n/-\n## Tasks\nProve the result below. You cannot use `push_neg` for this level.\nThis level is somewhat challenging!\n\n-/\n\n/- Hint : The structure of the proof.\n\nAfter doing the natural first step when proving an implication, I\nsuggest doing a proof by contradiction using `by_contra h\u2082`.\nDo the obvious things until you get stuck. At some point, you'll\nneed to use contradiction again.\n-/\n\nvariable (X : Type) -- hide\n\n\n\nopen_locale classical -- hide\n\n/- Theorem : no-side-bar\n$\\neg(\\forall (x : X),\\ P(x)) \\to \\exists (x : X),\\ \\neg P(x)$.\n-/\ntheorem exists_neg_of_neg_all (P : X \u2192 Prop) :\n\u00ac(\u2200 (x : X), P(x)) \u2192 (\u2203 (x : X), \u00acP(x)) :=\nbegin\n", "proof": "  assume h : \u00ac(\u2200 (x : X), P(x)),\n  by_contra h\u2082,\n  apply h,\n  assume x : X,\n  by_contra h\u2083,\n  apply h\u2082,\n  use x,\n\n\n\n\n\n\n\n\n\n", "proof_hint": "sorry", "textAfter": "\nend\n\nend exlean -- hide", "height": 17, "editorText": "sorry", "lineOffset": 39, "name": "exists_neg_of_neg_all", "statement": "(P : X \u2192 Prop) :\n\u00ac(\u2200 (x : X), P(x)) \u2192 (\u2203 (x : X), \u00acP(x))"}, {"type": "lean", "content": "983", "hidden": true}]}], "parents": [2]}, {"name": "984", "levels": [{"name": "", "problemIndex": 11, "objects": [{"type": "lean", "content": "985", "hidden": true}, {"type": "text", "content": "986"}, {"type": "text", "content": "987"}, {"type": "lean", "content": "988", "hidden": true}, {"type": "lean", "content": "989", "hidden": true}, {"type": "lean", "content": "990", "hidden": false}, {"type": "lean", "content": "991", "hidden": true}, {"type": "lean", "content": "992", "hidden": false}, {"type": "text", "content": "993"}, {"type": "lean", "content": "994", "hidden": false}, {"type": "text", "content": "995"}, {"type": "theorem", "text": "996", "lean": "theorem ten_in_even' : (10 : \u2124) \u2208 even' :=\n", "sideBar": false, "firstProofLineNumber": 68, "lastProofLineNumber": 70, "textBefore": "import tactic.modded  tactic.linarith -- hide\n\n/-\n# Sets\n## Level 1: Set membership\n\nA set on a type $X$ is simply a predicate on that type.\n\nLet's define predicates $\\mathsf{even}$ and $\\mathsf{even}'$ on\n$\\mathbb Z$ by\n$\\mathsf{even}(n) := \\exists(m : \\mathbb Z),\\ n = 2 m$ and\n$\\mathsf{even}'(n) := \\exists(m : \\mathbb Z),\\ n + 4 = 2 m$.\n\nThen $\\mathsf{even}$ and $\\mathsf{even}'$ can be seen as sets\nof elements of type $\\mathbb Z$.\n\nWe write $10 \\in \\mathsf{even}$ (for instance) as a synonym for\n$\\mathsf{even}(10)$. More generally, $x \\in P$ is a synonym for\n$P(x)$ (given that $P$ is a predicate on a type $X$ and that $x : X$).\n\nHere's a proof of $10 \\in \\mathsf{even}$.\n\n**Proof**: We must show $\\mathsf{even}(10)$, namely that\n$\\exists(m : \\mathbb Z),\\ 10 = 2m$. Take $m$ to be $5$. Then\n$10 = 2 \\times 5$ follows by arithmetic.\n-/\n\n/-\nIn Lean, we define sets much as we define predicates. The only\ndifference between the following defintion and the definition of\na predicate is the use of `set \u2124` in place of `\u2124 \u2192 Prop`.\n-/\n\nnamespace exlean -- hide\n\nnamespace even_sets -- hide\n\ndef even : set \u2124 := \u03bb n, \u2203 (m : \u2124), n = 2 * m\n\n-- hide\n\ndef even' : set \u2124 := \u03bb n, \u2203 (m : \u2124), n + 4 = 2 * m\n\n/-\nIn Lean, `\u2208` is typed `\\in`. Here is a Lean proof that `10 \u2208 even`.\nNote that I have to type `(10 : \u2124)` so Lean knows I'm working with the\ninteger `10` rather than the natural number `10`.\n-/\n\nexample : (10 : \u2124) \u2208 even :=\nbegin\n  show \u2203 (m : \u2124), 10 = 2 * m,\n  use 5,\n  show (10 : \u2124) = 2 * 5, linarith,\nend\n\n/-\n## Task\nProve that $10 \\in \\mathsf{even}'$, with $\\mathsf{even}'$ defined\nas above.\n-/\n\n/- Theorem : no-side-bar\n$10 \\in \\mathsf{even}'$.\n-/\ntheorem ten_in_even' : (10 : \u2124) \u2208 even' :=\nbegin\n", "proof": "  show \u2203 (m : \u2124), 10 + 4 = 2 * m,\n  use 7,\n  show (10 : \u2124) + 4 = 2 * 7, linarith,", "proof_hint": "sorry", "textAfter": "\nend\n\nend even_sets -- hide\n\nend exlean -- hide", "height": 3, "editorText": "sorry", "lineOffset": 67, "name": "ten_in_even'", "statement": "(10 : \u2124) \u2208 even'"}, {"type": "lean", "content": "997", "hidden": true}, {"type": "lean", "content": "998", "hidden": true}]}, {"name": "", "problemIndex": 5, "objects": [{"type": "lean", "content": "999", "hidden": true}, {"type": "text", "content": "1000"}, {"type": "lean", "content": "1001", "hidden": true}, {"type": "lean", "content": "1002", "hidden": true}, {"type": "text", "content": "1003"}, {"type": "theorem", "text": "1004", "lean": "theorem even_eq_even' : even = even' :=\n", "sideBar": false, "firstProofLineNumber": 59, "firstProofHintLineNumber": 79, "lastProofHintLineNumber": 90, "lastProofLineNumber": 97, "textBefore": "import sets.set_membership -- hide\n\n/-\n# Sets\n## Level 2: Equality of sets\n\nFrom the previous level, recall the definitions of the \nsets $\\mathsf{even}$ and $\\mathsf{even}'$ on\n$\\mathbb Z$ by\n$\\mathsf{even}(n) := \\exists(m : \\mathbb Z),\\ n = 2 m$ and\n$\\mathsf{even}'(n) := \\exists(m : \\mathbb Z),\\ n + 4 = 2 m$.\n\nRecall that for two predicates $P$ and $Q$ on a type $X$ to be\nequal means that $\\forall(x : X),\\ P(x) \\leftrightarrow Q(x)$.\nThis is the principle of extensionality of predicates.\n\nViewed as sets, $P = Q$ means\n$\\forall(x : X),\\ x \\in P \\leftrightarrow x \\in Q$.\n\nI claim that $\\mathsf{even} = \\mathsf{even}'$.\n\nHere's a sketch proof of the result.\n\n**Proof**:\nBy extensionality, we must show\n$\n\\forall (x : \\mathbb Z),\\ x \\in \\mathsf{even} \\leftrightarrow x \\in \\mathsf{even}'.$\n\nAssume $x : \\mathbb Z$. It suffices to show\n$x \\in \\mathsf{even} \\to x \\in \\mathsf{even}'$ and\n$x \\in \\mathsf{even}' \\to x \\in \\mathsf{even}$.\n\nFor the first of these, assume $h : x \\in \\mathsf{even}$.\nThen we have $k : \\mathbb Z$ such that $h_2 : x = 2 k$.\nWe must show $x \\in \\mathsf{even}'$. That is, that\n$\\exists(m : \\mathbb Z),\\ x + 4 = 2m$. Takes $m$ to be $k + 2$.\nWe must show $x + 4 = 2(k + 2)$. This holds by arithmetic.\n\nThe remaining part of the proof is left to the reader.\n-/\n\n\nnamespace exlean -- hide\n\nnamespace even_sets -- hide\n\n/-\n## Task\nBelow, I have given one direction of the proof that `even = even'`.\nIn particular, I have proved `even x \u2192 even' x` (for a given `x : \u2124`).\nYour task is to replace `sorry` with a proof that `even' x \u2192 even x`.\n-/\n\n/- Theorem : no-side-bar\n$\\mathsf{even} = \\mathsf{even}'$.\n-/\ntheorem even_eq_even' : even = even' :=\nbegin\n", "proof": "  ext x, -- By the principle of extensionality, it suffices to ...\n  show (even x \u2194 even' x),\n  split,\n  { show even x \u2192 even' x,\n    assume h : even x,\n    given h : \u2203 (m : \u2124), x = 2 * m,\n    cases h with k h\u2082,\n    given h\u2082 : x = 2 * k,\n    show \u2203 (m : \u2124), x + 4 = 2 * m,\n    use k + 2,\n    linarith, },\n  { show even' x \u2192 even x,\n    assume h : even' x,\n    given h : \u2203 (m : \u2124), x + 4 = 2 * m,\n    cases h with k h\u2082,\n    given h\u2082 : x + 4 = 2 * k,\n    show \u2203 (m : \u2124), x = 2 * m,\n    use k - 2,\n    linarith, }\n/- hint\next x,\nshow (even x \u2194 even' x),\nsplit,\n{ show even x \u2192 even' x,\n  assume h : even x,\n  given h : \u2203 (m : \u2124), x = 2 * m,\n  cases h with k h\u2082,\n  given h\u2082 : x = 2 * k,\n  show \u2203 (m : \u2124), x + 4 = 2 * m,\n  use k + 2,\n  linarith, },\n{ sorry, }\n-/\n\n\n\n\n\n", "proof_hint": "ext x,\nshow (even x \u2194 even' x),\nsplit,\n{ show even x \u2192 even' x,\n  assume h : even x,\n  given h : \u2203 (m : \u2124), x = 2 * m,\n  cases h with k h\u2082,\n  given h\u2082 : x = 2 * k,\n  show \u2203 (m : \u2124), x + 4 = 2 * m,\n  use k + 2,\n  linarith, },\n{ sorry, }", "textAfter": "\nend\n\nend even_sets -- hide\n\nend exlean -- hide", "height": 39, "editorText": "ext x,\nshow (even x \u2194 even' x),\nsplit,\n{ show even x \u2192 even' x,\n  assume h : even x,\n  given h : \u2203 (m : \u2124), x = 2 * m,\n  cases h with k h\u2082,\n  given h\u2082 : x = 2 * k,\n  show \u2203 (m : \u2124), x + 4 = 2 * m,\n  use k + 2,\n  linarith, },\n{ sorry, }", "lineOffset": 58, "name": "even_eq_even'", "statement": "even = even'"}, {"type": "lean", "content": "1005", "hidden": true}, {"type": "lean", "content": "1006", "hidden": true}]}, {"name": "", "problemIndex": 7, "objects": [{"type": "lean", "content": "1007", "hidden": true}, {"type": "text", "content": "1008"}, {"type": "lean", "content": "1009", "hidden": true}, {"type": "text", "content": "1010"}, {"type": "text", "content": "1011"}, {"type": "lean", "content": "1012", "hidden": false}, {"type": "text", "content": "1013"}, {"type": "theorem", "text": "1014", "lean": "theorem seven_in_unusual_set :\n(7 : \u2124) \u2208 {n : \u2124 | \u2203 (m : \u2124), n + 1 = 2 * m + 4} :=\n", "sideBar": false, "firstProofLineNumber": 57, "lastProofLineNumber": 59, "textBefore": "import sets.even_even -- hide\n\n/-\n# Sets\n## Level 3: Set constructor notation\n\nLet $S$ be a predicate on a type $X$. Thus $S$ can be viewed\nas a set of elements of type $X$. It is common to represent the\nset $S$ via the 'set constructor' notation as\n$\\\\{x : X \\mid S(x)\\\\}$. \n\nHere, for example, is an definition, using set constructor notation,\nof the set of even integers.\n$T := \\\\{n : \\mathbb Z \\mid \\exists(m : \\mathbb Z),\\ n = 2m \\\\}$.\n-/\n\nnamespace exlean -- hide\n\n/-\nLet's show that $6 \\in T$.\n\n**Proof**: by definition, we must show $\\exists (m : \\mathbb Z),\\\n6 = 2m$. Take $m$ to be $3$. We show $2 = 2 \\times 3$ by \narithmetic. \u220e\n-/\n\n/-\nBelow is the proof of this result in Lean. Note the use\nof `(6 : \u2124)` to let Lean know we're working with the integer `6`\nand not the natural number `6`.\n-/\n\nexample : (6 : \u2124) \u2208 {n : \u2124 | \u2203 (m : \u2124), n = 2 * m} :=\nbegin\n  show \u2203 (m : \u2124), 6 = 2 * m,\n  use 3,\n  show (6 : \u2124) = 2 * 3, linarith,\nend\n\n\n\n\n/-\n## Task\nAdapt the proof above to show that the integer $7$ belongs to the set\n$\\\\{n : \\mathbb Z \\mid \\exists(m : \\mathbb Z),\\ n + 1 = 2m + 4\\\\}$.\n-/\n\n\n\n/- Theorem : no-side-bar\n$7\\in\\\\{n : \\mathbb Z \\mid \\exists(m : \\mathbb Z),\\ n + 1 = 2m + 4\\\\}$.\n-/\ntheorem seven_in_unusual_set :\n(7 : \u2124) \u2208 {n : \u2124 | \u2203 (m : \u2124), n + 1 = 2 * m + 4} :=\nbegin\n", "proof": "  show \u2203 (m : \u2124), 7 + 1 = 2 * m + 4,\n  use 2,\n  show (7 + 1 : \u2124) = 2 * 2 + 4, linarith,", "proof_hint": "sorry", "textAfter": "\nend\n\n\nend exlean -- hide", "height": 3, "editorText": "sorry", "lineOffset": 56, "name": "seven_in_unusual_set", "statement": "(7 : \u2124) \u2208 {n : \u2124 | \u2203 (m : \u2124), n + 1 = 2 * m + 4}"}, {"type": "lean", "content": "1015", "hidden": true}]}, {"name": "", "problemIndex": 19, "objects": [{"type": "lean", "content": "1016", "hidden": true}, {"type": "text", "content": "1017"}, {"type": "lean", "content": "1018", "hidden": true}, {"type": "text", "content": "1019"}, {"type": "lean", "content": "1020", "hidden": true}, {"type": "lean", "content": "1021", "hidden": false}, {"type": "lean", "content": "1022", "hidden": true}, {"type": "lean", "content": "1023", "hidden": false}, {"type": "text", "content": "1024"}, {"type": "tactic", "content": "1025", "name": "dec_trivial", "sideBar": true}, {"type": "lean", "content": "1026", "hidden": false}, {"type": "lean", "content": "1027", "hidden": true}, {"type": "text", "content": "1028"}, {"type": "lean", "content": "1029", "hidden": true}, {"type": "lean", "content": "1030", "hidden": false}, {"type": "lean", "content": "1031", "hidden": true}, {"type": "lean", "content": "1032", "hidden": false}, {"type": "lean", "content": "1033", "hidden": true}, {"type": "lean", "content": "1034", "hidden": false}, {"type": "theorem", "text": "1035", "lean": "theorem which_set_equal :\n((S = T) \u2228 (S = U)) \u2228 (T = U) :=\n", "sideBar": false, "firstProofLineNumber": 78, "lastProofLineNumber": 78, "textBefore": "import sets.set_constructor  -- hide\n\n/-\n# Sets\n## Level 4: Finite sets\n\nThe set of natural numbers represented by $\\\\{1, 3, 7\\\\}$\nis the predicate $S$ on $\\mathbb N$ given by\n$S(x) := (x = 1) \\lor (x = 3) \\lor (x = 7)$.\n\nLikewise, the set $\\\\{3, 7, 3, 1\\\\}$ is the predicate $T$ on\n$\\mathbb N$ given by\n$T(x) := (x = 3) \\lor (x = 7) \\lor (x = 3) \\lor (x = 1)$.\n\nClearly, $\\forall(x : X),\\ x \\in S \\leftrightarrow x \\in T$. Thus,\n$S$ and $T$ are equal. \n-/\n\nnamespace exlean -- hide\n\n\n/-\nIn Lean, we use `finset` to define finite sets.\n-/\n\nnamespace finset_test1 -- hide\n\ndef S : finset \u2115 := {1, 3, 7}\n\n-- hide\n\ndef T : finset \u2115 := {3, 7, 3, 1}\n\n/-\nResults that can be proved trivially by applying an algorithm (decidability) are proved in Lean\nusing `dec_trivial`. We can prove `S = T` using `dec_trivial`.\n-/\n\n/- Tactic : dec_trivial\nIf Lean knows that a given statement is 'decidable' (that is, it is given an algorithm for\ndetermining whether the statement is true or false), then `dec_trivial` can be used to prove the\ntheorem.\n-/\n\nexample : S = T :=\nbegin\n  dec_trivial,\nend\n\n\nend finset_test1  -- hide\n\n\n/-\n## Task\nProve that two of the sets below are equal.\n-/\n\nnamespace finset_test2 -- hide\n\ndef S : finset \u2115 := {3, 2, 3, 5}\n\n-- hide\n\ndef T : finset \u2115 := {2, 5, 1, 3}\n\n-- hide\n\ndef U : finset \u2115 := {2, 5, 3, 5}\n\n\n/- Theorem : no-side-bar\n$((S = T) \\lor (S = U)) \\lor (T = U)$.\n-/\ntheorem which_set_equal :\n((S = T) \u2228 (S = U)) \u2228 (T = U) :=\nbegin\n", "proof": "  dec_trivial,", "proof_hint": "sorry", "textAfter": "\nend\n\nend finset_test2 -- hide\n\nend exlean -- hide", "height": 1, "editorText": "sorry", "lineOffset": 77, "name": "which_set_equal", "statement": "((S = T) \u2228 (S = U)) \u2228 (T = U)"}, {"type": "lean", "content": "1036", "hidden": true}, {"type": "lean", "content": "1037", "hidden": true}]}, {"name": "", "problemIndex": 14, "objects": [{"type": "lean", "content": "1038", "hidden": true}, {"type": "text", "content": "1039"}, {"type": "lean", "content": "1040", "hidden": true}, {"type": "text", "content": "1041"}, {"type": "lean", "content": "1042", "hidden": true}, {"type": "lean", "content": "1043", "hidden": false}, {"type": "lean", "content": "1044", "hidden": true}, {"type": "lean", "content": "1045", "hidden": true}, {"type": "lean", "content": "1046", "hidden": false}, {"type": "lean", "content": "1047", "hidden": true}, {"type": "text", "content": "1048"}, {"type": "lean", "content": "1049", "hidden": true}, {"type": "lean", "content": "1050", "hidden": true}, {"type": "lean", "content": "1051", "hidden": false}, {"type": "theorem", "text": "1052", "lean": "theorem find_size_of_S :\n\u2203 (m : \u2115), card S = m :=\n", "sideBar": false, "firstProofLineNumber": 61, "lastProofLineNumber": 65, "textBefore": "import sets.finite_sets  -- hide\n\n/-\n# Sets\n## Level 5: The size of finite sets\n\nLet $S$ be a set on a type $X$. For a natural number $n$ to be the *size* of\n$S$ means that $n$ is the smallest natural number for which $S$ can be\nexpressed as $\\\\{a_1, \\dots, a_n\\\\}$. We write $|S|$ for the size of $S$. \n\nFor example, the size of the set $\\\\{1, 3, 4, 3, 1\\\\}$ of integers is $3$\nas the set can be expressed as $\\\\{1, 3, 4\\\\}$ but as no smaller set.#check\n\nIn Lean, the size (more formally called the *cardinality*) of a finite set `S`\nis denoted by `card S`.\n-/\n\nnamespace exlean -- hide\n\n\n/-\nEquations involving cardinalities of sets can be proved trivially by\ndecidability, as below.\n-/\n\nnamespace finset_test3 -- hide\n\ndef S : finset \u2115 := {1, 3, 7}\n\n-- hide\n\nopen finset -- hide\n\nexample : \u2203 (m : \u2115), card S = m :=\nbegin\n  use 3,\n  dec_trivial,\nend\n\nend finset_test3  -- hide\n\n\n/-\n## Task\nFind the cardinality of the given set.\n-/\n\nnamespace finset_test4 -- hide\n\nopen finset -- hide\n\ndef S : finset \u2115 := {3, 2, 3, 5, 1, 2, 7, 5}\n\n/- Theorem : no-side-bar\nGiven $S = \\\\{3, 2, 3, 5, 1, 2, 7, 5\\\\}$,\n$\\exists (m : \\mathbb N),\\ |S| = m$.\n-/\ntheorem find_size_of_S :\n\u2203 (m : \u2115), card S = m :=\nbegin\n", "proof": "  use 5,\n  dec_trivial,\n\n\n", "proof_hint": "sorry", "textAfter": "\nend\n\nend finset_test4 -- hide\n\nend exlean -- hide", "height": 5, "editorText": "sorry", "lineOffset": 60, "name": "find_size_of_S", "statement": "\u2203 (m : \u2115), card S = m"}, {"type": "lean", "content": "1053", "hidden": true}, {"type": "lean", "content": "1054", "hidden": true}]}, {"name": "", "problemIndex": 15, "objects": [{"type": "lean", "content": "1055", "hidden": true}, {"type": "text", "content": "1056"}, {"type": "lean", "content": "1057", "hidden": true}, {"type": "text", "content": "1058"}, {"type": "text", "content": "1059"}, {"type": "lean", "content": "1060", "hidden": true}, {"type": "axiom", "content": "1061", "name": "vacuous_truth :", "sideBar": true}, {"type": "lean", "content": "1062", "hidden": false}, {"type": "text", "content": "1063"}, {"type": "text", "content": "1064"}, {"type": "lean", "content": "1065", "hidden": false}, {"type": "lean", "content": "1066", "hidden": true}, {"type": "lean", "content": "1067", "hidden": false}, {"type": "text", "content": "1068"}, {"type": "hint", "content": "1069", "title": "1070"}, {"type": "theorem", "text": "1071", "lean": "theorem eq_five_of_in_S :\n\u2200 (x : \u2115), x \u2208 S \u2192 x = 5 :=\n", "sideBar": false, "firstProofLineNumber": 111, "lastProofLineNumber": 117, "textBefore": "import sets.finite_sets_cardinality  -- hide\n\n/-\n# Sets\n## Level 6: The empty set\n\nGiven a type $X$, the empty set on $X$, denoted $\\varnothing$, is the set\ndefined so that $x \\in \\varnothing$ means $\\bot$.\n\nEqually, $\\varnothing$ can be viewed as the predicate $\\varnothing : X \\to \\mathsf{Prop}$\ndefined by $\\varnothing(x) := \\bot$.\n-/\n\nnamespace exlean -- hide\n\n\n/-\nThis definition gives rise to the interesting fact that, for any predicate $P$, the proposition\n$P(x)$ is *always* true on the assumption that $x \\in \\varnothing$.\n\n**Theorem**: Let $X$ be a type and let $P$ be a predicate on $X$. Then\n$\\forall (x : X),\\ x \\in \\varnothing \\to P(x)$.\n\n**Proof**: Assume $x : X$. Assume $h : x \\in \\varnothing$. But this just means\n$h : \\bot$. From false elimination on $h$, we show $P(x)$. \u220e\n-/\n\n/-\nBelow is a Lean proof of the result. In Lean, we must specify the type of the empty set.\nHere, we are concerned with `\u2205 : set X`, the empty set of elements of type `X`.\n\nThe symbol `\u2205` is typed `\\empty`.\n-/\n\nvariables {X : Type*} {P : X \u2192 Prop} -- hide\n\n/- Axiom : vacuous_truth :\n\u2200 (x : X), x \u2208 (\u2205 : set X) \u2192 P(x)\n-/\n\nlemma vacuous_truth : \u2200 (x : X), x \u2208 (\u2205 : set X) \u2192 P(x) :=\nbegin\n  assume x : X,\n  assume h : x \u2208 \u2205,\n  given h : false,\n  from false.elim h,\nend\n\nnamespace empty_set1\n\n/-\nAs another example, let $S$ be the set of natural numbers defined by\n$S := \\\\{ n : \\mathbb N \\mid n < 0 \\\\}$. We'll show that $S = \\varnothing$.\n\n**Proof**: We must show (by extensionality), that given $n : \\mathbb N$,\n$n \\in S \\leftrightarrow n \\in \\varnothing$.\n\nThat is, we must show both $n \\in S \\to n \\in \\varnothing$ and\n$n \\in \\varnothing \\to n\\in S$.\n\n1. Assume $h : n \\in S$. That is, $h : n < 0$. This gives false, by arithmetic.\n2. Assume $h : n \\in \\varnothing$. That is, $h : \\bot$.\nWe show $n \\in S$ by false elimination on $h$. \u220e\n-/\n\n/-\nThis can be proved in Lean as follows.\n-/\n\ndef S : set \u2115 := {n : \u2115 | n < 0}   \n\n-- hide\n\nlemma empty_S : S = \u2205 :=\nbegin\n  ext n,\n  show n \u2208 S \u2194 n \u2208 \u2205, \n  split,\n  { show n \u2208 S \u2192 n \u2208 \u2205,\n    assume h : n \u2208 S,\n    given h : n < 0,\n    show false, linarith, },\n  { show n \u2208 \u2205 \u2192 n \u2208 S,\n    assume h : n \u2208 \u2205,\n    given h : false,\n    show n \u2208 S, from false.elim h, },\nend\n\n\n/-\n## Task\nSuppose $S$ is the set of natural numbers given by $S := \\\\{ n : \\mathbb N \\mid n < 0 \\\\}$.\nUsing the two theorems given above, prove \n$\\forall (x : \\mathbb N),\\ x \\in S \\to x = 5$.\n-/\n\n/- Hint : Starting the proof\n\nA good starting point is to rewrite the theorem statement using one of the results given\nin this level.\n\nYou should be able to complete the proof using one more line.\n-/\n\n/- Theorem : no-side-bar\n$\\forall (x : \\mathbb N)\\, x \\in S \\to x = 5$.\n-/\ntheorem eq_five_of_in_S :\n\u2200 (x : \u2115), x \u2208 S \u2192 x = 5 :=\nbegin\n", "proof": "  rw empty_S,\n  from vacuous_truth,\n\n\n\n\n", "proof_hint": "sorry", "textAfter": "\nend\n\nend empty_set1\n\nend exlean -- hide", "height": 7, "editorText": "sorry", "lineOffset": 110, "name": "eq_five_of_in_S", "statement": "\u2200 (x : \u2115), x \u2208 S \u2192 x = 5"}, {"type": "lean", "content": "1072", "hidden": false}, {"type": "lean", "content": "1073", "hidden": true}]}, {"name": "", "problemIndex": 12, "objects": [{"type": "lean", "content": "1074", "hidden": true}, {"type": "text", "content": "1075"}, {"type": "lean", "content": "1076", "hidden": true}, {"type": "text", "content": "1077"}, {"type": "text", "content": "1078"}, {"type": "lean", "content": "1079", "hidden": true}, {"type": "axiom", "content": "1080", "name": "subset_rfl :", "sideBar": true}, {"type": "lean", "content": "1081", "hidden": false}, {"type": "text", "content": "1082"}, {"type": "axiom", "content": "1083", "name": "subset_antisymm (h\u2081 : S \u2286 T) (h\u2082 : T \u2286 S) :", "sideBar": true}, {"type": "lean", "content": "1084", "hidden": false}, {"type": "text", "content": "1085"}, {"type": "theorem", "text": "1086", "lean": "theorem subset_trans {S T U : set X} (h\u2081 : S \u2286 T) (h\u2082 : T \u2286 U) : S \u2286 U :=\n", "sideBar": true, "firstProofLineNumber": 92, "lastProofLineNumber": 104, "textBefore": "import sets.empty_set  -- hide\n\n/-\n# Sets\n## Level 7 : Subsets\n\nLet $S$ and $T$ be sets on a type $X$. For $S$ to be a subset of $T$,\nwritten $S \\subseteq T$, means\n$\\forall (x : X), x \\in S \\to x \\in T$.\n\nThis is abbreviated to $\\forall x \\in S, x \\in T$.\n-/\n\nnamespace exlean -- hide\n\n\n/-\n**Theorem** [Reflexivity of subset]:\nLet $X$ be a type and let $S$ be a set on $X$. Then $S \\subseteq S$.\n\n**Proof**: We must show $\\forall (x : X), x \\in S \\to x \\in S$.\nAssume $x : X$. Assume $h : x \\in S$. We show $x \\in S$, from $h$. \u220e\n-/\n\n/-\nIn Lean, we write `\u2286` as `\\sub`. Below, we prove reflexivity of `\u2286` in Lean.\n-/\n\nvariable {X : Type*} -- hide\n\n/- Axiom : subset_rfl :\nS \u2286 S\n-/\n\nlemma subset_rfl {S : set X} : S \u2286 S :=\nbegin\n  show \u2200 x \u2208 S, x \u2208 S,\n  assume x : X,\n  assume h : x \u2208 S,\n  show x \u2208 S, from h,\nend\n\n/-\nAbove we *proved* a subset result. Let's now *use* subset assumptions to prove\nanother result. The result we're interested in is 'antisymmetry' of the subset relation.\nThat is, on the assumptions that $h_1 : S \\subseteq T$ and $h_2 : T \\subseteq S$, we'll prove $S = T$.\n\n**Proof**: We must show $S = T$. That is, we must show $x \\in S \\leftrightarrow x \\in T$\n(given $x : X$). This requires proving each direction of the double implication.\n\n1. We'll show $x \\in S \\to x \\in T$. Assume $h : x \\in S$. We show $x \\in T$ from $h_1$ and $h$.\n2. We'll show $x \\in T \\to x \\in S$. Assume $h : x \\in T$. We show $x \\in S$ from $h_2$ and $h$.\n\u220e\n\nIn the proof above, our 'from $h_1 : S \\subseteq T$ and $h : x \\in S$ is a combination of\nfor all elimination and implication elimination. The same idiom is accessible in the Lean proof below.\n-/\n\n\n/- Axiom : subset_antisymm (h\u2081 : S \u2286 T) (h\u2082 : T \u2286 S) :\nS = T \n-/\n\ntheorem subset_antisymm {S T : set X} (h\u2081 : S \u2286 T) (h\u2082 : T \u2286 S) : S = T :=\nbegin\n  ext x,\n  show x \u2208 S \u2194 x \u2208 T,\n  split,\n  { show x \u2208 S \u2192 x \u2208 T,\n    assume h : x \u2208 S,\n    show x \u2208 T, from h\u2081 h, },\n  { show x \u2208 T \u2192 x \u2208 S,\n    assume h : x \u2208 T,\n    show x \u2208 S, from h\u2082 h, }\nend\n\n/-\n## Task\nProve the transitivity of $\\subseteq$. That is, given sets $S$, $T$, and $U$\non a type $X$, prove that if $S \\subseteq T$ and $T \\subseteq U$, then $S \\subseteq U$.\n\nYou may draw inspiration from parts of the proof of antisymmetry.\n-/\n\n\n/- Theorem :\nGiven sets $S$, $T$, and $U$\non a type $X$, one has $S \\subseteq T$ and $T \\subseteq U$, then $S \\subseteq U$.\n-/\ntheorem subset_trans {S T U : set X} (h\u2081 : S \u2286 T) (h\u2082 : T \u2286 U) : S \u2286 U :=\nbegin\n", "proof": "  show \u2200 x \u2208 S, x \u2208 U,\n  assume x : X,\n  assume h : x \u2208 S,\n  have h\u2083 : x \u2208 T, from h\u2081 h,\n  show x \u2208 U, from h\u2082 h\u2083, \n\n\n\n\n\n\n\n", "proof_hint": "sorry", "textAfter": "\nend\n\n\n\nend exlean -- hide", "height": 13, "editorText": "sorry", "lineOffset": 91, "name": "subset_trans", "statement": "{S T U : set X} (h\u2081 : S \u2286 T) (h\u2082 : T \u2286 U) : S \u2286 U"}, {"type": "lean", "content": "1087", "hidden": true}]}, {"name": "", "problemIndex": 12, "objects": [{"type": "lean", "content": "1088", "hidden": true}, {"type": "text", "content": "1089"}, {"type": "lean", "content": "1090", "hidden": true}, {"type": "text", "content": "1091"}, {"type": "text", "content": "1092"}, {"type": "tactic", "content": "1093", "name": "tauto!", "sideBar": true}, {"type": "lean", "content": "1094", "hidden": true}, {"type": "lean", "content": "1095", "hidden": false}, {"type": "text", "content": "1096"}, {"type": "text", "content": "1097"}, {"type": "lean", "content": "1098", "hidden": false}, {"type": "text", "content": "1099"}, {"type": "theorem", "text": "1100", "lean": "theorem inter_union_distrib_left {S T U : set X} : S \u2229 (T \u222a U) = (S \u2229 T) \u222a (S \u2229 U) :=\n", "sideBar": true, "firstProofLineNumber": 86, "lastProofLineNumber": 98, "textBefore": "import sets.subset -- hide\n\n/-\n# Sets\n## Level 8 : Intersection and Union\n\n### Intersection\n\nLet $S$ and $T$ be sets on a type $X$. The *intersection* of $S$ and $T$, written $S \\cap T$, is the set\n$\\\\{x : X \\mid (x \\in S) \\land (x \\in T) \\\\}$.\n-/\n\nnamespace exlean -- hide\n\n\n/-\n**Theorem** [Commutativity of intersection]:\nLet $X$ be a type and let $S$ and $T$ be sets on $X$. Then $S \\cap T = T \\cap S$.\n\n**Proof**: We must show $x \\in S \\cap T \\leftrightarrow x \\in T \\cap S$, given $x : X$.\nWe prove this by calculation.\n\\begin{align}\nx \\in S \\cap T  &\\leftrightarrow (x \\in S) \\land  (x \\in T) & & \\text{[by definition]} \\\\\\\\\n&\\leftrightarrow (x \\in T) \\land  (x \\in S)& &\\text{[by logic]} \\\\\\\\\n&\\leftrightarrow  x \\in S \\cap T.  & &\\text{[by definition]}\n\\end{align} \u220e\n-/\n\n/-\nIn Lean, we write `\u2229` as `\\i`. Below, we prove commutativity of `\u2229`. \nWe use the Lean tactic `tauto!`, which proves any result in propositional logic.\n-/\n\n/- Tactic : tauto!\nProves any result in propositional logic.\n-/\n\nvariable {X : Type*} -- hide\n\n\nlemma inter_comm (S T : set X) : S \u2229 T = T \u2229 S :=\nbegin\n  ext x,\n  show x \u2208 S \u2229 T \u2194 x \u2208 T \u2229 S,\n  calc x \u2208 S \u2229 T \u2194 (x \u2208 S) \u2227 (x \u2208 T)    : by refl\n    ... \u2194  (x \u2208 T) \u2227 (x \u2208 S)  : by tauto!\n    ... \u2194 x \u2208 T \u2229 S           : by refl\nend\n\n\n/-\n### Union\n\nLet $S$ and $T$ be sets on a type $X$. The *union* of $S$ and $T$, written $S \\cup T$, is the set\n$\\\\{x : X \\mid (x \\in S) \\lor (x \\in T) \\\\}$.\n-/\n\n/-\nIn Lean, we write `\u222a` as `\\un`. Below is a Lean proof of the commutativity of union.\n-/\n\nlemma union_comm (S T : set X) : S \u222a T = T \u222a S :=\nbegin\n  ext x,\n  show x \u2208 S \u222a T \u2194 x \u2208 T \u222a S,\n  calc\n  x \u2208 S \u222a T \u2194 (x \u2208 S) \u2228 (x \u2208 T)    : by refl\n    ... \u2194  (x \u2208 T) \u2228 (x \u2208 S)  : by tauto!\n    ... \u2194 x \u2208 T \u222a S           : by refl\nend\n\n/-\n## Task\nProve the left distributivity of intersection over union. That is, given sets $S$, $T$, $U$\nof a type $X$, prove $S \\cap (T \\cup U) = (S \\cap T) \\cup (S \\cap U)$.\n\nTry a 'proof by calculation', as above. You should need only three calculation lines.\n-/\n\n/- Theorem :\nGiven sets $S$, $T$, and $U$\non a type $X$, one has  $S \\cap (T \\cup U) = (S \\cap T) \\cup (S \\cap U)$.\n-/\ntheorem inter_union_distrib_left {S T U : set X} : S \u2229 (T \u222a U) = (S \u2229 T) \u222a (S \u2229 U) :=\nbegin\n", "proof": "  ext x,\n  show x \u2208 S \u2229 (T \u222a U) \u2194 x \u2208 (S \u2229 T) \u222a (S \u2229 U),\n  calc\n  x \u2208 S \u2229 (T \u222a U) \u2194  (x \u2208 S) \u2227 ((x \u2208 T) \u2228 (x \u2208 U))   :  by refl\n    ... \u2194  ((x \u2208 S) \u2227 (x \u2208 T)) \u2228 ((x \u2208 S) \u2227 (x \u2208 U)) : by tauto!\n    ... \u2194 x \u2208 (S \u2229 T) \u222a (S \u2229 U)                      :  by refl,\n  \n\n\n\n\n\n", "proof_hint": "sorry", "textAfter": "\nend\n\n\n\nend exlean -- hide", "height": 13, "editorText": "sorry", "lineOffset": 85, "name": "inter_union_distrib_left", "statement": "{S T U : set X} : S \u2229 (T \u222a U) = (S \u2229 T) \u222a (S \u2229 U)"}, {"type": "lean", "content": "1101", "hidden": true}]}, {"name": "", "problemIndex": 6, "objects": [{"type": "lean", "content": "1102", "hidden": true}, {"type": "text", "content": "1103"}, {"type": "lean", "content": "1104", "hidden": true}, {"type": "text", "content": "1105"}, {"type": "lean", "content": "1106", "hidden": true}, {"type": "text", "content": "1107"}, {"type": "theorem", "text": "1108", "lean": "theorem subset_inter_iff {S T U : set X} :\nU \u2286 (S \u2229 T) \u2194 (U \u2286 S) \u2227 (U \u2286 T) :=\n", "sideBar": true, "firstProofLineNumber": 48, "firstProofHintLineNumber": 75, "lastProofHintLineNumber": 89, "lastProofLineNumber": 90, "textBefore": "import sets.intersection_union -- hide\n\n/-\n# Sets\n## Level 9 : Intersections and subsets\n-/\n\nnamespace exlean -- hide\n\n\n/-\n**Theorem**:\nLet $X$ be a type and let $S$, $T$, and $U$ be sets on $X$. \nThen $U \\subseteq (S \\cap T) \\leftrightarrow (U \\subseteq S) \\land (U \\subseteq T)$.\n\n**Sketch proof**: We must show both directions of the double implication.\n\n1. We'll show $U \\subseteq (S \\cap T) \\to (U \\subseteq S) \\land (U \\subseteq T)$\nAssume $h : U \\subseteq (S \\cap T)$. We'll show $(U \\subseteq S) \\land (U \\subseteq T)$.\nTo prove this is to prove two statements.\n\n  1.1. We'll show $U \\subseteq S$. Assume $x : X$. Assume $h_2 : x \\in U$. We must show\n    $x \\in S$.  We have $h_3 : x \\in S \\cap T$, from $h$ and $h_2$. The remainder of this\n    subproof is left for the reader.\n\n\n  1.2. We'll show $U \\subseteq T$. Do this yourself.\n\n\n2. We'll show $(U \\subseteq S) \\land (U \\subseteq T) \\to U \\subseteq (S \\cap T)$. Or rather,\nyou'll show this!  \u220e\n-/\n\nvariable {X : Type*} -- hide\n\n/-\n## Task\nComplete the Lean proof below of the theorem above.\n-/\n\n/- Theorem :\nLet $X$ be a type and let $S$, $T$, and $U$ be sets on $X$. \nThen $U \\subseteq (S \\cap T) \\leftrightarrow (U \\subseteq S) \\land (U \\subseteq T)$\n-/\ntheorem subset_inter_iff {S T U : set X} :\nU \u2286 (S \u2229 T) \u2194 (U \u2286 S) \u2227 (U \u2286 T) :=\nbegin\n", "proof": "  split,\n  { show U \u2286 (S \u2229 T) \u2192 (U \u2286 S) \u2227 (U \u2286 T),\n    assume h : U \u2286 (S \u2229 T),\n    show (U \u2286 S) \u2227 (U \u2286 T),\n    split,\n    { assume x : X,\n      assume h\u2082 : x \u2208 U,\n      show x \u2208 S,\n      have h\u2083 : x \u2208 S \u2229 T, from h h\u2082,\n      show x \u2208 S, from h\u2083.left, },\n    { assume x : X,\n      assume h\u2082 : x \u2208 U,\n      show x \u2208 T,\n      have h\u2083 : x \u2208 S \u2229 T, from h h\u2082,\n      show x \u2208 T, from h\u2083.right, }, },\n  { show (U \u2286 S) \u2227 (U \u2286 T) \u2192 U \u2286 (S \u2229 T),\n    assume h : (U \u2286 S) \u2227 (U \u2286 T),\n    assume x : X,\n    assume h\u2082 : x \u2208 U,\n    show (x \u2208 S) \u2227 (x \u2208 T),\n    cases h with h\u2083 h\u2084,\n    given h\u2083 : U \u2286 S,\n    given h\u2084 : U \u2286 T,\n    have h\u2085 : x \u2208 S, from h\u2083 h\u2082,\n    have h\u2086 : x \u2208 T, from h\u2084 h\u2082,\n    show x \u2208 S \u2227 x \u2208 T, from and.intro h\u2085 h\u2086, },\n/- hint\nsplit,\n{ show U \u2286 (S \u2229 T) \u2192 (U \u2286 S) \u2227 (U \u2286 T), -- Part 1 of proof.\n  assume h : U \u2286 (S \u2229 T),\n  show (U \u2286 S) \u2227 (U \u2286 T),\n  split,\n  { show U \u2286 S,                          -- Part 1.1.\n    assume x : X,\n    assume h\u2082 : x \u2208 U,\n    show x \u2208 S,\n    have h\u2083 : x \u2208 S \u2229 T, from h h\u2082,\n    sorry },\n  { show U \u2286 T,                          -- Part 1.2.\n    sorry, }, },\n{ show (U \u2286 S) \u2227 (U \u2286 T) \u2192 U \u2286 (S \u2229 T), -- Part 2.\n  sorry, },\n-/", "proof_hint": "split,\n{ show U \u2286 (S \u2229 T) \u2192 (U \u2286 S) \u2227 (U \u2286 T), -- Part 1 of proof.\n  assume h : U \u2286 (S \u2229 T),\n  show (U \u2286 S) \u2227 (U \u2286 T),\n  split,\n  { show U \u2286 S,                          -- Part 1.1.\n    assume x : X,\n    assume h\u2082 : x \u2208 U,\n    show x \u2208 S,\n    have h\u2083 : x \u2208 S \u2229 T, from h h\u2082,\n    sorry },\n  { show U \u2286 T,                          -- Part 1.2.\n    sorry, }, },\n{ show (U \u2286 S) \u2227 (U \u2286 T) \u2192 U \u2286 (S \u2229 T), -- Part 2.\n  sorry, },", "textAfter": "\nend\n\n\nend exlean -- hide", "height": 43, "editorText": "split,\n{ show U \u2286 (S \u2229 T) \u2192 (U \u2286 S) \u2227 (U \u2286 T), -- Part 1 of proof.\n  assume h : U \u2286 (S \u2229 T),\n  show (U \u2286 S) \u2227 (U \u2286 T),\n  split,\n  { show U \u2286 S,                          -- Part 1.1.\n    assume x : X,\n    assume h\u2082 : x \u2208 U,\n    show x \u2208 S,\n    have h\u2083 : x \u2208 S \u2229 T, from h h\u2082,\n    sorry },\n  { show U \u2286 T,                          -- Part 1.2.\n    sorry, }, },\n{ show (U \u2286 S) \u2227 (U \u2286 T) \u2192 U \u2286 (S \u2229 T), -- Part 2.\n  sorry, },", "lineOffset": 47, "name": "subset_inter_iff", "statement": "{S T U : set X} :\nU \u2286 (S \u2229 T) \u2194 (U \u2286 S) \u2227 (U \u2286 T)"}, {"type": "lean", "content": "1109", "hidden": true}]}, {"name": "", "problemIndex": 5, "objects": [{"type": "lean", "content": "1110", "hidden": true}, {"type": "text", "content": "1111"}, {"type": "lean", "content": "1112", "hidden": false}, {"type": "lean", "content": "1113", "hidden": true}, {"type": "text", "content": "1114"}, {"type": "theorem", "text": "1115", "lean": "theorem diff_inter_diff {S T U : set X} :\n(S \\ T) \u2229 (S \\ U) = S \\ (T \u222a U) :=\n", "sideBar": true, "firstProofLineNumber": 31, "lastProofLineNumber": 42, "textBefore": "import sets.subset_inter -- hide\n\n/-\n# Sets\n## Level 10: Set difference\n\nLet $S$ and $T$ be sets on a type $X$. The *set difference* of $S$ and $T$, written $S \\setminus T$, is the set\n$\\\\{x : X \\mid (x \\in S) \\land (x \\notin T) \\\\}$.\n\n\n-/\n\n\nvariable {X : Type*}\n\n\nnamespace exlean -- hide\n\n/-\n## Task\nComplete the proof below.\n-/\n\n/- Theorem :\nLet $S$, $T$, and $U$ be sets on a type $X$, then\n$(S \\setminus T)  \\cap (S \\setminus U) = S \\setminus (T \\cup U)$.\n-/\ntheorem diff_inter_diff {S T U : set X} :\n(S \\ T) \u2229 (S \\ U) = S \\ (T \u222a U) :=\nbegin\n", "proof": "  ext x,\n  show x \u2208 S \\ T \u2229 (S \\ U) \u2194 x \u2208 S \\ (T \u222a U),\n  calc\n  x \u2208 S \\ T \u2229 (S \\ U) \u2194 (x \u2208 S \u2227 x \u2209 T) \u2227 (x \u2208 S \u2227 x \u2209 U) : by refl \n  ... \u2194 (x \u2208 S) \u2227 (x \u2209 T \u2227 x \u2209 U)               : by tauto!\n  ... \u2194 (x \u2208 S) \u2227 \u00ac(x \u2208 T \u2228 x \u2208 U)              : by tauto!\n  ... \u2194   x \u2208 S \\ (T \u222a U)                       : by refl,\n\n\n\n\n", "proof_hint": "sorry", "textAfter": "\nend\n\n\n\nend exlean -- hide", "height": 12, "editorText": "sorry", "lineOffset": 30, "name": "diff_inter_diff", "statement": "{S T U : set X} :\n(S \\ T) \u2229 (S \\ U) = S \\ (T \u222a U)"}, {"type": "lean", "content": "1116", "hidden": true}]}, {"name": "", "problemIndex": 9, "objects": [{"type": "lean", "content": "1117", "hidden": true}, {"type": "text", "content": "1118"}, {"type": "text", "content": "1119"}, {"type": "text", "content": "1120"}, {"type": "lean", "content": "1121", "hidden": true}, {"type": "lean", "content": "1122", "hidden": true}, {"type": "axiom", "content": "1123", "name": "union_prod {A B : set X} {S : set Y} :", "sideBar": true}, {"type": "lean", "content": "1124", "hidden": false}, {"type": "text", "content": "1125"}, {"type": "theorem", "text": "1126", "lean": "theorem inter_prod {A B : set X} {S : set Y} :\n(A \u2229 B) \u00d7\u02e2 S = (A \u00d7\u02e2 S) \u2229 (B \u00d7\u02e2 S) :=\n", "sideBar": true, "firstProofLineNumber": 59, "lastProofLineNumber": 64, "textBefore": "import sets.intersection_union -- hide\n\n/-\n# Sets\n## Level 11: Cartesian product\n\nLet $X$ and $Y$ be types. The *Cartesian product* of $X$ and $Y$, written $X \\times Y$, is the set of pairs\n$(x, y)$, where $x : X$ and $y : Y$. Given a term $z : X \\times Y$, we write $z = (z_1, z_2)$.\n\n\nLet $S$ be a set on $X$ and let $T$ be a set on $Y$. The *Cartesian product*\nof $S$ and $T$ is the set $\\\\{z : X \\times Y \\mid (z_1 \\in S) \\land (z_2 \\in T) \\\\}$.\n-/\n\n/-\nIn Lean, we write `X \u00d7 Y` for the Cartesian product of types `X` and `Y`, where `\u00d7` is typed `\\x`.\n\nLikewise, we write `S \u00d7\u02e2 T` for the Cartesian product of two sets `S` and `T`. Here, `\u00d7\u02e2` is typed `\\x\\^s`.\n\nGiven `z : X \u00d7 Y`, we write `z.fst` and `z.snd` for the first and second elements of the pair `z`. Thus,\n`z = (z.fst, z.snd)`.\n-/\n\n/-\nBelow is a Lean proof of the mathematical result $(A \\cup B) \\times S = (A \\times S) \\cup (B \\times S)$.\n-/\n\n\nnamespace exlean -- hide\n\nvariables {X Y : Type*} -- hide\n\n/- Axiom : union_prod {A B : set X} {S : set Y} :\n(A \u222a B) \u00d7\u02e2 S = (A \u00d7\u02e2 S) \u222a (B \u00d7\u02e2 S)\n-/\n\nlemma union_prod {A B : set X} {S : set Y} :\n(A \u222a B) \u00d7\u02e2 S = (A \u00d7\u02e2 S) \u222a (B \u00d7\u02e2 S) :=\nbegin\n  ext x,\n  show x \u2208 (A \u222a B) \u00d7\u02e2 S \u2194 x \u2208 A \u00d7\u02e2 S \u222a B \u00d7\u02e2 S,\n  calc\n  x \u2208 (A \u222a B) \u00d7\u02e2 S  \u2194 (x.fst \u2208 A \u2228 x.fst \u2208 B) \u2227 x.snd \u2208 S : by refl\n    ... \u2194 (x.fst \u2208 A \u2227 x.snd \u2208 S) \u2228 (x.fst \u2208 B \u2227 x.snd \u2208 S) : by tauto!\n    ... \u2194 x \u2208 A \u00d7\u02e2 S \u222a B \u00d7\u02e2 S                               : by refl\nend\n\n/-\n## Task\nProve that $(A \\cap B) \\times S = (A \\times S) \\cap (B \\times S)$.\n-/\n\n/- Theorem :\n$(A \\cap B) \\times S = (A \\times S) \\cap (B \\times S)$.\n-/\ntheorem inter_prod {A B : set X} {S : set Y} :\n(A \u2229 B) \u00d7\u02e2 S = (A \u00d7\u02e2 S) \u2229 (B \u00d7\u02e2 S) :=\nbegin\n", "proof": "  ext x,\n  show x \u2208 (A \u2229 B) \u00d7\u02e2 S \u2194 x \u2208 A \u00d7\u02e2 S \u2229 B \u00d7\u02e2 S,\n  calc\n  x \u2208 (A \u2229 B) \u00d7\u02e2 S  \u2194 (x.fst \u2208 A \u2227 x.fst \u2208 B) \u2227 x.snd \u2208 S   : by refl\n    ... \u2194 (x.fst \u2208 A \u2227 x.snd \u2208 S) \u2227 (x.fst \u2208 B \u2227 x.snd \u2208 S) : by tauto!\n    ... \u2194 x \u2208 A \u00d7\u02e2 S \u2229 B \u00d7\u02e2 S                                 : by refl", "proof_hint": "sorry", "textAfter": "\nend\n\nend exlean -- hide", "height": 6, "editorText": "sorry", "lineOffset": 58, "name": "inter_prod", "statement": "{A B : set X} {S : set Y} :\n(A \u2229 B) \u00d7\u02e2 S = (A \u00d7\u02e2 S) \u2229 (B \u00d7\u02e2 S)"}, {"type": "lean", "content": "1127", "hidden": true}]}, {"name": "", "problemIndex": 8, "objects": [{"type": "lean", "content": "1128", "hidden": true}, {"type": "text", "content": "1129"}, {"type": "text", "content": "1130"}, {"type": "lean", "content": "1131", "hidden": true}, {"type": "lean", "content": "1132", "hidden": true}, {"type": "text", "content": "1133"}, {"type": "lean", "content": "1134", "hidden": false}, {"type": "text", "content": "1135"}, {"type": "theorem", "text": "1136", "lean": "theorem powerset_sub_power_of_sub {S T : set X} (h : S \u2286 T) : \ud835\udcab(S) \u2286 \ud835\udcab(T) :=\n", "sideBar": true, "firstProofLineNumber": 53, "firstProofHintLineNumber": 61, "lastProofHintLineNumber": 62, "lastProofLineNumber": 63, "textBefore": "import sets.union_prod -- hide\n\n/-\n# Sets\n## Level 12: Power set\n\nLet $S$ be a set on a type $X$. The *power set* of $S$, denoted $\\mathcal P(S)$, is the set of\nall subsets of $S$.\n\nThat is, $A \\in \\mathcal P(S)$ means $A \\subseteq S$.\n\nIn set constructor notation, the definition of $\\mathcal P(S)$ is\n$\n\\mathcal P(S) := \\\\{A : \\text{set} X \\mid A \\subseteq S\\\u2984.\n$\n\nThis illustrates that the members $A$ of the set $\\mathcal P(S)$ are terms of\ntype $\\text{set} X$. That is, each $A$ is itself a set of elements of type $X$.\n-/\n\n/-\nIn Lean, the power set of `S` is written `\ud835\udcab(S)`, where `\ud835\udcab` is typed `\\power`.\n-/\n\nvariables {X : Type*} -- hide\n\nnamespace exlean -- hide\n\n/-\nHere is a Lean proof that $S \\in \\mathcal P(S)$, for every set $S$.\n-/\n\nexample (S : set X) : S \u2208 \ud835\udcab(S) :=\nbegin\n  show S \u2286 S,\n  from subset_refl S,\nend\n\n\n/-\n## Task\nProve that for all sets $S$ and $T$ on a type $X$, if $S \\subseteq T$, then\n$\\mathcal P(S) \\subseteq \\mathcal P(T)$.\n-/\n\n\n/- Theorem :\nFor all sets $S$ and $T$ on a type $X$, if $S \\subseteq T$, then\n$\\mathcal P(S) \\subseteq \\mathcal P(T)$.\n-/\ntheorem powerset_sub_power_of_sub {S T : set X} (h : S \u2286 T) : \ud835\udcab(S) \u2286 \ud835\udcab(T) :=\nbegin\n", "proof": "  assume A : set X,\n  show A \u2208 \ud835\udcab(S) \u2192 A \u2208 \ud835\udcab(T),\n  assume h\u2082 : A \u2208 \ud835\udcab(S),\n  show A \u2208 \ud835\udcab(T),\n  show A \u2286 T,\n  given h\u2082 : A \u2286 S,\n  from subset_trans h\u2082 h, \n/- hint\nassume A : set X,\nshow A \u2208 \ud835\udcab(S) \u2192 A \u2208 \ud835\udcab(T),\n-/", "proof_hint": "assume A : set X,\nshow A \u2208 \ud835\udcab(S) \u2192 A \u2208 \ud835\udcab(T),", "textAfter": "\nend\n\nend exlean -- hide", "height": 11, "editorText": "assume A : set X,\nshow A \u2208 \ud835\udcab(S) \u2192 A \u2208 \ud835\udcab(T),", "lineOffset": 52, "name": "powerset_sub_power_of_sub", "statement": "{S T : set X} (h : S \u2286 T) : \ud835\udcab(S) \u2286 \ud835\udcab(T)"}, {"type": "lean", "content": "1137", "hidden": true}]}, {"name": "", "problemIndex": 6, "objects": [{"type": "lean", "content": "1138", "hidden": true}, {"type": "text", "content": "1139"}, {"type": "lean", "content": "1140", "hidden": true}, {"type": "lean", "content": "1141", "hidden": true}, {"type": "text", "content": "1142"}, {"type": "hint", "content": "1143", "title": "1144"}, {"type": "theorem", "text": "1145", "lean": "theorem powerset_inter {S T : set X} : \ud835\udcab(S \u2229 T) = \ud835\udcab(S) \u2229 \ud835\udcab(T) :=\n", "sideBar": true, "firstProofLineNumber": 33, "firstProofHintLineNumber": 40, "lastProofHintLineNumber": 41, "lastProofLineNumber": 44, "textBefore": "import sets.power_set -- hide\n\n/-\n# Sets\n## Level 13: Power sets and intersections\n-/\n\n\n\nvariables {X : Type*} -- hide\n\nnamespace exlean -- hide\n\n/-\n## Task\nProve, by calculation, that for all sets $S$ and $T$ on a type $X$, \n$\\mathcal P(S \\cap T) = \\mathcal P(S) \\cap \\mathcal P(T)$.\n-/\n\n/- Hint : A useful result\nCheck the sidebar for a useful theorem you proved in a previous level\nof this world.\n-/\n\n\n\n/- Theorem : \nFor all sets $S$ and $T$ on a type $X$,\n$\\mathcal P(S \\cap T) = \\mathcal P(S) \\cap \\mathcal P(T)$.\n-/\ntheorem powerset_inter {S T : set X} : \ud835\udcab(S \u2229 T) = \ud835\udcab(S) \u2229 \ud835\udcab(T) :=\nbegin\n", "proof": "  ext A,\n  show A \u2208 \ud835\udcab(S \u2229 T) \u2194  A \u2208 \ud835\udcab(S) \u2229 \ud835\udcab(T),\n  calc\n  A \u2208 \ud835\udcab(S \u2229 T) \u2194 A \u2286 S \u2229 T : by refl\n  ... \u2194 (A \u2286 S) \u2227 (A \u2286 T)  : set.subset_inter_iff\n  ... \u2194  A \u2208 \ud835\udcab(S) \u2229 \ud835\udcab(T)   : by refl\n/- hint\next A,\nshow A \u2208 \ud835\udcab(S \u2229 T) \u2194  A \u2208 \ud835\udcab(S) \u2229 \ud835\udcab(T),\n-/\n\n", "proof_hint": "ext A,\nshow A \u2208 \ud835\udcab(S \u2229 T) \u2194  A \u2208 \ud835\udcab(S) \u2229 \ud835\udcab(T),", "textAfter": "\nend\n\nend exlean -- hide", "height": 12, "editorText": "ext A,\nshow A \u2208 \ud835\udcab(S \u2229 T) \u2194  A \u2208 \ud835\udcab(S) \u2229 \ud835\udcab(T),", "lineOffset": 32, "name": "powerset_inter", "statement": "{S T : set X} : \ud835\udcab(S \u2229 T) = \ud835\udcab(S) \u2229 \ud835\udcab(T)"}, {"type": "lean", "content": "1146", "hidden": true}]}], "parents": [3]}], "texts": [["Modern Mathematics with Lean", "# Modern Mathematics with Lean, version 0.4\n\n## By Gihan Marasingha\n\nThis is an interactive book aimed at beginning mathematics undergraduates. You'll learn to prove\ntheorems online using a computer tool called Lean.\n\nEach chapter is represented by a coloured circular button in the right-hand pane. Blue indicates your\ncurrent position, green is for completed chapters, and grey is for unread or incomplete chapters.\n\nAt every stage in a proof, there is a *target*, the thing you want to prove, and a *context*, the\nset of things you have already proved or assumed at the beginning of your argument.\nThe target and context change through the proof.\n\nThe word *goal* is used to refer variously to the target or to the combination of target and context.\n\nYou'll use *tactics* to modify the goal until you have proved the target (called 'closing the goal').\nEach tactic may invoke one or more *theorems*.\n\nNote: the book is several megabytes in size. It must be downloaded before you can begin to work on the\nproblems. Once you open the book, wait for the text 'Lean is busy...' to disappear from the\ntop-right-hand pane before using Lean.\n\n## Lean symbols\n\n<table>\n  <tr>\n    <th style=\"padding-right : 20px\">Symbol</th>\n    <th style=\"padding-right : 20px; text-align: left\">Lean input</th>\n    <th style=\"padding-right : 20px; text-align: left\">Meaning</th>\n  </tr>\n  <tr>\n    <td><code>h\u2081</code></td>\n    <td><code>h\\1</code></td>\n    <td>Subscript</td>\n  </tr>\n  <tr>\n    <td><code>\u03bb</code></td> \n    <td><code>\\lam</code></td>\n    <td>Lambda abstraction</td> \n  </tr>\n  <tr>\n    <td><code>X \u2192 Y</code></td>\n    <td><code>X \\r Y</code></td>\n    <td>Function type</td>\n  </tr>\n  <tr>\n    <td><code>\u2115</code></td>\n    <td><code>\\N</code></td>\n    <td>Natural number type</td>\n  </tr>\n  <tr>\n    <td><code>\u2124</code></td>\n    <td><code>\\Z<code></td>\n    <td>Integer type</td>\n  </tr>\n  <tr>\n    <td><code>\u211a</code></td>\n    <td><code>\\R<code></td>\n    <td>Rational number type</td>\n  </tr>\n  <tr>\n    <td><code>\u211d</code></td>\n    <td><code>\\R<code></td>\n    <td>Real number type</td>\n  </tr>\n  <tr>\n    <td><code>\u2211</code></td>\n    <td><code>\\sum<code></td>\n    <td>Sum (in finite sum notation)</td>\n  </tr>\n  <tr>\n    <td><code>\u227a</code></td>\n    <td><code>\\pref<code></td>\n    <td>Less than (in finite sum notation)</td>\n  </tr>\n  <tr>\n    <td><code>\u227c</code></td>\n    <td><code>\\preceq<code></td>\n    <td>Less than or equal to (in finite sum notation)</td>\n  </tr>\n  <tr>\n    <td><code>\u2227</code></td>\n    <td><code>\\and<code></td>\n    <td>Logical and</td>\n  </tr>\n  <tr>\n    <td><code>\u2228</code></td>\n    <td><code>\\or<code></td>\n    <td>Logical or</td>\n  </tr>\n  <tr>\n    <td><code>\u2192</code></td>\n    <td><code>\\r<code></td>\n    <td>Logical implication</td>\n  </tr>\n    <tr>\n    <td><code>\u2194</code></td>\n    <td><code>\\iff<code></td>\n    <td>Logical if and only if</td>\n  </tr>\n  <tr>\n    <td><code>\u00ac</code></td>\n    <td><code>\\n<code></td>\n    <td>Logical not</td>\n  </tr>\n  <tr>\n    <td><code>\u2200</code></td>\n    <td><code>\\all<code></td>\n    <td>For all</td>\n  </tr>\n  <tr>\n    <td><code>\u2203</code></td>\n    <td><code>\\ex<code></td>\n    <td>There exists</td>\n  </tr>\n  <tr>\n    <td><code>\u2208</code></td>\n    <td><code>\\in<code></td>\n    <td>Set membership</td>\n  </tr>\n  <tr>\n    <td><code>\u2205</code></td>\n    <td><code>\\empty<code></td>\n    <td>Empty set</td>\n  </tr>\n  <tr>\n    <td><code>\u2286</code></td>\n    <td><code>\\sub<code></td>\n    <td>Subset</td>\n  </tr>\n  <tr>\n    <td><code>\u2229</code></td>\n    <td><code>\\i<code></td>\n    <td>Set intersection</td>\n  </tr>\n  <tr>\n    <td><code>\u222a</code></td>\n    <td><code>\\un<code></td>\n    <td>Set union</td>\n  </tr>\n  <tr>\n    <td><code>\u00d7\u02e2</code></td>\n    <td><code>\\x\\^s<code></td>\n    <td>Cartesian product of sets</td>\n  </tr>\n  <tr>\n    <td><code>\ud835\udcab</code></td>\n    <td><code>\\power<code></td>\n    <td>Power set</td>\n  </tr>\n</table>\n\n*Modern mathematics with Lean* is part of the \n<a href=\"https://exlean.org\" target=\"blank\">exlean</a> project.\n\n**This book is under construction.** \n\n## Credits\n\nThis game was made using the\n<a href=\"https://github.com/mpedramfar/Lean-game-maker\">Lean Game Maker</a> by Mohammad Pedramfar.\n\nIt uses ideas and special tactics from the \n<a href=\"https://www.ma.imperial.ac.uk/~buzzard/xena/natural_number_game/\">Natural Number Game</a>\nby Kevin Buzzard.\n\n<a href=\"https://leanprover.github.io/\" target=\"blank\">Lean</a> is an interactive theorem prover developed at Microsoft Research under the direction of\nLeonardo de Moura.\n\nMathlib, Lean's mathematical library, is developed by the <a href=\"https://leanprover-community.github.io/\" target=\"blank\">Lean community</a>.\n", "Equations", "import mynat.basic -- hide\n", "# Equations\n\n## Level 1: Proving equations through reflexivity\n\nThe `rfl` principle (short for reflexivity) can be used to prove any statement of the form\n`?X = ?X`. Here, I use `?X` to stand in for any expression of any type.\nIt could be `8 + 9` or `a * b` or `\"adele\"` or whatever.\n\nBelow, you are asked to prove `x + y = x + y`, where `x` and `y` are natural numbers.\nThe word `sorry` between the `begin` and `end` lines below asks Lean not to give an error message if a\nproof isn't complete. You'll see a <span style=\"color:orange\">warning</span> message in the\nbottom-right hand pane. This indicates you shouldn't trust the proof just yet, as it uses `sorry`!\n\nDelete `sorry` (using the backspace key on your keyboard). In the right-hand pane you'll see:\n```\nx y : \u2115\n\u22a2 x + y = x + y\n```\n\nHere, `x y : \u2115` is the *context*, the set of things you know. In this case, you know `x` and `y`\nare natural numbers.\n\nThe *target* is `\u22a2 x + y = x + y`. The `\u22a2` symbol can be read 'to prove'. So your target is\nto prove `x + y = x + y`.\n\nThe bottom part of the right-hand pane shows an <span style=\"color:red\">error</span>  message:\ntactic failed, there are unsolved goals. Don't panic! It's just telling you that you haven't yet\nproved the result.\n\nYour task is to replace `sorry` with `from rfl,`. Note the comma at the end of the line!\nIf you're successful, Lean will respond with the message `no goals` or `Proof complete!`\n\nIn `from rfl`, the word `from` is a *tactic*. This tactic takes a proof term and closes a goal\nif the provided proof term exactly matches the target. The list of tactics you've seen so far\nis presented in the left-hand pane.\n", "## Translation to a hand-written proof\n\nIn words, the `from rfl` says, \"The result holds from reflexivity\".\n\n", "If `h` is a hypothesis or proof term that matches the target, then `from h` will close the goal.\n\n`from` is a synonym for the tactic `exact`.\n", "If `h` is a hypothesis or proof term that matches the target, then `exact h` will close the goal.\n", "a = a\n", "namespace exlean -- hide\n", "open mynat -- hide\n", "open_locale mynum -- hide\n", "variables (x y : \u2115) -- Declare `x` and `y` to be natural numbers.\n", "$x + y = x + y$, for all natural numbers $x$ and $y$.\n", "end exlean -- hide\n", "import mynat.add_mul_lemmas  -- hide\n", "# Equations\n\n## Level 2: Commutativity of addition\n\nNow we'll prove something (slighlty) more interesting, than `x + 3 = 3 + x`.\nTry `from rfl,` below (remember to put a comma after `rfl`) and see what happens.\n\nYou'll get an error message:\n```\ninvalid apply tactic, failed to unify\n  x + 3 = 3 + x\nwith\n  ?m_2 = ?m_2\n```\n\nLean tells you that you're trying to use `rfl` to prove `x + 3 = 3 + x`, but it expects a target\nof the form `?m_2 = ?m_2`.\n\nThe problem: even though we 'know' the left and right sides are equal, they are not\n*identically equal*.\nFortunately, Lean comes with a *theorem* of just the right kind. It's called `add_comm`, which is\nshort for additive commutativity.\nThe result `add_comm a b` states that `a + b = b + a`, where `a` and `b` are natural numbers.\n\nTo apply this theorem, we'll use the `from` tactic.\n\nReplace the `sorry` below with `from add_comm x 3` (followed by a comma\u2014I won't mention this from now\non).\n\nAlternatively, write `apply add_comm`. The `apply` tactic automatically fills in the missing\narguments to `add_comm`.\n", "`apply`, provided with a theorem name and any number of conditions of the theorem,\nopens as many new goals are necessary to fill in proofs of the remaining conditions\nof the theorem.\n", "namespace exlean -- hide\n", "open_locale mynum -- hide\n", "variables (x y : \u2115) -- hide\n", "a + b = b + a\n", "theorem add_comm (a b : \u2115) : a + b = b + a := mynat.add_comm' a b -- hide\n", "$x + 3 = 3 + x$, for all natural numbers $x$.\n", "end exlean -- hide\n", "## Translation to a hand-written proof\n\nIn words, `from add_comm x 3` says, \"The result follows from additive commutativity applied\nto $x$ and $3$.\"\n\nLikewise, `apply add_comm` says, \"The result follows by applying additive commutativity\".\n", "## Anatomy of a level\n\nEach level contains three vertical panes. The left-hand pane contains a list of the tactics and\ntheorem statements you've seen so far. Click on the arrows to dig deeper.\n\nThe middle pane is the one you're reading now! It contains text and interactive exercises.\nThe right-hand pane contains the Lean Infoview window, showing the 'tactic state' and error messages.\n\nYou can navigate through the book using the buttons in the top horizonal pane. The circular arrow\nresets your progress.\n", "import equations.add_comm -- hide\n", "# Equations\n\n## Level 3: `have` and `show`\n\nThe `have` tactic enables you to structure your proofs by adding intermediate results into the\ncontext. The `show` tactic helps your reader understand what you are proving.\n\n", "`have` is used to introduce a hypothesis into the context. For example,\n`have h : x + y = x + y, from rfl,` introduces the hypothesis `h : x + y = x + y` into the context.\n`have` requires a tactic proof of the claimed result. Here, `from rfl` is a tactic proof of `x + y = x + y`.\n\nMore generally, `have h : \u03b1, T` introduces `h : \u03b1` into the context if `T` is a tactic proof of `\u03b1`.\n", "namespace exlean -- hide\n", "open_locale mynum -- hide\n", "variables (a b c : \u2115) -- hide\n", "In the example below, the first line adds `h : a + b = b + a` into the context. Here,\n`apply add_comm` gives a proof of `a + b = b + a`. The second lines uses this intermediate result\nto close the goal. In this simple example `have` is not necessary as the proof can be done in one\nline with `apply add_comm`.\n", "example : a + b = b + a :=\nbegin\n  have h : a + b = b + a, apply add_comm,\n  from h,\nend\n", "## Translation to a hand-written proof\n\nIn words, the above proof says:\n> We have $h : a + b = b + a$, by additive commutativity.\n> The result follows from $h$.\n", "Changing the last line of the Lean proof above, we indicate what is being proved with the `show` tactic.\n", "`show` is used to state what is being proved. If, for example, the target is to prove `x + y = x + y`,\nyou can indicate and prove this using `show x + y = x + y, from rfl`.\n\nMore generally, if the target is to prove `\u03b1`, you can close the goal using `show \u03b1, T` where `T` is a tactic proof of `\u03b1`.\n", "example : a + b = b + a :=\nbegin\n  have h : a + b = b + a, apply add_comm,\n  show a + b = b + a, from h,\nend\n", "In words, the above proof says:\n> We have $h : a + b = b + a$, by additive commutativity.\n> We show $a + b = b + a$ from $h$.\n", "## Task\nReplace the underscores `_` below with statements and the `sorry` with a proof.\n", "$b + c = c + b$, for all natural numbers $b$ and $c$.\n", "end exlean -- hide\n", "import equations.add_comm -- hide\n", "# Equations\n\n## Level 4: Substitution\n", "namespace exlean -- hide\n", "open_locale mynum -- hide\n", "variables (s t u : \u2115) -- hide\n", "P b\n", "@[elab_as_eliminator]\ndef eq.sub {T} {a b : T} (P : T -> Prop) (h : a = b) (ha : P a) := @eq.rec T a P ha b h\n", "If you know `h\u2081 : a = b` and you know `h\u2082 : P(a)`, where `P(a)` is some statement involving `a`,\nthen you know `P(b)`. This principle is called *substitution*. In Lean, `eq.sub P h\u2081 h\u2082` is a\nproof of `P(b)`.\n\nA statement that depends on a variable (or on zero or more variables) is called a *predicate*. Thus,\n`P` above is a predicate.\n\nWe use the substitution principle to prove $s + (t + u) = s + (u + t)$. Let $P(x)$ be the statement\n$s + (t + u) = s + x$. We have $h_1 : t + u = u + t$, by commutativity of addition.\nWe have $h_2 : P (t + u)$ (that is $s + (t + u) = s + (t + u)$), from reflexivity.\n\nThus, the result (which is $P(u + t)$) follows by substituting $h_1$ into $h_2$.\n\nThis proof is written in Lean as follows.\n", "s + (t + u) = s + (u + t)\n", "theorem add_comm_congr_left : s + (t + u) = s + (u + t) :=\nbegin\n  let P : \u2115 \u2192 Prop := \u03bb x, s + (t + u) = s + x,\n  have h\u2081 : t + u = u + t, apply add_comm,\n  have h\u2082 : P(t + u), from rfl,\n  show P(u + t), from eq.sub P h\u2081 h\u2082,\nend\n", "In the proof below, we don't give $P$ explicitly. By using the underscore `_` as an argument to\n`eq.sub`, we ask Lean to infer the correct predicate `P`.\n", "example : s + (t + u) = s + (u + t) :=\nbegin\n  have h\u2081 : t + u = u + t, from add_comm t u,\n  have h\u2082 : s + (t + u) = s + (t + u), from rfl,\n  show s + (t + u) = s + (u + t) , from eq.sub _ h\u2081 h\u2082,\nend\n", "Finally, we can give a very terse proof of the result.\n", "example : s + (t + u) = s + (u + t) :=\nbegin\n  from eq.sub _ (add_comm t u) rfl,\nend\n", "## Task \n\nComplete the proof below, adapting the proof above. Replace each underscore `_` with a statement\nand each `sorry` with a proof.\n\nHere, `\u2115`, the type of natural numbers, is written `\\N` while `\u03bb` is typed `\\lam`.\n", "If you're struggling to determine the predicate `P`, delete the `let` line, replace `h\u2082 : P(s + t)`\nwith `h\u2082 : (s + t) + u = (s + t) + u`, and replace `eq.sub P h\u2081 h\u2082` with `eq.sub _ h\u2081 h\u2082`.\n", "Avoiding the predicate", "$(s + t) + u = (t + s) + u$, for all natural numbers $s$, $t$, $u$.\n", "end exlean -- hide\n", "import equations.substitution -- hide\n", "# Equations\n\n## Level 5: Substitution 2\n", "namespace exlean -- hide\n", "open_locale mynum -- hide\n", "variables (s t u : \u2115) -- hide\n", "## Task \n\nComplete the proof below. Get hints if needed by clicking on the drop-down menus below.\nIf you want to start with an explicit predicate, the first line should be\n```let P : \u2115 \u2192 Prop := \u03bb x, _,```\nwhere you should replace `_` with a statement depending on `x`.\n", "You can do this with (no more than) two `have`s and an application of substitution.\n", "Structure of the proof", "The result proved in the previous level will come in handy.\n", "A useful result", "$(s + t) + u  = u + (t + s)$, for all natural numbers $s$, $t$, and $u$.\n", "end exlean -- hide\n", "import equations.substitution2 -- hide\n", "# Equations\n\n## Level 6: Congruence of arguments\n", "namespace exlean -- hide\n", "open_locale mynum -- hide\n", "variables (s t u : \u2115) -- hide\n", "f a\u2081 = f a\u2082\n", "Let `f` be a function. Suppose `h : a = b`. Then `congr_arg f h` gives a proof of `f(a) = f (b)`.\nThis is called congruence of arguments.\n\nIn the example below, $f$ is the function from $\\mathbb N$ to $\\mathbb N$ given by $f(x) := 5 x$.\nThe term $h$ is a proof of $t + u = u + t$. Thus, `congr_arg f h` is a proof that\n$5(t + u) = 5(u + t)$.\n", "example : 5 * (t + u) = 5 * (u + t) :=\nbegin\n  let f : \u2115 \u2192 \u2115 := \u03bb x, 5 * x,\n  have h : t + u = u + t, apply add_comm,\n  show 5 * (t + u) = 5 * (u + t), from congr_arg f h,\nend\n", "## Translation to a hand-written proof\n\nThe proof above can be written by hand as follows.\n> Let $f : \\mathbb N \\to \\mathbb N$ be the function $f(x) := 5 x$.\n> We have $h : t + u = u + t$ by commutativity of addition.\n> The result follows by congruence of arguments with $f$ and $h$.\n", "## Task \n\nComplete the proof below, adapting the proof above.\n", "$(s + (t + u))  t = (s + (u + t))  t$, for all natural numbers\n$s$, $t$, $u$.\n", "end exlean -- hide\n", "import equations.congruence -- hide\n", "# Equations\n\n## Level 7: Congruence of arguments - proof\n", "namespace exlean -- hide\n", "## Task \n\nYou've used the `congr_arg` theorem. In this level, you'll *prove* it. Naturally, I've disabled\nthe ordinary `congr_arg` theorem so you can't cheat!\n", "namespace hidden -- hide\n", "variables {\u03b1 : Type*} {\u03b2 : Type*} {a b : \u03b1} -- hide\n", "Let $f$ be a function from a type $\\alpha$ to a type $\\beta$. \nLet $a$ and $b$ be terms of type $\\alpha$ and suppose $h : a = b$.\nThen $f(a) = f(b)$. \n", "end hidden -- hide\n", "end exlean -- hide\n", "import equations.congruence -- hide\n", "# Equations\n\n## Level 8: Associativity\n", "namespace exlean -- hide\n", "open_locale mynum -- hide\n", "Additional of natural numbers satisfy the *associative* property. That is,\nfor all natural numbers $x$, $y$, and $z$, we have $(x + y) + z = x + (y + z)$.\nIn Lean, `add_assoc` is the name of this theorem. Thus, `add_assoc a b c` is a proof that\n`(a + b) + c = a + (b + c)`.\n", "(a + b) + c = a + (b + c)\n", "theorem add_assoc (a b c : \u2115) : (a + b) + c = a + (b + c) := mynat.add_assoc' a b c -- hide\n", "variables (s t u v : \u2115) -- hide\n", "Thus, `add_assoc (s + t) u v` is a proof that $((s + t) + u) + v = (s + t) + (u + v)$.\n", "example : ((s + t) + u) + v = (s + t) + (u + v) :=\nbegin\n  from add_assoc (s + t) u v,\nend\n", "We can let Lean do the chore of determining the arguments to `add_assoc` by using the `apply`\ntactic.\n", "example : ((s + t) + u) + v = (s + t) + (u + v) :=\nbegin\n  apply add_assoc,\nend\n", "variables (a b c : \u2115) -- hide\n", "$a + (b + c) = (a + b) + c$, for all natural numbers $a$, $b$, and $c$.\n", "end exlean -- hide\n", "import equations.associativity -- hide\n", "# Equations\n\n## Level 9: Symmetry\n", "namespace exlean -- hide\n", "open_locale mynum -- hide\n", "The symmetry property of $=$ states that if $a = b$, then $b = a$. In Lean, if $h : a = b$,\nthen `eq.symm h` is a proof that `b = a`. This can also be written `h.symm`.\n", "b = a\n", "Using `eq.symm`, we'll reprove the result from the previous level.\n", "variables (a b c : \u2115) -- hide\n", "example : a + (b + c) = (a + b) + c :=\nbegin\n  have h : (a + b) + c = a + (b + c), apply add_assoc,\n  show a + (b + c) = (a + b) + c, from eq.symm h,\nend\n", "Or, more simply:\n", "example : a + (b + c) = (a + b) + c :=\nbegin\n  from (add_assoc a b c).symm\nend\n", "variables (s t u : \u2115) -- hide\n", "## Task\n\nComplete the proof below, replacing each underscore `_` with a statement and\neach `sorry` with a proof.\n", "$s + (t + u) = (t + s) + u$, for all natural numbers $s$, $t$, and $u$.\n", "end exlean -- hide\n", "import equations.symmetry -- hide\n", "# Equations\n\n## Level 10 : Transitivity\n", "namespace exlean -- hide\n", "open_locale mynum -- hide\n", "Given `h\u2081 : a = b` and `h\u2082 : b = c`, we have `a = c`. This is called *transitivity*. Specifically,\nthe Lean result `eq.trans h\u2081 h\u2082` is a  proof of `a = c`.\n", "a = c\n", "We'll prove a result using `eq.trans` and two other results we've seen.\n", "variables (x y z : \u2115) -- hide\n", "example : (x + y) + z = x + (z + y) :=\nbegin\n  have h\u2081 : (x + y) + z = x + (y + z), apply add_assoc,\n  have h\u2082 : x + (y + z) = x + (z + y), apply add_comm_congr_left,\n  show (x + y) + z = x + (z + y), from eq.trans h\u2081 h\u2082,\nend\n", "## Task\n\nComplete the proof below. You may need to replace `sorry` with two lines. The last\nline should invoke `eq.trans`.\n", "$(x + y) + z = (x + z) + y$, for all natural numbers $x$, $y$, and $z$.\n", "end exlean -- hide\n", "import equations.transitivity -- hide\n", "# Equations\n\n## Level 11 : Proof by calculation\n", "namespace exlean -- hide\n", "open_locale mynum -- hide\n", "If you did the exericse from the previous level, you may have found it overly complicated for\nsuch a simple result. The proof required showing three equations of the form `h\u2081 : a = b`,\n`h\u2082 : b = c`, and `h\u2083 : c = d` and combining them by two applications of transitivity.\n\nThis technique is so common, that we have a special notation for proofs that combine several\nequations via transitivity. First, we present the handwritten version.\n\n**Proof**:\n$$\n\\begin{align}\n(x + y) + z &= x + (y + z) & & \\text{[by associativity of addition]} \\\\\\\\\n&= x + (z + y) & &\\text{[by Theorem add_comm_congr_left]} \\\\\\\\\n&= (x + z) + y. & & \\text{[by associativity of addition (backward)]}\n\\end{align}\n$$\n\nThe same proof can be presented in Lean as follows. Here, I use underscores `_` to ask Lean\nto fill in the missing arguments.\n", "variables (x y z : \u2115) -- hide\n", "example : (x + y) + z = (x + z) + y :=\nbegin\n  calc  \n  (x + y) + z = x + (y + z) : add_assoc _ _ _\n          ... = x + (z + y) : add_comm_congr_left _ _ _\n          ... = (x + z) + y : add_assoc_symm _ _ _,\nend\n", "## Task\n\nComplete the proof below. As usual, you will find it helpful to use the results already proved.\n", "$(x + y) + z = (z + x) + y$, for all natural numbers $x$, $y$, and $z$.\n", "end exlean -- hide\n", "import equations.calculation -- hide\n", "# Equations\n\n## Level 12 : Challenge level\n", "namespace exlean -- hide\n", "open_locale mynum -- hide\n", "Write a proof by calculation (or by any other method) of the result below.\n", "You can do this entirely using `congr_arg`, `add_assoc`, and `add_comm`.\n", "Required results", "Try the following proof template. For the first `sorry`, you'll need `congr_arg`.\n```\ncalc (x + y) + (s + t) = (x + y) + (t + s) : sorry\n... = x + (y + (t + s)) : sorry\n... = (y + (t + s)) + x : sorry,\n```\n", "A proof template", "variables (x y z s t : \u2115) -- hide\n", "$(x + y) + (s + t) = (y + (t + s)) + x$, for all natural numbers $x$, $y$, $s$, and $t$.\n", "end exlean -- hide\n", "import equations.challenge tactic.pure_maths -- hide\n", "# Equations\n\n## Level 13 : Backward proof and the `rw` tactic\n", "namespace exlean -- hide\n", "open_locale mynum -- hide\n", "Let's give a backward proof of $x + (y + z) = (z + y) + x$.\n\n**Proof**:\n$$\n\\begin{align}\n&& x + (y + z) & = (z + y) + x & &  \\\\\\\\\n&\\iff & x + (z + y)& = (z + y) + x & & \\text{[by commutativity of addition on $y$ and $z$]} \\\\\\\\\n&\\iff & (z + y) + x&= (z + y) + x. & & \\text{[by commutativity of addition on $x$ and $z + y$]}\n\\end{align}\n$$\nThe last line follows by reflexivity. \u220e\n", "Here is a Lean proof of this result.\n", "variables (x y z : \u2115) -- hide\n", "example : x + (y + z) = (z + y) + x :=\nbegin [pure_maths]\n  show x + (y + z) = (z + y) + x,   rw add_comm y z,\n  show x + (z + y) = (z + y) + x,   rw add_comm x (z + y),\n  show (z + y) + x = (z + y) + x,   from rfl,\nend\n", "If `h` is an equation of the form `p = q`, `rw h` rewrites replaces `p` in the target with `q`.\n\nIf `k` is in the context, `rw h at k` performs the rewrite at `k` instead of at the target.\n\n`rw \u2190h` will rewrite backward: every occurrence of `q` is replaced with `p`. Type `\\l` to produce `\u2190`.\n\n`rw [h1, h2, h3]` rewrites with multiple hypotheses (you aren't limited to three)!\n", "In this proof, `rw` is short for `rewrite` and the expression `rw add_comm y z` is the Lean\nversion of the handwritten, 'by commutativity of addition on $y$ and $z$'. The only difference\nis that each `rw` appears one line above where it would in a handwritten proof.\n\nIn general, if you use `rw h` where `h : a = b`, then Lean\nwill look for every instance of `a` in the target and replace it with `b`.\n\n\n\n## Task\nThere are many ways to prove a given theorem. Below is a different backward proof of our result.\nConvert this Lean proof into a handwritten proof.\n", "example : x + (y + z) = (z + y) + x :=\nbegin [pure_maths] \n  show x + (y + z) = (z + y) + x,   rw add_comm (z + y) x,\n  show x + (y + z) = x + (z + y),   rw add_comm y z,\n  show x + (z + y) = x + (z + y),   from rfl,\nend\n", "The use of `show` isn't required by Lean. Moreover, multiple applications of `rw` can\nbe combined on one line, as shown below. However, this translates poorly to handwritten proofs.\n", "example : x + (y + z) = (z + y) + x:=\nbegin [pure_maths]\n  rw [add_comm y z, add_comm], from rfl,\nend\n", "\n", "## Task \nGiven a backward of the theorem `add_right_comm` that you first encounterd in the transitivity level.\nI've provided you with a suggested first line.\n\nThe old `add_right_comm` result is unavailable for use in your proof!\n", "namespace hidden -- hide\n", "$(x + y) + z = (x + z) + y$, for all natural numbers $x$, $y$, and $z$.\n", "end hidden -- hide\n", "end exlean -- hide\n", "import equations.challenge tactic.pure_maths -- hide\n", "# Equations\n\n## Level 14 : Easy calculation proofs using `rw`\n", "namespace exlean -- hide\n", "open_locale mynum -- hide\n", "The idea of 'replacing equals with equals' can lead to simpler proofs. Using this idea,\nwe present a proof of the result from the challenge level.\n", "variables (x y z s t: \u2115) -- hide\n", "example : (x + y) + (s + t) = (y + (t + s)) + x :=\nbegin\n  calc\n  (x + y) + (s + t) = (x + y) + (t + s) : by rw add_comm s t\n                ... = x + (y + (t + s)) : by rw add_assoc\n                ... = (y + (t + s)) + x : by rw add_comm,\nend\n", "In each line of justification above, the word `by` announces that we are to provide Lean with a \ntactic proof.\n\nThus, `rw add_comm s t` is a tactic proof of `(x + y) + (s + t) = (x + y) + (t + s)`.\n", "## Task\n\nComplete the proof below. To do this, replace the `_` with an expression, add extra lines of calculation,\nand replace the `sorry` with a final justification.\n", "If you try `add_comm` (or `add_assoc`) and Lean doesn't do what you expect, you may need\nto be more precise about what you want to add `add_comm` to.\n\nFor example, to justify the line `a + (b + c) = a + (c + b)` requires `rw add_comm b c`\n(or `rw add_comm b`). The problem is that `rw add_comm` by itself transforms \n`a + (b + c)` into `(b + c) + a`.\n", "Problems with applying `add_assoc` or `add_comm`?", "$x + ((y + z) + z) = ((z + z) + x) + y$, for all natural numbers $x$, $y$, and $z$.\n", "end exlean -- hide\n", "import equations.rewrite_calc-- hide\n", "# Equations\n\n## Level 15 : The simplifier\n", "namespace exlean -- hide\n", "open_locale mynum -- hide\n", "This level introduces a powerful new tactic, `simp`, Lean's simplifier. It rewrites \nrepeatedly using either supplied theorems & hypotheses or theorems that it 'knows'.\n\nTo suggest theorems and hypotheses for use with `simp`, provide them as a comma-separated list.\nIn the example below, we supply `simp` with `add_assoc` and `add_comm y x`.\n\nWithout `simp`, you'd need several applications of `rw add_assoc`. \n", "example (x y z : \u2115) : x + ((y + z) + x) = (y + x) + (z + x) :=\nbegin\n  simp [add_assoc, add_comm y x],\nend\n", "## Tasks\n\n* Prove the result below using only `simp` with supplied theorems, as in the example above. You should\nonly need to supply two theorems.\n\n* For fun (!) try proving this result using `rw`. Which proof do you prefer?\n", "Let `x`, `y`, and `z` be natural numbers. Then `(y + x) + (0 + z + 0) + (0 + x + 0) = y + (z + (x + x))`.\n", "The `simp` tactic rewrites repeatedly using either supplied theorems & hypotheses or theorems\nthat it 'knows'.\n\nTo suggest theorems and hypotheses for use with `simp`, provide them as a comma-separated list.\nFor example `simp [h, add_comm]` rewrites repeatedly with hypotheses `h` and theorem `add_comm`.\n", "end exlean -- hide\n", "Natural numbers", "import mynat.basic tactic.pure_maths -- hide\n", "set_option pp.structure_projections false -- hide\n", "namespace exlean -- hide\n", "open_locale mynum -- hide\n", "open mynat -- hide\n", "# Natural numbers\n\n## Level 1: A boolen evenness function\n\nIn this world, a natural number is either `O` (the capital letter `O`) or\n`S(k)`, where `k` is a natural number. The successor function `S` can be thought of\nas 'returning' the number `S(k)` that comes after `k`.\n\nThe number we call $2$ can be written with this definition as `S(S(O))` or `S(S O)`.\n", "example : \u2115 := O \nexample : \u2115 := S O \nexample : \u2115 := S(S(O))\nexample : \u2115 := S(S(S O))\n", "\nTo define a function on `\u2115` is to give its value at `O` and to specify how its\nvalue at `S(k)` depends on its value at `k`.\n\nWe define a function `evenb` such that `evenb(n)` is `tt` (true) if `n` is even and is\n`ff` (false) otherwise. In the following recursive definition of `evenb`, the symbol `!`\nrepresents the Boolean 'not' function, defined so that `!(tt) := ff` and `!(ff) := tt`.\n", "def evenb : \u2115 \u2192 bool\n| O     := tt\n| (S k) := !(evenb k)\n", "By definition of `evenb`, we extract two lemmas. The first, `evenb_O`, asserts\n`evenbO = tt`. The second, `evenb_S`, asserts that `evenb(S(n)) = !(evenb(n))`.\n", "evenb(O) = tt\n", "lemma evenb_O : evenb O = tt := rfl\n", "evenb (S(n)) = !(evenb n)\n", "lemma evenb_S (n : \u2115) : evenb (S n) = !(evenb n) := rfl\n", "Using these two lemmas, we give a proof by calculation that 3 is not even. More precisely,\nthat `evenb(S(S(S(O)))) = ff`.\n", "example : evenb(S(S(S(O)))) = ff :=\nbegin\n  calc\n  evenb(S(S(S(O)))) = !evenb((S(S(O)))) : by rw evenb_S\n                ... = !!evenb(S O)      : by rw evenb_S\n                ... = !!!evenb(O)       : by rw evenb_S\n                ... = !!!tt             : by rw evenb_O\n                ... = ff                : rfl,\nend\n", "In fact, as each step of the proof above involves an application of a definition, the\nresult holds by reflexivity.\n", "example : evenb(S(S(S(O)))) = ff :=\nbegin\n  from rfl,\nend\n", "## Task\n\nComplete the proof by calculation that 2 is even. You'll need\nadditional lines of calculation.\n\nOnce you've done this, check that `from rfl,` suffices\nas a one-line proof.\n", "That $2$ is even has value 'true'.\n", "end exlean -- hide", "import natural_numbers.evenb -- hide\n", "set_option pp.structure_projections false -- hide\n", "namespace exlean -- hide\n", "open_locale mynum -- hide\n", "open mynat -- hide\n", "# Natural numbers\n\n## Level 2: The definition of addition\n\nOur addition function is defined so that for every natural number `m`, we have\n`m + O = m` and `m + (S n) = S(m + n)`, for every natural number `n`.\n\nThese definitions are available as the theorems `add_O` and `add_S`:\n\n`add_O (m : \u2115) : m + O = m`\n\n`add_S (m n : \u2115) : m + (S n) = S(m + n)`\n", "n + O = n\n", "m + (S n) = S(m + n)\n", "Using these two lemmas, we give a proof by calculation that `(S O) + (S O) = S(S(O))`,\nthat is, that $1 + 1 = 2$.\n", "example : (S O) + (S O) = S(S(O)) :=\nbegin\n  calc\n  (S O) + (S O) = S((S O) + O)  : by rw add_S\n            ... = S(S(O))       : by rw add_O\nend\n", "As in the previous level, both sides are *definitionally* equal to `S(S(O))`, thus\nthe result could, more easily, be proved by reflexivity.\n", "example : (S O) + (S O) = S(S(O)) :=\nbegin\n  from rfl,\nend\n", "As another example, we prove that `S(n) = n + (S O)`, effectively that\n$\\mathsf{S}(n) = n + 1$.\n", "S n = n + (S O)\n", "lemma S_eq_add_one (n : \u2115) : S n = n + (S O) :=\nbegin [pure_maths]\n  show S n = n + (S O), rw add_S,\n  show S n = S(n + O),  rw add_O,\n  show S n = S n, from rfl,\nend\n", "## Task\n\nComplete the proof by calculation that $1 + 2 = 3$. You'll need\nadditional lines of calculation.\n\nOnce you've done this, check that `from rfl,` suffices\nas a one-line proof.\n", "$1 + 2 = 3$.\n", "end exlean -- hide", "import natural_numbers.addition -- hide\n", "set_option pp.structure_projections false -- hide\n", "namespace exlean -- hide\n", "open_locale mynum -- hide\n", "open mynat -- hide\n", "# Natural numbers\n\n## Level 3: Induction and `S_eq_one_add`\n\nLet $P$ be a predicate on $\\mathbb N$. To prove that $P(n)$ holds for every natural number $n$\nis to:\n1. [base case] prove $P(\\mathsf{O})$ and\n2. [inductive step] prove that for every $k : \\mathbb N$, $P(\\mathsf S(k))$ follows from the *induction hypothesis*,\nthe assumption of $P(k)$.\n\nThis is called *proof by induction*.\n", "Via proof by induction, one may prove $\\mathsf O + n = n$, for every $n : \\mathbb N$. Here, the\npredicate $P$ is given by $P(n) := \\mathsf O + n = n$.\n\n**Proof**:\n1. [Base case] We must show $P(\\mathsf O)$. That is, $\\mathsf O + \\mathsf O = \\mathsf O$. This follows by definition of\naddition.\n\n2. [Inductive step] Let $k$ be a natural number. Assume the induction hypothesis $h : P(k)$, which is\n$\\mathsf O + k = k$. We must show $P(\\mathsf S(k))$, i.e. $\\mathsf O + \\mathsf S(k) = \\mathsf S(k)$.\nBut\n$$\n\\begin{align}\n\\mathsf O + \\mathsf S(k) & = \\mathsf S(\\mathsf O + k) && \\text{[by definition of addition]} \\\\\\\\\n&= \\mathsf S(k). & & \\text{[by  $h$]}\n\\end{align}\n$$\n\nThe result follows by induction. \u220e \n", "The same result is proved in Lean below. Here, `induction n` marks the start of the proof. The base case is\nindicated with `case O` and the inductive step with `case S`.\n\nThe base case is the proof of `P(O)`. That is, the proof of `O + O = O`. This holds by\ndefinition of addition, and hence by reflexivity.\n\nIn the inductive step, the quantities `k` and `h` in `case S : k h` are the induction variable\nand induction hypothesis, respectively. We must show `P(S(k))`, i.e. `O + S(k) = S(k)`,\ngiven the induction hypothesis: the assumption of `P(k)`, i.e.\nof `O + k = k`.\n", "To prove `P(n)` holds for all `n : \u2115`, use the `induction n`. This opens up two new goals:\n(1) to prove `P(O)` and (2) to prove `P(S(k))` on the assumption of `P(k)`.\n\nTo specify the names of the induction variable (say `k`) and induction hypothesis (say `h`)\nyou can either use the form `induction with k h` or you can tag the induction step with\n`case S : k h`.\n", "O + n = n\n", "@[simp] lemma O_add (n : \u2115) : O + n = n :=\nbegin\n  induction n,\n", "  -- hide\n", "  case O :\n  { show O + O = O, from rfl, },\n", "  -- hide\n", "  case S : k h\n  { show O + S(k) = S(k),\n    given h : O + k = k,\n    calc\n    O + S(k)  = S(O + k)  : by rw add_S\n          ... = S(k)      : by rw h, },\nend\n", "As an aside, note that I've tagged the theorem above with `@[simp]`. This\nmeans that the `simp` tactic will automatically call on `O_add` whenever applicable, as in\nthe proof below.\n", "example (n : \u2115) : (O + (O + n)) + O  = n :=\nbegin\n  simp,\nend\n", "## Task\n\nComplete the following proof by induction, following the template given by the proof of `O_add`\nabove. Note you have to separately proof the base case and the inductive step.\n", "If you're not sure how to start, begin with the following template. The `sorry` in the inductive\nstep can be filled in with a proof by calculation, as above.\n```\ninduction n,\n\ncase O :\n{ show S(O) = S(O) + O, sorry, },\n\ncase S : k h\n{ show S(S(k)) = S(O) + S(k),\n  given h : S(k) = S(O) + k,\n  sorry, },\n```\n\n", "A proof template", "For every natural number $n$, we have $\\mathsf S(n) = \\mathsf S(\\mathsf O) + n$. That is,\n$\\mathsf S(n) = 1 + n$.\n", "end exlean -- hide", "import natural_numbers.S_eq_one_add -- hide\n", "set_option pp.structure_projections false -- hide\n", "namespace exlean -- hide\n", "open_locale mynum -- hide\n", "open mynat -- hide\n", "# Natural numbers\n\n## Level 4: `S_add`\n\nIn this level, you'll prove a result that depends on two variables $m$ and $n$ by fixing $m$\nand performing induction on $n$.\n\n## Task\n\nComplete the following proof by induction.\n", "If you're not sure how to start, begin with the following template. The `sorry` in the inductive\nstep can be filled in with a proof by calculation, as above.\n```\ninduction n,\n\ncase O :\n{ show S m + O = S(m + O), sorry, },\n\ncase S : k h\n{ show S(m) + S(k) = S(m + S(k)),\n  given h : S(m) + k = S(m + k),\n  sorry, },\n```\n", "A proof template", "If you used the proof template above, the goal of the inductive step is\n```\n m k : \u2115,\n h : S m + k = S (m + k)\n \u22a2 S m + S k = S (m + S k)\n```\nTo help you understand proof by induction, I recommend using a proof by calculation here.\nHowever, Lean can partially automate the construction of a proof using the `simp` tactic. Here,\n`simp [add_S, h]` proves the inductive step. It tells Lean to use `add_S` and the inductive\nhypothesis `h` (and any other lemma marked with the `simp` attribute) as many times as necesary\nand in whatever order until a proof is found or no further simplification is possible.\n", "A cheap proof using `simp`", "For all natural numbers $m$ and $n$, we have $\\mathsf S(m) + n = \\mathsf S(m + n)$.\n", "end exlean -- hide", "import natural_numbers.S_add -- hide\n", "set_option pp.structure_projections false -- hide\n", "namespace exlean -- hide\n", "open_locale mynum -- hide\n", "open mynat -- hide\n", "# Natural numbers\n\n## Level 5: Doubling\n\nThe function `double` from `\u2115` to `\u2115` is defined so that `double(O) := O` and\n`double(S(k)) = S(S(double(k)))`. It corresponds to the ordinary notion of doubling a natural\nnumber.\n", "def double : \u2115 \u2192 \u2115\n| O     := O\n| (S k) := S (S (double k))\n", "The definition equations of `double` give two results, by reflexivity.\n", "double(O) = O\n", "lemma double_O : double(O) = O := rfl\n", "double(S(n)) = S(S(double(n)))\n", "lemma double_S (n : \u2115) : double(S(n)) = S(S(double(n))) := rfl\n", "## Task\n\nComplete the following proof by induction. Use the results `double_O` and `double_S` above\ntogether with any relevant results from previous levels in this world.\n", "For every natural number $n$, we have $\\mathsf{double}(n) = n + n$.\n", "end exlean -- hide", "import natural_numbers.double_eq_add_self -- hide\n", "set_option pp.structure_projections false -- hide\n", "namespace exlean -- hide\n", "open_locale mynum -- hide\n", "open mynat -- hide\n", "# Natural numbers\n\n## Level 6: Commutativity of addition\n", "## Task\n\nLet $m$ be a natural number. By induction on $n$, prove that $m + n = n + m$\nfor all natural numbers $n$.\n", "This is the first level where the base case cannot be proved by reflexivity. Previously proved\nresults will come in handy here. See the 'Theorem statements' side bar on the left for inspiration.\n", "Proving the base case", "For all natural numbers $m$ and $n$, we have $m + n = n + m$.\n", "end exlean -- hide", "import natural_numbers.add_comm -- hide\n", "set_option pp.structure_projections false -- hide\n", "namespace exlean -- hide\n", "open_locale mynum -- hide\n", "open mynat -- hide\n", "# Natural numbers\n\n## Level 7: Associativity of addition\n", "## Task\n\nLet $x$ and $y$ be a natural numbers. By induction on $z$, prove that $(x + y) + z = x + (y + z)$\nfor all natural numbers $z$.\n", "For all natural numbers $x$, $y$, and $z$, we have $(x + y) + z = x + (y + z)$.\n", "end exlean -- hide", "import natural_numbers.add_assoc algebra.group.defs -- hide\n", "set_option pp.structure_projections false -- hide\n", "namespace exlean -- hide\n", "open_locale mynum -- hide\n", "open mynat -- hide\n", "# Natural numbers\n\n## Level 8: Easy addition with `ac_refl`\n", "If you were asked to prove $(a + b) + (c + (b + a)) = (c + (b + b)) + (a + a)$ for all natural \nnumbers $a$, $b$, and $c$, you might say that the statement is clearly true, by rearranging.\n\nIf you were required to prove this step-by-step using the laws of commutativity and associativity\nof addition, it would be a pain.\n\nFortunately, Lean comes with a clever tactic called `ac_refl` that can creates proofs of any\nresult that can be justified solely by associativity, commutativity, and reflexivity.\n\nSince we've shown `+` is associative and commutative, we may use `ac_refl`.\n", "instance : add_comm_monoid mynat :=\n{ add_assoc := add_assoc,\n  add_comm := add_comm,\n  zero_add := O_add,\n  add_zero := add_O,\n  .. }\n", "variables (a b c v i o l e t : \u2115) -- hide\n", "example : (a + b) + (c + (b + a)) = (c + (b + b)) + (a + a) :=\nbegin\n  ac_refl,\nend\n", "This tactic closes any goal that can be proved only by associativity, commutativity, and\nreflexivity.\n", "## Task\n\nUse `ac_refl` to prove the following.\n", "$(v + (i + o)) + (l + (e + t)) = ((l + o) + (v + e)) + (i + t)$.\n", "end exlean -- hide", "import natural_numbers.easy_addition -- hide\n", "set_option pp.structure_projections false -- hide\n", "namespace exlean -- hide\n", "open_locale mynum -- hide\n", "open mynat -- hide\n", "# Natural numbers\n\n## Level 9: Multiplication and `mul_two`\n\nThe multiplication function is defined so that for every natural number `m`, we have\n`m * O = O` and `m * (S n) = m * n + m`, for every natural number `n`.\n\nThese definitions are available as the theorems `mul_O` and `mul_S`:\n\n`mul_O (m : \u2115) : m * O = O`\n\n`mul_S (m n : \u2115) : m * (S n) = m * n + m`\n", "n * O = O\n", "m * (S n) = m * n + m\n", "Using these 'definitional' results, we'll prove $n \\times 1 = n$.\n", "n * S(O) = n\n", "@[simp] lemma mul_one (n : \u2115) : n * S(O) = n :=\nbegin\n  calc\n  n * S(O)  = n * O + n : by rw mul_S\n        ... = O + n     : by rw mul_O\n        ... = n         : by rw O_add,\nend\n", "## Task\n\nProve that $n \\times \\mathsf S(\\mathsf S(\\mathsf O)) = n + n$, for every natural number $n$.\nYou *do not* require induction for this proof. Give a proof by calculation using previously\nproved results.\n\nTo complete the proof, replace the `_` with an expression, add extra lines of calculation,\nand replace the `sorry` with a final justification.\n", "For every natural number $n$, we have $n \\times 2 = n + n$.\n", "end exlean -- hide", "import natural_numbers.mul_two -- hide\n", "set_option pp.structure_projections false -- hide\n", "namespace exlean -- hide\n", "open_locale mynum -- hide\n", "open mynat -- hide\n", "# Natural numbers\n\n## Level 10: Multiply by O on the left\n", "## Task\n\nBy induction on $n$, prove that $\\mathsf O \\times n = \\mathsf O$,\nfor every natural number $n$.\n", "For every natural number $n$, we have $\\mathsf O \\times n = \\mathsf O$.\n", "attribute [simp] O_mul -- hide\n", "end exlean -- hide", "import natural_numbers.zero_mul -- hide\n", "set_option pp.structure_projections false -- hide\n", "namespace exlean -- hide\n", "open_locale mynum -- hide\n", "open mynat -- hide\n", "# Natural numbers\n\n## Level 11: Left distributivity of multiplication\n", "## Task\n\nLet $x$ and $y$ be natural numbers. By induction on $z$, prove that\n$x(y + z) = x y + xz$, for every natural number $z$.\n", "For all natural numbers $x$, $y$, and $z$, we have $x(y + z) = xy + xz$.\n", "end exlean -- hide", "import natural_numbers.mul_add -- hide\n", "set_option pp.structure_projections false -- hide\n", "namespace exlean -- hide\n", "open_locale mynum -- hide\n", "open mynat -- hide\n", "# Natural numbers\n\n## Level 12: Associativity of multiplication\n", "## Task\n\nLet $x$ and $y$ be natural numbers. By induction on $z$, prove that\n$(xy)z = x(yz)$, for every natural number $z$.\n", "At some point in your proof, it will be helpful to use `mul_add`, the\nleft distributivity of multiplication result.\n", "A helpful result", "For all natural numbers $x$, $y$, and $z$, we have $(xy)z = x(yz)$.\n", "end exlean -- hide", "import natural_numbers.mul_assoc -- hide\n", "set_option pp.structure_projections false -- hide\n", "namespace exlean -- hide\n", "open_locale mynum -- hide\n", "open mynat -- hide\n", "# Natural numbers\n\n## Level 13: `S_mul`\n", "## Task\n\nLet $m$ be a natural number. By induction on $n$, prove that\n$\\mathsf S(m) n = mn + n$, for every natural number $n$.\n\nThis is the hardest induction so far.\n", "At some point in your proof of the inductive step, it will be\nhelpful to use `mul_S`, `add_S`, `add_assoc`, and `add_comm`.\n", "Helpful results", "For all natural numbers $m$ and $n$, we have $\\mathsf S(m) n = mn + n$.\n", "end exlean -- hide", "import natural_numbers.S_mul -- hide\n", "set_option pp.structure_projections false -- hide\n", "namespace exlean -- hide\n", "open_locale mynum -- hide\n", "open mynat -- hide\n", "# Natural numbers\n\n## Level 14: Commutativity of multiplication\n", "## Task\n\nLet $m$ be a natural number. By induction on $n$, prove that\n$mn = nm$, for every natural number $n$.\n\nYou've done all the hard work in the previous level, `S_mul`.\n", "For all natural numbers $m$ and $n$, we have $mn = nm$.\n", "end exlean -- hide", "import natural_numbers.mul_comm tactic.ring -- hide\n", "set_option pp.structure_projections false -- hide\n", "namespace exlean -- hide\n", "open_locale mynum -- hide\n", "open mynat -- hide\n", "# Natural numbers\n\n## Level 15: Easy arithmetic\n\nWe've proved a significant set of theorems about natural number arithmetic. We know addition\nand multiplication are associative and commutative. We know that multiplication is distributive.\nWe know special facts about adding and multiplying by zero and multiplying by one.\n\nPut together, these facts mean that `\u2115` is something called a 'commutative semiring'. You don't\nneed to know what that means for the moment. What's important is that Lean has powerful tactics\nfor proving results in commutative semirings.\n", "S(O) * m = m\n", "@[simp] lemma one_mul (n : \u2115) : S(O) * n = n := by rw [mul_comm, mul_one]\ninstance : comm_monoid mynat :=\n{ mul_assoc := mul_assoc,\n  mul_comm := mul_comm,\n  one_mul := one_mul,\n  mul_one := mul_one,\n  .. }\ninstance : has_coe nat mynat := \u27e8\u03bb n, nat.rec_on n O (\u03bb a b, S b)\u27e9\nlemma coe_succ (n : nat) : \u2191(nat.succ n) = S n := rfl\nlemma nsmul_succ' (n : nat) (x : mynat) : \u2191(n.succ) * x = x + \u2191n * x :=\nby rw [coe_succ, S_mul, add_comm]\nlemma add_mul (a b c : \u2115) : (a + b) * c = a * c + b * c :=\nby rw [mul_comm, mul_add, mul_comm c, mul_comm c]\ninstance : comm_semiring mynat :=\n{ nsmul := \u03bb m n, m * n,\n  nsmul_zero' := O_mul,\n  nsmul_succ' := nsmul_succ',\n  left_distrib := mul_add,\n  right_distrib := add_mul,\n  zero_mul := O_mul,\n  mul_zero := mul_O,\n  ..mynat.add_comm_monoid, ..mynat.comm_monoid, .. }\n", "For example, the `ring` tactic can prove $(a + b)^2 = a^2 + 2ab + b^2$.\n", "example (a b c : \u2115) :\n(a + b) ^ 2 = a ^ 2 + 2 * a * b + b ^ 2 :=\nbegin\n  ring,\nend\n", "To make things interesting, we can pose the proof above as a question. Find $x$ such that\n$(a + b)^2 = a^2 + xab + b^2$, for all $a$ and $b$.\n\nThe answer is $2$ (of course!). You tell Lean to use $2$ by typing `use 2`. Then `ring`\nfinishes the proof.\n", "Proves equations in commutative semirings (such as \u2115).\n", "example (a b c : \u2115) : \u2203 (x : \u2115),\n(a + b) ^ 2 = a ^ 2 + x * a * b + b ^ 2 :=\nbegin\n  use 2,\n  ring,\nend\n", "## Task\n\nAdapting the proof above, prove the following result by finding $x$ such that\n$(a + 2b)(2a + b) = 2a ^ 2 + xab + 2b^2$.\n", "There exists a natural number $x$ such that $(a + 2b)(2a + b) = 2a ^ 2 + xab + 2b^2$, for all\nnatural numbers $a$ and $b$.\n", "end exlean -- hide", "import natural_numbers.easy_multiplication -- hide\n", "set_option pp.structure_projections false -- hide\n", "namespace exlean -- hide\n", "open_locale mynum -- hide\n", "open mynat -- hide\n", "# Natural numbers\n\n## Level 16: Exponentiation. Raising to the first power\n", "Let $m$ be a natural number. We'll define raising $m$ to the (natural number) power $n$\nrecursively on $n$ so that $m^{\\mathsf O} := 1$ and $m^{\\mathsf S(n)} := (m ^ n) \\times m$.\n\nIn Lean, we write `m ^ n` for $m ^ n$. The defining equations of exponentiation are represented\nby the following theorems.\n\n`pow_O (n : \u2115) : n ^ O = S(O)`\n\n`pow_S (m n : \u2115) : m ^ S(n) = (m ^ n) * m`\n", "n ^ O = S(O)\n", "m ^ S(n) = (m ^ n) * m\n", "## Task\n\nProve that $m ^ 1 = m$, for every natural number $m$. You *don't* need\ninduction.\n", "For all natural numbers $m$ and $n$, we have $mn = nm$.\n", "end exlean -- hide", "import natural_numbers.pow_one -- hide\n", "set_option pp.structure_projections false -- hide\n", "namespace exlean -- hide\n", "open_locale mynum -- hide\n", "open mynat -- hide\n", "# Natural numbers\n\n## Level 17: Powers of 1\n\n## Task\n\nProve that $1 ^ m = 1$, for every natural number $m$.\n", "$1 ^ m = 1$, for every natural number $m$.\n", "end exlean -- hide", "import natural_numbers.one_pow -- hide\n", "set_option pp.structure_projections false -- hide\n", "namespace exlean -- hide\n", "open_locale mynum -- hide\n", "open mynat -- hide\n", "# Natural numbers\n\n## Level 18: Raising to a power $a + b$\n\n## Task\n\nLet $m$ and $a$ be natural numbers. Prove, by induction on $b$,\nthat $m ^ {a + b} = m ^ a m ^ b$, for all natural numbers $b$.\n", "For all natural numbers $m$, $a$, and $b$, we have $m ^ {a + b} = m ^ a m ^ b$.\n", "end exlean -- hide", "import natural_numbers.pow_add -- hide\n", "set_option pp.structure_projections false -- hide\n", "namespace exlean -- hide\n", "open_locale mynum -- hide\n", "open mynat -- hide\n", "# Natural numbers\n\n## Level 19: Raising to a power $ab$\n\n## Task\n\nLet $m$ and $a$ be natural numbers. Prove, by induction on $b$,\nthat $m ^ {a b} = (m ^ a) ^ b$, for all natural numbers $b$.\n", "For all natural numbers $m$, $a$, and $b$, we have $m ^ {a b} = (m ^ a) ^ b$.\n", "end exlean -- hide", "import natural_numbers.pow_mul -- hide\n", "set_option pp.structure_projections false -- hide\n", "namespace exlean -- hide\n", "open_locale mynum -- hide\n", "open mynat -- hide\n", "# Natural numbers\n\n## Level 20: Powers of products\n\n## Task\n\nLet $a$ and $b$ be natural numbers. Prove that $(ab)^m = (a^m)(b^m)$,\nfor every natural number $m$.\n", "At some point in the proof, you may find it helpful to use the `ac_refl` tactic \nor the `ring` tactic to easily show\na result that depends on commutativity and associativity of multiplication.\n", "A time-saving tactic", "For all natural numbers $a$, $b$, and $m$, we have $(ab)^m = (a^m)(b^m)$.\n", "end exlean -- hide", "import natural_numbers.mul_pow -- hide\n", "set_option pp.structure_projections false -- hide\n", "namespace exlean -- hide\n", "open_locale mynum -- hide\n", "open mynat -- hide\n", "# Natural numbers\n\n## Level 21: Finite sums\n\nIn mathematics, the 'sigma' notation is used to represent sums. We may write\n$$\n\\sum_{i=0}^{10} i\n$$\nto represent the sum $0 + 1 + \\dots + 9 + 10$. Henceforth, as all our numbers are non-negative,\nwe'll omit the lower summation bound $0$.\n\nIn this book, we represent the same quantity as\n`\u2211 i \u227c 10, i`. Here, `\u2211` is typed `\\sum`, and `\u227c` is typed `\\preceq`.\n\nLikewise, the sum $\\sum_{i < 10} i$ is represented as `\u2211 i \u227a 10, i`, where `\u227a` is typed `\\prec`.\n\nFor example, one can prove (by reflexivity), that\n$$\\sum_{i \\le 4} i ^ 2 = 30.$$\n", "open_locale fsum -- hide\n", "example : \u2211 i \u227c 4, i ^ 2 = 30 :=\nbegin\n  from rfl,\nend\n", "More generally, one can consider $\\sum_{i < n} f(i)$, for some function $f$. We'll define this by\ntwo principles: (1) $\\sum_{i < 0} f(i) := 0$ and (2)\n$\\sum_{i < \\mathsf S(n)} f(i) := \\sum_{i < n} f(i) + f(n)$.\n\nNote (2) may also be written as $\\sum_{i \\le n} f(i) := \\sum_{i < n} f(i) + f(n)$.\n", "These definitions are available as the theorems `fsum_O` and `fsum_S`:\n\n`fsum_O (f : \u2115 \u2192 \u2115) : \u2211 i \u227a O, f(i) = O`\n\n`fsum_S (f : \u2115 \u2192 \u2115) (n : \u2115) : \u2211 i \u227c n, f(i) = \u2211 i \u227a n, f(i) + f(n)`\n", "\u2211 i \u227a O, f(i) = O\n", "\u2211 i \u227c n, f(i) = \u2211 i \u227a n, f(i) + f(n)\n", "Using these theorems, we can prove $\\sum_{i < n} 0 = 0$, for all natural numbers $n$.\n", "\u2211 i \u227a n, 0 = 0\n", "lemma fsum_zero (n : \u2115) : \u2211 i \u227a n, 0 = 0 :=\nbegin [pure_maths]\n  induction n,\n  case O :\n  { show \u2211 i \u227a 0, 0 = 0, from rfl, },\n  case S : k h\n  { show \u2211 i \u227c k, 0 = 0,\n    given h : \u2211 i \u227a k, 0 = 0,\n    calc\n    \u2211 i \u227c k, 0  = \u2211 i \u227a k, 0 + 0 : by rw fsum_S\n            ... = 0 + 0           : by rw h\n            ... = 0               : rfl, },\nend\n", "\n## Task\n\nLet $c : \\mathbb N$ be a constant.\nBy induction on $n$, prove that $\\sum_{i < n} c = cn$, for every natural number $n$.\n", "$\\sum_{i < n} c = cn$, for all natural numbers $c$ and $n$.\n", "attribute [simp] fsum_const -- hide\n", "end exlean -- hide", "import natural_numbers.finite_sum -- hide\n", "set_option pp.structure_projections false -- hide\n", "namespace exlean -- hide\n", "open_locale mynum -- hide\n", "open mynat -- hide\n", "# Natural numbers\n\n## Level 22: Triangular numbers\n", "open_locale fsum -- hide\n", "\n## Task\n\nProve the formula for triangular numbers, that\n$$\n2\\left(\\sum_{i \\le n} i\\right) = n(n + 1),\n$$\nfor every natural number $n$.\n", "Remember that the `ring` tactic can prove most equations.\n", "Cheap algebra", "The equation `S(k) = k + 1` holds from `rfl`. Use this before\napplying the `ring` tactic.\n", "Converting from `S(k)` to `k + 1`", "If you're not sure how to get going, try the following proof template.\nFill in the `_` with an expression, add extra calculation lines and\ncomplete the final `sorry`.\n```\ninduction n,\n\ncase O :\n{ from rfl, },\n\ncase S : k h\n{ show 2 * (\u2211 i \u227c S(k), i) = S(k) * (S(k) + 1),\n  given h : 2 * (\u2211 i \u227c k, i) = k * (k + 1),\n  calc\n  2 * (\u2211 i \u227c S(k), i)\n      = 2 * (\u2211 i \u227c k, i + S(k))        : by rw fsum_S\n  ... = (k + 1) * ((k + 1) + 1)        : sorry, }\n```\n\n", "A proof template", "$2(\\sum_{i \\le n} i) = n(n + 1)$, for every natural number $n$.\n", "end exlean -- hide", "import natural_numbers.triangle_numbers -- hide\n", "set_option pp.structure_projections false -- hide\n", "namespace exlean -- hide\n", "open_locale mynum -- hide\n", "open mynat -- hide\n", "# Natural numbers\n\n## Level 23: Sums of squares\n", "open_locale fsum -- hide\n", "\n## Task\n\nProve the formula for sums of squares, that\n$$\n6\\left(\\sum_{i \\le n} i^2\\right) = n(n + 1)(2n + 1),\n$$\nfor every natural number $n$.\n", "$6(\\sum_{i \\le n} i^2) = n(n + 1)(2n + 1)$, for every natural number $n$.\n", "end exlean -- hide", "import natural_numbers.sums_of_squares -- hide\n", "set_option pp.structure_projections false -- hide\n", "namespace exlean -- hide\n", "open_locale mynum -- hide\n", "open mynat -- hide\n", "# Natural numbers\n\n## Level 24: Change of index in a sum\n", "open_locale fsum -- hide\n", "By *definition*, we have\n$$\n\\sum_{i \\le n} f(i) = \\left(\\sum_{i < n} f(i)\\right) + f(n),\n$$\ncorresponding to the intuition\n$$\nf(0) + f(1) + \\dots + f(n) = (f(0) + \\dots + f(n-1)) + f(n).\n$$\nOne should expect also that\n$$\nf(0) + f(1) + \\dots + f(n)  = f(0) + (f(1) \\dots  + f(n)),\n$$\nwhich can be written as\n$$\n\\sum_{i \\le n} f(i) = \\sum_{i < n} f(i + 1) + f(0).\n$$\n\n\n\n", "\n## Task\n\nProve the claim above.\n", "At some point, you'll need to use a result of the form $(a + b) + c = (a + c) + b$.\nYou've proved a result that states exactly this earlier. Either use this theorem or use\none of the `ac_refl` or `ring` tactics.\n", "A helpful result", "For any function $f : \\mathbb N \\to \\mathbb N$, we have \n$\\sum_{i \\le n} f(i) = \\sum_{i < n} f(i + 1) + f(0)$,\nfor every natural number $n$.\n", "end exlean -- hide", "import natural_numbers.fsum_S_prime -- hide\n", "set_option pp.structure_projections false -- hide\n", "namespace exlean -- hide\n", "open_locale mynum -- hide\n", "open mynat -- hide\n", "# Natural numbers\n\n## Level 25: Multiplying each term by a constant\n", "open_locale fsum -- hide\n", "\n## Task\n\nFor any function $f : \\mathbb N \\to \\mathbb N$, for all natural numbers $x$ and $n$,\nprove that \n$$\nx\\sum_{i \\le n} f(i) = \\sum_{i < n} x f(i).\n$$\n", "For any function $f : \\mathbb N \\to \\mathbb N$, we have \n$x\\sum_{i \\le n} f(i) = \\sum_{i < n} x f(i)$,\nfor all natural numbers $x$ and $n$.\n", "end exlean -- hide", "import natural_numbers.mul_fsum -- hide\n", "set_option pp.structure_projections false -- hide\n", "namespace exlean -- hide\n", "open_locale mynum -- hide\n", "open mynat -- hide\n", "# Natural numbers\n\n## Level 26: Summing over sums\n", "open_locale fsum -- hide\n", "\n## Task\n\nFor all functions $f$ and $g$ of type $\\mathbb N \\to \\mathbb N$,\nprove that \n$$\n\\sum_{i < n} (f(i) + g(i)) = \\sum_{i < n} f(i) + \\sum_{i < n} g(i),\n$$\nfor every natural number $n$.\n", "For all functions $f$ and $g$ of type $\\mathbb N \\to \\mathbb N$,\nwe have \n$\\sum_{i < n} (f(i) + g(i)) = \\sum_{i < n} f(i) + \\sum_{i < n} g(i),$\nfor all natural numbers $n$.\n", "end exlean -- hide", "import natural_numbers.fsum_add_distrib -- hide\n", "set_option pp.structure_projections false -- hide\n", "namespace exlean -- hide\n", "open_locale mynum -- hide\n", "open mynat -- hide\n", "# Natural numbers\n\n## Level 27: Multiplying sums\n", "open_locale fsum -- hide\n", "\n## Task\n\nFor all functions $f$ and $g$ of type $\\mathbb N \\to \\mathbb N$,\nprove that \n$$\n\\left(\\sum_{i < m} f(i)\\right) \\left(\\sum_{j < n} g(j)\\right)  =\n\\sum_{i < m} \\sum_{j < n} f(i)g(j)\n$$\nfor all natural numbers $m$ and $n$.\n", "There's a painful way and an easy (or easier) way to prove this result. The \neasier way is to try induction on `m`, rather than induction on `n`.`\n", "Having trouble with the induction?", "At some point in the proof, you'll need to use the results `mul_fsum` and `add_mul`.\n", "A useful result", "For all functions $f$ and $g$ of type $\\mathbb N \\to \\mathbb N$,\nwe have \n$\\left(\\sum_{i < m} f(i)\\right) \\left(\\sum_{j < n} g(j)\\right)  =\n\\sum_{i < m} \\sum_{j < n} f(i)g(j)$,\nfor all natural numbers $n$.\n", "end exlean -- hide", "Propositional logic", "import data.int.basic tactic.pure_maths -- hide\n", "# Propositional logic\n## Level 1: And elimination\n\nLet $p$ and $q$ be propositions (mathematical statements). The formal statement $p \\land q$\n(read '$p$ conjunction $q$')\ncorresponds to the informal statement '$p$ and $q$'.\n\nSuppose you are given a hypothesis `h : p \u2227 q`. Then\n\n1. [left and elimination] `h.left` is a proof of `p` and\n2. [right and elimination] `h.right` is a proof of `q`.\n\nHere, `h.left` is an abbreviation for `and.elim_left h`. Likewise for `h.right`.\n\n**Theorem**: Let $x$ be an integer. Supose $h : (x > 0) \\land (x ^ 2 = 16)$. Then $x ^ 2 = 16$.\n\n**Proof**: The result follows from right and elimination on $h$. \u220e\n\nThe Lean proof is below.\n\n**Notation**: the symbol `\u2227` in Lean is typed `\\and`.\n", "p\n", "q\n", "example (x : \u2124) (h : (x > 0) \u2227 (x * x = 16)) : x * x = 16 :=\nbegin\n  from h.right,\nend\n", "Alternatively, the `cases` tactic will decompose the `\u2227` into both the left and right sides.\nBelow `cases h with h\u2081 h\u2082` decomposes `h` into `h\u2081 : x > 0` and `h\u2082 : x * x = 16`.\n", "example (x : \u2124) (h : (x > 0) \u2227 (x * x = 16)) : x * x = 16  :=\nbegin\n  cases h with h\u2081 h\u2082,  \n  show x * x = 16, from h\u2082,\nend\n", "Frequently, we consider the conjunction of several statements. \nWe can, for instance, derive $q$ given the assumption $p \\land (q \\land r).\n", "example (p q r : Prop) (h : p \u2227 (q \u2227 r)) : q :=\nbegin\n  have h\u2082 : q \u2227 r, from h.right,\n  show q, from h\u2082.left,\nend\n", "`cases` is a general-purpose elimination tactic. It it used to 'decompose' a hypothesis into\nits constituent parts.\n\n### Examples\n\n* Given `h : \u2203 (x : \u2124), x + 5 = y`, typing `cases h with m h\u2082` replaces `h` with `m : \u2124` and\n`h\u2082 : m + 5 = y`.\n\n* Given `h : p \u2227 q`, typing `cases h with hp hq` replaces `h` with `hp : p` and `hq : q`.\n\n* Given `h : p \u2228 q`, typing `cases h with hp hq` replaces the current goal with two goals\n(1) in which `h` is replaced with `hp : p` and (2) in which `h` is replaced with `hq : q`.\n\n* Given `x : \u2115`, typing `cases x with k` replaces the goal with two new goals: (1) a goal in which\nevery occurence of `x` is replaced with `0` and (2) a goal with a new variable `k : \u2115` and in \nwhich every occurrence of `x` is replaced with `succ k`.\n\n* Given `h : \u2203 (x : X), P(x)`, typing `cases h with y h\u2082` introduces a new variable `y : X`\nand replaces `h` with `h\u2082 : P(y)`.\n", "namespace exlean -- hide\n", "## Tasks\n\n1. Replace `sorry` below with a Lean proof using `have` together with left and right and elimination.\nAdapt the proof of the example above.\n2. Write another Lean proof using `cases`.\n3. On a piece of paper, state and give a handwritten proof of this result.\n", "Let $p$, $q$, and $r$ be propositions. Assuming $h : (r \\land (p \\land q)) \\land r$,\nwe have $q$.\n", "end exlean -- hide", "import tactic.pure_maths -- hide\n", "# Propositional logic\n## Level 2: And introduction\n\n## And introduction\n\nTo *prove* $p\\land q$ is to prove $p$ and to prove $q$.\n\nIn Lean, if `h\u2081 : p` is a proof of `p` and `h\u2082 : q` is a proof of `q`, then `and.intro h\u2081 h\u2082`\nis a proof of `p \u2227 q`.\n", "example (p q : Prop) (h\u2081 : p) (h\u2082 : q) : p \u2227 q :=\nbegin\n  from and.intro h\u2081 h\u2082,\nend\n", "The `split` tactic is an alternative (backward) proof technique. If the target is to prove `p \u2227 q`,\nthen `split` replaces the goal with two new goals: (1) to prove `p` and (2) to prove `q`.\n", "example (p q : Prop) (h\u2081 : p) (h\u2082 : q) : p \u2227 q :=\nbegin\n  split,\n  { show p, from h\u2081, }, -- The first goal.\n  { show q, from h\u2082, }, -- The second goal.\nend\n", "namespace exlean -- hide\n", "## Tasks\n\n1. Replace `sorry` below with a Lean proof using `and.intro`.\n2. Write another Lean proof using `split`.\n3. On a piece of paper, state and give a handwritten proof of this result.\n\n**Notation**: Recall that `h\u2081` is written `h\\1`.\n", "\nThe `split` tactic splits a 'compound' target into multiple goals. \n\n### Examples\n\n`split` turns the target `\u22a2 p \u2227 q` into two goals: (1) `\u22a2 p` and (2)  `\u22a2 q`.\n\nEqually, if the target is `\u22a2 p \u2194 q`, split creates the goals (1) to prove\n`p \u2192 q` and (2) to prove `q \u2192 p`.\n", "p \u2227 q\n", "variables (p q r : Prop) -- hide\n", "Let $p$, $q$, and $r$ be propositions. Assuming $h_1 : p$, $h_2 : q$, and $h_3 : r$, we have\n$h : r \\land q$.\n", "end exlean -- hide", "import tactic.pure_maths -- hide\n", "# Propositional logic\n## Level 3: And swap\n\n", "namespace exlean -- hide\n", "variables {p q : Prop} -- hide\n", "## Task\n\nIntuitively, you'd expect that if you have $h : p \\land q$, then you can derive $q \\land p$.\nIn this level, you'll do just that!\n\nRecall you can:\n* use `cases`, or `.left` and `.right` for and elimination and\n* use `split` or `and.intro` for and introduction.\n", "Let $p$ and $q$ be propositions. Assuming $h : p \\land q$, we have $h : q \\land p$.\n", "end exlean -- hide", "import propositional_logic.and_swap -- hide\n", "# Propositional logic\n## Level 4: Implication elimination\n\nGiven proofs of $p \\to q$ ($p$ implies $q$) and $p$, you know $q$. This is *implication elimination*,\nsometimes called *modus ponens*.\n\nIn Lean, if `h\u2081 : p \u2192 q` is a proof of `p \u2192 q` and `h\u2082 : p` is a proof of `p`, then `h\u2081 h\u2082` is a proof\nof `q`.\n\n**Notation**: The symbol `\u2192` is typed `\\r`.\n", "variables (p q r : Prop) -- hide\n", "example (h\u2081 : p \u2192 q) (h\u2082 : p) : q :=\nbegin\n  from h\u2081 h\u2082\nend\n", "As an example, we'll prove $r$ on the assumptions $h_1 : p \\to (q \\land r)$ and $h_2 : p$.\n", "example (h\u2081 : p \u2192 (q \u2227 r)) (h\u2082 : p) : r :=\nbegin\n  have h\u2083 : q \u2227 r, from h\u2081 h\u2082,\n  show r, from h\u2083.right,\nend\n", "namespace exlean -- hide\n", "## Task\n\nProve the following result in Lean.\n", "Let $p$, $q$, and $r$ be propositions. Assuming $h_1 : p \\to q \\land r$ and $h_2 : p$, we have $q$.\n", "end exlean -- hide", "import propositional_logic.imp_elim -- hide\n", "# Propositional logic\n## Level 5: Implication introduction\n\nTo prove $p \\to q$ it to assume $p$ and derive $q$.\n\nIn Lean, if the target is `p \u2192 q`, typing `assume h : p` introduces `h : p` into the context\nand replaces the target with one of proving `q`.\n\nHere, we prove $(p \\land q) \\to p$.\n", "variables (p q : Prop) -- hide\n", "example : (p \u2227 q) \u2192 p :=\nbegin\n  assume h : p \u2227 q,\n  show p, from h.left,\nend\n", "namespace hidden -- hide\n", "A useful result, `id` asserts that `s \u2192 s`, for any `s`.\n", "p \u2192 p\n", "variable (s : Prop) -- hide\n", "lemma id : s \u2192 s :=\nbegin\n  assume h : s,\n  show s, from h,\nend\n", "end hidden -- hide\n", "namespace exlean -- hide\n", "In the fun example below, we prove $p \\to (q \\to p)$.\n", "example : p \u2192 (q \u2192 p) :=\nbegin\n  assume h\u2081 : p,\n  show q \u2192 p,\n  assume h\u2082 : q,\n  show p, from h\u2081,\nend\n", "## Task\n\nProve the following result in Lean.\n", "Let $p$ and $q$ be propositions. Then $(p \\land q) \\to p$.\n", "end exlean -- hide", "import propositional_logic.imp_intro -- hide\n", "# Propositional logic\n## Level 6: Proving negations\n\nGiven a proposition $p$, we write $\\neg p$ to mean 'not $p$'. Thus, $\\neg (x = 5)$ is the same as\n$x \\ne 5$. Formally, $\\neg p$ is an abbreviation for $p\\to\\bot$, where $\\bot$ is read 'false'\nor 'contradiction'.\n\nWe've seen that to prove $p \\to q$ is to assume $p$ and derive $q$. Thus, to prove $\\neg p$ is to\nassume $p$ and derive $\\bot$.\n\n**Notation**: The symbol `\u00ac` is typed `\\n` or `\\not`. The mathematical symbol $\\bot$ is written\n`false` in Lean.\n\nUsing these ideas, we'll prove $p \\to \\neg\\neg p$.\n", "namespace exlean -- hide\n", "variables {p q r : Prop} -- hide\n", "p \u2192 \u00ac\u00acp\n", "lemma not_not_intro : p \u2192 \u00ac\u00acp :=\nbegin \n  assume h\u2081 : p,\n  show \u00ac\u00acp,\n  show \u00acp \u2192 false,\n  assume h\u2082 : \u00acp, -- So h\u2082 : p \u2192 false\n  show false, from h\u2082 h\u2081,\nend\n", "Implication elimination is used in the last line of the proof above. Lean permits *backward*\nimplication elimination via the `apply` tactic.\nIf the target is to prove `q` and if `h : p \u2192 q`, then typing `apply h`, transforms\nthe target to one of proving `p`.\n\nBelow, we prove $r$ on the assumptions $h_1 : (p \\land q) \\to r)$, $h_2 : p$ and $h_3 : q$.\nThe first step is to realise that $r$ is the 'conclusion' of $h_1$, whence `apply h\u2081` transforms\nthe goal to one of proving $p \\land q$.\n", "example (h\u2081 : (p \u2227 q) \u2192 r) (h\u2082 : p) (h\u2083 : q) : r :=\nbegin\n  apply h\u2081,\n  show p \u2227 q, from and.intro h\u2082 h\u2083,\nend\n", "## Task\n\nProve the logical principle that $\\neg q \\to \\neg p$ follows from $p \\to q$. This is\nsometimes called *modus tollens*.\n\nYou'll need to perform implication introduction three times and implication elimination twice.\nFor fun, try both formward and backward implication elimination.\n", "Let $p$ and $q$ be propositions. Then $(p \\to q) \\to (\\neg q \\to \\neg p)$.\n", "end exlean -- hide", "import propositional_logic.proving_negation -- hide\n", "# Propositional logic\n## Level 7: Or introduction\n\nThe proposition $p \\lor q$ has the informal meaning '$p$ or $q$'. To prove $p \\lor q$ is:\n1. [left or introduction] to prove $p$ or`\n2. [right or introduction] to prove $q$.\n\nIn Lean, suppose `h\u2081 : p` is a proof of `p` and `h\u2082 : q` is a proof of `q`. Then\n`or.inl h\u2081` is a proof of `p \u2228 q` and `or.inr h\u2082` is a proof of `p \u2228 q`.\n\n**Notation**: `\u2228` is typed `\\or`.\n", "namespace exlean -- hide\n", "variables {p q r : Prop} -- hide\n", "example (h\u2081 : p) : p \u2228 q :=\nbegin\n  from or.inl h\u2081,\nend\n", "-- hide\n", "example (h\u2082 : q) : p \u2228 q :=\nbegin\n  from or.inr h\u2082,\nend\n", "For example, we'll prove `p \u2228 (q \u2227 r)` given `h : p`.\n", "example (h : p) : p \u2228 (q \u2227 r) :=\nbegin\n  from or.inl h,\nend\n", "  (h : p) : p \u2228 q\n", "  (h : q) : p \u2228 q\n", "`left` changes a goal of proving `p \u2228 q` into a goal of proving `p`.\n", "`right` changes a goal of proving `p \u2228 q` into a goal or proving `q`.\n", "As a backward alternative, if the target is to prove `p \u2228 q`, the `left` tactic replaces the target\nwith one of proving `p`. Likewise for the `right` tactic.\n\nHere is a backward proof that $q \\lor (p \\lor r)$ follows from $h : p$.\n", "example (h : p) : q \u2228 (p \u2228 r) :=\nbegin \n  show q \u2228 (p \u2228 r),\n  right,\n  show p \u2228 r,\n  left,\n  show p, from h,\nend\n", "To prove the same result forward involves the introduction of hypotheses.\n", "example (h : p) : q \u2228 (p \u2228 r) :=\nbegin\n  have h\u2082 : p \u2228 r, from or.inl h,\n  show q \u2228 (p \u2228 r), from or.inr h\u2082,\nend\n", "## Task\n\nProve the following in Lean and by hand.\n", "Let $p$, $q$ and $r$ be propositions. Then $(p \\lor q) \\lor r$ follows from the assumption\n$h : q$.\n", "end exlean -- hide", "import propositional_logic.or_introduction -- hide\n", "# Propositional logic\n## Level 8: Or elimination\n\nSuppose you are given $h : p \\lor q$. To prove $r$ is to\n1. Assume $p$ and derive $r$ and (separately) to\n2. assume $q$ and derive $r$.\n\nThis is (backward) *or elimination*.\n\nFor example, we prove $q \\lor p$ on the assumption $h : p \\lor q$.\n\n**Proof**:\n1. Assume $h_2 : p$. We must show $q \\lor p$. This follows from right or introduction on $h_2$.\n2. Assume $h_3 : q$. We must show $q \\lor p$. This follows from left or introduction on $h_3$.\n\n\nIn Lean, the `cases` tactic performs backward or elimination. With hypotheses as above,\n`cases h with h\u2082 h\u2083` creates two new goals:\n1. to prove `r` under the assumption `h\u2082 : p` and, separately\n2. to prove `r` under the assumption `h\u2083 : q`.\n\nHere is a Lean proof of the result above.\n", "namespace exlean -- hide\n", "variables {p q r : Prop} -- hide\n", "q \u2228 p\n", "lemma or.swap (h : p \u2228 q) : q \u2228 p :=\nbegin\n  cases h with h\u2082 h\u2083,\n  { given h\u2082 : p,\n    show q \u2228 p, from or.inr h\u2082, },\n  { given h\u2083 : q,\n    show q \u2228 p, from or.inl h\u2083, },\nend\n", "## Task\n\nProve the following in Lean and by hand. For the adventurous, see the end of this level for discussion\nof *forward* or elimination. Come back and try a forward argument of this result.\n", "Let $p$, $q$ and $r$ be propositions. Then $p$ follows from the assumption\n$h : (p \\land q) \\lor (r \\land p)$.\n", "## Forward or elimination\n\nI find it simplest to use or elimination in its backward form. For the sake of completeness, I\ninclude the forward version.\n\nLet $h : p \\lor q$ be a proof of $p \\lor q$, $h_1 : p \\to r$ a proof of $p \\to r$ and let $h_2 : q \\to r$ be a proof of $q \\to r$.\nThen (forward) *or elimination* applied to $h$, $h_1$, and $h_2$ is a proof of $r$.\n\nThe Lean name of the formard or elimination result is `or.elim`. Below, we use it to re-prove `or.swap`.\n", "r\n", "example  (h : p \u2228 q) : q \u2228 p :=\nbegin\n  have h\u2081 : p \u2192 (q \u2228 p),\n  { assume k : p,\n    show q \u2228 p, from or.inr k, },\n", "  -- hide\n", "  have h\u2082 : q \u2192 (q \u2228 p),\n  { assume k : q,\n    show q \u2228 p, from or.inl k,  },\n", "  -- hide\n", "  show q \u2228 p, from or.elim h h\u2081 h\u2082,\nend\n", "end exlean -- hide", "import propositional_logic.or_elimination -- hide\n", "# Propositional logic\n## Level 9: Iff elimination\n\nThe proposition $p \\leftrightarrow q$ represents the informal notation '$p$ if and only if $q$'.\n\nSuppose you are given `h : p \u2194 q` Then\n1. [left iff elimination] `h.mp` is a proof of `p \u2192 q` and\n2. [right iff elimination] `h.mpr` is a proof of `q \u2192 p`.\n\nHere, `h.left` is an abbreviation of `iff.elim_left`. Likewise for `h.right`.\n\n**Notation**: `\u2194` is typed `\\iff`.\n\nUsing this, we'll prove $p$ on the assumptions $h_1 : p \\leftrightarrow q$ and $h_2 : q$.\n\n**Proof**:\nWe have $h_3 : q \\to p$ by right iff elimination on $h_1$.\nFrom $h_3$, it suffices to show $q$, which follows from $h_2$.\n", "p \u2192 q\n", "q \u2192 p\n", "namespace exlean -- hide\n", "variables {p q r : Prop} -- hide\n", "The same result may be proved in Lean.\n", "example (h\u2081 : p \u2194 q) (h\u2082 : q) : p :=\nbegin\n  have h\u2083 : q \u2192 p, from iff.elim_right h\u2081,\n  apply h\u2083,\n  show q, from h\u2082,\nend\n", "Alternatively, the `cases` tactic (much as for and elimination) decomposes `h : p \u2194 q` into proofs\nof `p \u2192 q` and `q \u2192 p`. We use this below and also \n", "example (h\u2081 : p \u2194 q) (h\u2082 : q) : p :=\nbegin\n  cases h\u2081 with k h\u2083,\n  given h\u2083 : q \u2192 p,\n  apply h\u2083,\n  show q, from h\u2082,\nend\n", "## Task\n\nProve the following in Lean and by hand. Use either forward or backward iff elimination.\n", "Let $p$, $q$ and $r$ be propositions. Then $q$ follows from the assumptions\n$h : p \\leftrightarrow (q \\land r)$ and $k : p$.\n", "end exlean -- hide", "import propositional_logic.iff_elimination -- hide\n", "# Propositional logic\n## Level 10: Iff introduction\n\nTo *prove* $p\\leftrightarrow q$ is to prove $p \\to q$ and to prove $q \\to p$.\n\nIn Lean, if `h\u2081 : p \u2192 q` is a proof of `p \u2192 q` and `h\u2082 : q \u2192 p` is a proof of `q \u2192 p`, then\n`iff.intro h\u2081 h\u2082` is a proof of `p \u2194 q`.\n\nNote the similarities between `\u2227` and `\u2194`.\n", "p \u2194 q\n", "namespace exlean -- hide\n", "variables {p q r : Prop} -- hide\n", "example (p q : Prop) (h\u2081 : p \u2192 q) (h\u2082 : q \u2192 p) : p \u2194 q :=\nbegin\n  from iff.intro h\u2081 h\u2082,\nend\n", "Recall we earlier proved `and.swap` which gives `q \u2227 p` from `p \u2227 q`.\nWe'll use this to prove `(a \u2227 b) \u2194 (b \u2227 a)`.\n", "a \u2227 b \u2194 b \u2227 a \n", "lemma and.comm {a b : Prop} : (a \u2227 b) \u2194 (b \u2227 a) :=\nbegin\n  have h\u2081 : a \u2227 b \u2192 b \u2227 a, from and.swap,\n  have h\u2082 : b \u2227 a \u2192 a \u2227 b, from and.swap,\n  show a \u2227 b \u2194 b \u2227 a, from iff.intro h\u2081 h\u2082,\nend\n", "As with `\u2227` introduction, the `split` tactic changes a goal of proving `p \u2194 q` into two\nnew goals: (1) to prove `p \u2192 q` and (2) to prove `q \u2192 p`. This is backward iff introduction.\n", "example {a b : Prop} : (a \u2227 b) \u2194 (b \u2227 a) :=\nbegin\n  split,\n  { show (a \u2227 b) \u2192 (b \u2227 a), from and.swap, },\n  { show (b \u2227 a) \u2192 (a \u2227 b), from and.swap, }, \nend\n", "## Task\n\nProve the commutativity of `\u2228` in Lean and by hand.\n", "Let $p$ and $q$ be propositions. Then $(p \\lor q) \\leftrightarrow (q \\lor p)$.\n", "end exlean -- hide", "import propositional_logic.iff_introduction -- hide\n", "# Propositional logic\n## Level 11: True and false\n\nWe have two propositional constants, $\\top$ and $\\bot$, written as \n`true` and `false` in Lean.\n\nThere's not much to say about $\\top$. It's always true. The proof of this is `trivial`, also called\n*true introduction*.\n", "true\n", "example : true :=\nbegin\n  from trivial,\nend\n", "False ($\\bot$) is more interesting! The single governing principle of `false` is that\n*anything follows from false*, a principle called *false elimination* or *exfalso sequitur quodlibet*.\n\nIn Lean, if `h : false` is a proof of `false` and if `p` is *anything*, then `false.elim h` is\na proof / construction of `p`.\n", "p\n", "universe u -- hide\n", "example (p : Sort u) (h : false) : p :=\nbegin\n  from false.elim h,\nend\n", "namespace exlean -- hide\n", "## Task\n\nRecall that $\\neg p$ is shorthand for $p \\to \\bot$ (or `p \u2192 false` in Lean notation).\n\nUse this to prove that anything follows from the assumptions of $p$ and $\\neg p$.\n", "Let $p$ and $q$ be propositions. Then $q$ follows from $h_1 : p$ and\n$h_2 : \\neg p$.\n", "end exlean -- hide", "import propositional_logic.true_and_false tactic.localized -- hide\n", "# Propositional logic\n## Level 12: Law of the excluded middle, proof by cases, proof by contradiction\n\nGiven a proposition $p$, the law of the excluded middle is the assertion $p \\lor \\neg p$.\n\nIn Lean, if `p : Prop`, then `em p` is the assertion `p \u2228 \u00acp`.\n", "p \u2228 \u00acp\n", "open_locale classical -- hide\n", "example (p : Prop) : p \u2228 \u00acp :=\nbegin\n  from em p,\nend\n", "False ($\\bot$) is more interesting! The single governing principle of `false` is that\n*anything follows from false*, a principle called *false elimination* or *exfalso sequitur quodlibet*.\n\nIn Lean, if `h : false` is a proof of `false` and if `p` is *anything*, then `false.elim h` is\na proof / construction of `p`.\n", "p\n", "example (p : Type*) (h : false) : p :=\nbegin\n  from false.elim h,\nend\n", "namespace exlean -- hide\n", "variables {p q : Prop} -- hide\n", "From the law of the excluded middle, we derive a proof method called 'proof by cases'.\nNamely, to prove $q$, it suffices to prove $p \\to q$ and $\\neg p \\to q$.\n\nThe first step of the proof is to deduce $h : p \\lor \\neg p$, by the law of the\nexcluded middle. The rest of the proof follows by or elimination on $h$.\n\n", "q\n", "theorem by_cases (h\u2081 : p \u2192 q) (h\u2082 : \u00acp \u2192 q) : q :=\nbegin\n  have k : p \u2228 \u00acp, from em p,\n  cases k with k\u2081 k\u2082,\n  { given k\u2081 : p,\n    show q, from h\u2081 k\u2081, },\n  { given k\u2082 : \u00acp,\n    show q, from h\u2082 k\u2082, },\nend\n", "\nWe call `by_cases` with the name of a proposition `p` and a tag for the resulting hypotheses.\nFor example, if you write `by_cases h : p`, then Lean creates two new goals\n(1) to prove the target under the assumption\n`h : p` and (2) separately to prove the target under the assumption `h : \u00acp`.\n\n", "This is such a useful theorem that Lean provides a `by_cases` tactic to help write\nbackward proofs by cases. It's best illustrated by example.\n\nWe call `by_cases` with the name of a proposition `p` and a tag for the resulting hypotheses\n(here, we used `k`). The tactic creates two new goals (1) to prove the target under the assumption\n`k : p` and (2) separately to prove the target under the assumption `k : \u00acp`.\n", "example (h\u2081 : p \u2192 q) (h\u2082 : \u00acp \u2192 q) : q :=\nbegin\n  by_cases k : p,\n  { given k : p,\n    show q, from h\u2081 k, },\n  { given k : \u00acp,\n    show q, from h\u2082 k, },\nend\n", "## Tasks\n\nProof by contradiction asserts that to prove $p$, it suffices to show that $\\neg p$ leads to a\ncontradiction. Equally, to prove $(\\neg p \\to \\bot) \\to p$.\n\n1. Your first task is to complete the result below, the principle of 'proof by contradiction',\nusing any of the methods shown above (law of the excluded middle, the proof by cases theorem or the proof\nby cases tactic).\n2. Lean offers a `by_contra` tactic to help write backward proofs by contradiction.\nProve the theorem below by starting with `by_contra k`. This introduces the hypothesis `k : \u00acp`\nand makes proving `false` the target.\n\n", "\nProof by contradiction. If the target is to prove `p`, using the tactic `by_contra h` will introduce the hypothesis `h : p`\nand change the target to one of proving `false`. \n", "Proof by contradiction. Given a proposition $p$, we have $\\neg \\neg p \\to \\bot$.\n", "end exlean -- hide", "import propositional_logic.lem -- hide\n", "# Propositional logic\n## Level 13: Propositional extensionality\n\nLet $\\alpha$ and $\\beta$ be propositions. Suppose $\\alpha\\leftrightarrow\\beta$. Then anything that holds for $\\alpha$ holds for $\\beta$\nand vice-versa. This is called *propositional extensionality*.\n\nUsing propositional extensionality is similar to using `rw` to write backward proofs in the\nequation world.\n", "namespace exlean -- hide\n", "variables {p q r : Prop} -- hide\n", "We prove $p \\lor (q\\land r) \\to p \\lor (r \\land q)$ by propositional extensionality.\n\n**Proof**:\n$$\n\\begin{align}\n&& p \\lor (q\\land r) \\to (r \\land q) \\lor p& &  \\\\\\\\\n&\\iff & p \\lor (r\\land q) \\to (r \\land q) \\lor p & & \\text{[by commutativity of $\\land$]} \\\\\\\\\n&\\iff & (r \\land q) \\lor p \\to (r \\land q) \\lor p. & & \\text{[by commutativity of $\\lor$]} \\\\\\\\\n\\end{align}\n$$\nThe last line follows by reflexivity of $\\to$. \u220e\n", "The same proof is given below in Lean.\n", "example : p \u2228 (q \u2227 r) \u2192 (r \u2227 q) \u2228 p :=\nbegin\n  show p \u2228 (q \u2227 r) \u2192 (r \u2227 q) \u2228 p, rw and.comm,\n  show p \u2228 (r \u2227 q) \u2192 (r \u2227 q) \u2228 p, rw or.comm,\n  show (r \u2227 q) \u2228 p \u2192 (r \u2227 q) \u2228 p, from id,\nend\n", "Before moving on to the task for this level, we'll prove a helpful\nequivalence, that $\\neg\\neg p \\leftrightarrow p$.\n", "\u00ac\u00acp \u2194 p\n", "lemma not_not {p : Prop} : \u00ac\u00acp \u2194 p :=\nbegin\n  have h\u2081 : \u00ac\u00acp \u2192 p, from by_contra,\n  have h\u2082 : p \u2192 \u00ac\u00acp, from not_not_intro,\n  show \u00ac\u00acp \u2194 p, from iff.intro h\u2081 h\u2082,\nend\n", "## Tasks\n1. Prove the result below in Lean using propositional extensionality. Follow the idea\nof the proof above.\n2. If you're feeling adventurous, try proving the result *without* using propositional\nextensionality.\n\n", "Let $p$, $q$, and $r$ be propositions. Then\n$q \\land \\neg\\neg(r \\lor p) \\to (p \\lor r) \\land q$.\n", "end exlean -- hide", "import propositional_logic.prop_ext -- hide\n", "# Propositional logic\n## Level 14: Implication redux, part 1\n\nThe aim of this level and the next is to prove $p \\to q$ is equivalent to $\\neg p \\lor q$.\n", "namespace exlean -- hide\n", "## Task\nProve in Lean that $(\\neg p \\lor q) \\to (p \\to q)$.\n", "Let $p$ and $q$ be propositions. Then $(\\neg p \\lor q) \\to (p \\to q)$.\n", "end exlean -- hide", "import propositional_logic.implication_redux1 -- hide\n", "# Propositional logic\n## Level 15: Implication redux, part 2\n\nIn this level, we prove the converse of the result of the previous level.\n", "namespace exlean -- hide\n", "## Task\nProve in Lean that $(p \\to q) \\to (\\neg p \\lor q)$.\n", "For this result, you'll need to use a non-constructive proof method\n(law of the excluded middle, proof by contradiction, proof by cases, and so forth).\nI suggest proof by cases on `p`.\n", "Suggested approach", "If you get stuck, try the following template.\n```\nassume h : p \u2192 q,\nshow \u00acp \u2228 q,\nby_cases k : p,\n{ given k : p,\n  sorry, },\n{ given k : \u00acp,\n  sorry, },\n```\n\n", "A proof template", "Let $p$ and $q$ be propositions. Then $(p \\to q) \\to (\\neg p \\lor q)$.\n", "end exlean -- hide", "import propositional_logic.implication_redux2 -- hide\n", "# Propositional logic\n## Level 16: De Morgan's laws 1\n\nDe Morgan's laws state:\n* $\\neg(p \\land q) \\leftrightarrow (\\neg p \\lor \\neg q)$ and\n* $\\neg(p \\lor q) \\leftrightarrow (\\neg p \\land \\neg q)$.\n\nIn this series of levels, you will prove the four implications that\ntogether constitute these laws.\n", "namespace exlean -- hide\n", "## Task\nProve in Lean that $(\\neg p \\lor \\neg q) \\to \\neg(p \\land q)$. \n", "You need to prove an implication. Thus, you should start by assuming\nthe left hand side of the implication.\n\nAt some point, you will need to decompose an or statement.\n", "Suggested approach", "Let $p$ and $q$ be propositions. Then $(\\neg p \\lor \\neg q) \\to \\neg(p \\land q)$.\n", "end exlean -- hide", "import propositional_logic.de_morgan1 -- hide\n", "# Propositional logic\n## Level 17: De Morgan's laws 2\n\nWe continue our examination of De Morgan's laws by proving the\n'backward' direction of \n\n$\\neg(p \\lor q) \\leftrightarrow (\\neg p \\land \\neg q)$.\n", "namespace exlean -- hide\n", "## Task\nProve in Lean that $(\\neg p \\land \\neg q) \\to \\neg(p \\lor q)$. \n", "You need to prove an implication. Thus, you should start by assuming\nthe left hand side of the implication.\n\nAt some point, you will need to decompose an or statement and an\nand statement.\n", "Suggested approach", "Let $p$ and $q$ be propositions. Then $(\\neg p \\lor \\neg q) \\to \\neg(p \\land q)$.\n", "end exlean -- hide", "import propositional_logic.de_morgan2 -- hide\n", "# Propositional logic\n## Level 18: De Morgan's laws 3\n\nWe now prove the forward direction of:\n$\\neg(p \\lor q) \\leftrightarrow (\\neg p \\land \\neg q)$.\n", "namespace exlean -- hide\n", "## Task\nProve in Lean that $\\neg(p \\lor q) \\to (\\neg p \\land \\neg q)$. \n", "You need to prove an implication. Thus, you should start by assuming\nthe left hand side of the implication.\n\nYou then have to prove an `\u2227` statement. What should you do?\n", "Suggested approach", "Let $p$ and $q$ be propositions. Then $(\\neg p \\lor \\neg q) \\to \\neg(p \\land q)$.\n", "end exlean -- hide", "import propositional_logic.de_morgan3 -- hide\n", "# Propositional logic\n## Level 19: De Morgan's laws 4\n\nWe continue our examination of De Morgan's laws by proving the\n'forward' direction of \n\n$\\neg(p \\land q) \\leftrightarrow (\\neg p \\lor \\neg q)$.\n\n\nFor this level, it will be helpful to have a proof of\n$\\neg(p \\to q) \\leftrightarrow (\u00acp \\lor q)$.\n\nWe prove this by combining two results from previous levels:\n", "namespace exlean -- hide\n", "(p \u2192 q) \u2194 (\u00acp \u2228 q)\n", "lemma imp_iff_not_or {p q : Prop} : (p \u2192 q) \u2194 (\u00acp \u2228 q) :=\nbegin\n  have h\u2081 : (p \u2192 q) \u2192 (\u00acp \u2228 q), from not_or_of_imp,\n  have h\u2082 : (\u00acp \u2228 q) \u2192 (p \u2192 q), from or.neg_resolve_left,\n  show (p \u2192 q) \u2194 (\u00acp \u2228 q), from iff.intro h\u2081 h\u2082,\nend\n", "## Task\nProve in Lean that $\\neg(p \\land q) \\to (\\neg p \\lor \\neg q)$. \n", "\nAt some point in your proof, you will have a target of the form `\u00aca \u2228 b`.\n\nTo prove this kind of statement requires 'classical reasoning'. That is,\nyou'll need to use something like the law of the excluded middle,\nproof by cases, proof by contradiction, or a result that uses one of\nthose principles.\n\nPerhaps the simplest approach is to use the lemma `imp_iff_not_or` above.\n\nUsing this lemma, you can turn the target (of the form `\u00aca \u2228 b`) into\na statement of the form `a \u2192 b`. To do this, rewrite\nfrom the left, typing\n\n`rw \u2190imp_iff_not_or`\n", "Suggested approach", "Let $p$ and $q$ be propositions. Then $(\\neg p \\lor \\neg q) \\to \\neg(p \\land q)$.\n", "end exlean -- hide", "Predicate logic", "import data.nat.basic propositional_logic.de_morgan4 -- hide\n", "# Predicate logic\n## Level 1: For all elimination\n\nSuppose $P : X \\to \\mathsf{Prop}$ is a predicate on a type $X$.\nGiven $h : \\forall (x : X),\\ P(x)$ and given $y : X$, the *for all\nelimination rule* applied to $h$ and $y$ gives a proof of $P(y)$.\n\nAs an example, let $h$ be a proof that\n$\\forall (n : \\mathbb N),\\ (n + 1)^2 = n ^ 2 + 2n + 1$.\n\nThen 'for all elimination', applied to $h$ and $ab$ (for natural \nnumbers $a$ and $b$) gives a proof of\n$(ab + 1)^2 = (ab)^2 + 2(ab) + 1$.\n\nIn Lean, if `h : \u2200 (x : X), P(x)` and if `y : X`, then the\nexpression `h(y)` is a proof of `P(y)`.\n\nThe symbol `\u2200` is typed `\\all`.\n\nHere follows a Lean translation of the above example.\n", "example (a b : \u2115) (h : \u2200 (n : \u2115), (n + 1)^2 = n^2 + 2 * n + 1)\n: (a * b + 1) ^ 2 = (a * b)^2 + 2 * (a * b) + 1 :=\nbegin\n  from h (a * b),\nend\n", "An alternative approach is to use the `specialize` tactic.\nGiven a hypothesis `h : \u2200 (x : X), P(x)` and given a term `y : X`,\ntyping `specialize h y` replaces `h` with `h : P(y)`.\n\nThat is, the general statment `\u2200 (x : X), P(x)` is replaced with\nits specialisation to `y`.\n\nHere is the same result as above, proved using the `specialize` tactic.\nAfter the first line, the hypothesis `h` changes to\n`h : (a * b + 1) ^ 2 = (a * b) ^ 2 + 2 * (a * b) + 1`\n\nIt is used directly in the last line to conclude the proof.\n", "example (a b : \u2115) (h : \u2200 (n : \u2115), (n + 1)^2 = n^2 + 2 * n + 1)\n: (a * b + 1) ^ 2 = (a * b)^2 + 2 * (a * b) + 1 :=\nbegin\n  specialize h (a * b),\n  from h,\nend\n", "`specialize` changes a proof of a `\u2200` statement to its specialisation at a particular value.\n\n### Example\n\nGiven `h : \u2200 (x : \u2124), f(x) = 10`, typing `specialize h 3` replaces `h` with\n`h : f(3) = 10`.\n", "namespace exlean -- hide\n", "## Tasks\n\n1. Prove the result below using for all elimination.\n2. Prove the result below using the `specialize` tactic.\n", "Let $f : \\mathbb N \\to \\mathbb N$ be a function such that\n$\\forall (x : \\mathbb N),\\ f(x) = f(x + 1)$.\nThen $f(5) = f(5 + 1)$.\n", "end exlean -- hide", "import predicate_logic.forall_elimination -- hide\n", "# Predicate logic\n## Level 2: For all introduction\n\nSuppose $P : X \\to \\mathsf{Prop}$ is a predicate on a type $X$.\nTo *prove* a statement $\\forall (x : X),\\ P(x)$ is to assume $y$\nis a term of type $X$ and to prove $P(y)$. This is the *for all\nintroduction* rule.\n\nIn this rule, there's nothing special about the name of the variable\n$y$ or the variable $x$.\n\n\n\nAs an example, suppose $P$ and $Q$ are predicates on a type $B$.\nWe'll prove $\\forall (b : B),\\ Q(b)$, given\n$h : \\forall (z : B),\\ P(z) \\land Q(z)$.\n\n**Proof** Assume $y : B$. We must show $Q(y)$.\nBy for all elimination on $h$ and $y$, we have $h_2 : P(y) \\land Q(y)$.\nWe show $Q(y)$ by right and elimination on $h_2$. \u220e\n\n*Note*: we don't explictly refer to the 'for all introduction' rule\nwhen proving a for all statement.\n", "variables (B : Type*) (P Q : B \u2192 Prop) -- hide\n", "example (h : \u2200 (z : B), P(z) \u2227 Q(z)) : \u2200 (b : B), Q(b) :=\nbegin\n  assume y : B,\n  show Q(y),\n  have h\u2082 : P(y) \u2227 Q(y), from h y,\n  show Q(y), from h\u2082.right,\nend\n", "namespace exlean -- hide\n", "## Tasks\n\n1. Prove the result below in Lean.\n2. Prove the result below by hand.\n", "Let $P$ and $Q$ be predicates on a type $B$. Suppose\n$h : \\forall (z : B),\\ P(z)$,\nthen $\\forall (b : B),\\ Q(b) \\lor P(b)$.\n", "end exlean -- hide", "import predicate_logic.forall_intro tactic.linarith -- hide\n", "# Predicate logic\n## Level 3: For all practice\n\n**Theorem**: Let $g : \\mathbb N \\to \\mathbb N$ be a function such\nthat $h : \\forall (n : \\mathbb N),\\ g(n + 1) = 2g(n)$. Then\n$\\forall (m : \\mathbb N),\\ g(m + 2) = 4g(m)$.\n\n**Proof**: Assume $m : \\mathbb N$. We must show $g(m + 2) = 4g(m)$.\nNow,\n$$\n\\begin{align}\ng(m + 2) &= g((m + 1) + 1) & & \\text{[by arithmetic]} \\\\\\\\\n&= 2 g(m + 1) & &\\text{[by $h$, specialised at $m + 1$]} \\\\\\\\\n&= 2 (2 g(m)) & &\\text{[by $h$, specialised at $m$]} \\\\\\\\\n&= 4g(m). & & \\text{[by arithmetic]}\n\\end{align}\n$$\n \u220e\n", "The handwritten proof above can be written in Lean. \nThe `linarith` tactic roughly corresponds to the English phrase\n'by arithemtic'. In particular, `linarith` proves many linear\nequations and inequalities.\n", "Proves many linear equations and inequalities.\n", "example (g : \u2115 \u2192 \u2115)\n(h : \u2200 (n : \u2115), g(n + 1) = 2 * g(n)) :\n\u2200 (m : \u2115), g(m + 2) = 4 * g(m) :=\nbegin\n  assume m : \u2115,\n  show g(m + 2) = 4 * g(m),\n  calc\n  g(m + 2)  = g((m + 1) + 1)  : by linarith\n        ... = 2 * g(m + 1)    : by rw h (m + 1)\n        ... = 2 * (2 * g(m))  : by rw h m\n        ... = 4 * g(m)        : by linarith\nend\n", "namespace exlean -- hide\n", "## Tasks\n\n1. Prove the result below in Lean, using the same basic structure as\nthe proof above.\n2. Prove the result below by hand.\n", "Let $f : \\mathbb N \\to \\mathbb N$ be a function such that\n$\\forall (a : \\mathbb N),\\ f(a) + f(a + 1) = f(a + 2)$. Then\n$\\forall (m : \\mathbb N),\\ 2 f(m + 2) = f(m) + f(m + 3)$.\n", "end exlean -- hide", "import predicate_logic.forall_practice -- hide\n", "# Predicate logic\n## Level 4: Exists introduction 1\n\nThe symbol $\\exists$ is real 'there exists' and is called the\nexistential quantifier.\n\nSuppose $P : X \\to \\mathsf{Prop}$ is a predicate on a type $X$.\nTo prove $\\exists (x : X),\\ P(x)$ is to exhibit a term $y : X$\nand a proof of $P(y)$. This is called *exists introduction*.\n\nAs an example, we'll prove an existentially quantified statement.\n\n**Theorem**: $\\exists (m : \\mathbb N),\\ m^2 + 2 = 3 m$.\n\nThe idea of the proof is to find an natural number $x$ together\nwith a proof that $x^2 + 2 = 3x$. How we *find* such a natural\nnumber is not relevant to the proof. In this case, you might\ntry to find an $x$ by rearranging the equation $x^2 + 2 = 3x$ into\n$(x - 2)(x - 1) = 0$, from which it is clear that $2$ or $1$ could\nbe taken as values for $x$.\n\n**Proof**: We have $h : 2^2 + 2 = 3 \\times 2$, by arithmetic.\nWe show $\\exists (m : \\mathbb N),\\ m^2 + 2 = 3 m$ by\nexists introduction on $2$ and $h$. \u220e\n\nIn Lean, `\u2203` is typed `\\exists`. The exists introduction rule is\ncalled `Exists.intro`. Given `y : X` and a proof `h : P(y)`,\n`Exists.intro y h` is a proof of `\u2203 (x : X), P(x)`.\n", "\u2203 (x : X), P(x)\n", "example : \u2203 (m : \u2115), m ^ 2 + 2 = 3 * m :=\nbegin\n  have h : 2 ^ 2 + 2 = 3 * 2, linarith,\n  from Exists.intro 2 h,\nend\n", "Our next example involves a more complicated predicate.\n\n**Theorem**: $\\exists (m : \\mathbb N),\\ (m < 2) \\land (m^2 + 2 = 3 m)$.\n\n**Proof**:\nWe have $h : (1 < 2) \\land (1 ^ 2 + 2 = 3 \\times 1)$ as\n1. $1 < 2$ by arithmetic and\n2. 1 ^ 2 + 2 = 3 \\times 1 by arithmetic.\n\nWe show $\\exists (m : \\mathbb N),\\ (m < 2) \\land (m^2 + 2 = 3 m)$\nfrom exists introduction on $1$ and $h$. \u220e\n\nIn the Lean proof below, we use the `split` tactic to prove the\n`\u2227` statement (recall this is backward and introduction).\n", "example : \u2203 (m : \u2115), (m < 2) \u2227 (m ^ 2 + 2 = 3 * m) :=\nbegin\n  have h : (1 < 2) \u2227 (1 ^ 2 + 2 = 3 * 1),\n  { split,\n      show 1 < 2, linarith,\n      show 1 ^ 2 + 2 = 3 * 1, linarith, },\n  from Exists.intro 1 h,\nend\n", "namespace exlean -- hide\n", "## Tasks\n\n1. Prove the result below in Lean, using the same basic structure as\nthe proof above.\n2. Prove the result below by hand.\n", "$\\exists (m : \\mathbb N),\\ (m > 5) \u2227 (m ^ 2 + 40 = 14 m)$\n", "end exlean -- hide", "import predicate_logic.exists_intro -- hide\n", "# Predicate logic\n## Level 5: Exists introduction 2\n\nIn the previous level, we saw that if `y : X` and if `h : P(y)`,\nthen `Exists.intro y h` is a proof of `\u2203 (x : X), P(x)`.\n\nThis is a 'forward' approach to the proof. Often, it is more\nnatural to give a 'backward' proof. Here a handwritten example.\n\n**Theorem**: $\\exists (m : \\mathbb N),\\ m^2 + 2 = 3 m$.\n\n**Proof**: Take $m$ to be $2$. It suffices to prove $2^2 + 2 = 3\\times 2$.\nBut this holds by arithmetic. \u220e\n\nIn Lean, we type `use 2` in place of the handwritten, 'Take $m$\nto be $2$'.\n", "\nThe `use` tactic is used to prove `\u2203` statements.\nIf the target is to prove `\u2203 (x : X), P(x)` and if `y : X`, then\n`use y` changes the target to one of proving `P(y)`.\n\n### Example\n\nThe tactic `use 2` can be employed in the first line of the\nproof of $\\exists (m : \\mathbb N) : m ^ 2 + 2 = 3m$. It\nchanges the target to one of proving $2^2 + 2 = 3 \\times 2$.\n\n```\nexample :\n\u2203 (m : \u2115), m ^ 2 + 2 = 3 * m :=\nbegin\n  use 2,\n  show 2 ^ 2 + 2 = 3 * 2,\n  linarith,\nend\n```\n", "example : \u2203 (m : \u2115), m ^ 2 + 2 = 3 * m :=\nbegin\n  use 2,\n  show 2 ^ 2 + 2 = 3 * 2, linarith,\nend\n", "**Theorem**: $\\exists (m : \\mathbb N),\\ (m < 2) \\land (m^2 + 2 = 3 m)$.\n\n**Proof**:\nLet $m$ be $1$. We'll show $(1 < 2) \\land (1 ^ 2 + 2 = 3 \\times 1)$.\nBut\n1. $1 < 2$ by arithmetic and\n2. 1 ^ 2 + 2 = 3 \\times 1 by arithmetic. \u220e\n", "example : \u2203 (m : \u2115), (m < 2) \u2227 (m ^ 2 + 2 = 3 * m) :=\nbegin\n  use 1,\n  show (1 < 2) \u2227 (1 ^ 2 + 2 = 3 * 1),\n  split,\n    show 1 < 2, linarith,\n    show 1 ^ 2 + 2 = 3 * 1, linarith, \nend\n", "namespace exlean -- hide\n", "## Tasks\n\nProve the result below in Lean, via the `use` tactic.\n", "$\\exists (m : \\mathbb N),\\ (m < 5) \\land\n((m ^ 2 + 18 = 9 m) \\lor (m ^ 2 + 35 = 12 m))$\n", "end exlean -- hide", "import predicate_logic.exists_intro2 -- hide\n", "# Predicate logic\n## Level 6: Exists elimination 1\n\nWe've seen how to prove existentially-quantified statements.\nHow do we *use* an existentially-quantified statement?\n\nLet's begin with an informal argument.\n\n**Theorem**: Suppose\n$h : \\exists (m : \\mathbb Z),\\ 32m ^ 5 + 160 m ^ 4 = 5184$.\nThen $\\exists (n : \\mathbb Z),\\ n^5 + 10n^4 = 5184$.\n\n**Proof**: From $h$, we have an integer $x$ such that\n$h_2 : 32 x ^ 5 + 160 x ^ 4$ = 5184$.\n\nTake $n$ to be $2x$. It suffices to prove $(2x)^5 + 10 (2x)^4 = 5184$,\nbut this follows by arithmetic.\n\u220e\n\n", "More formally, the *exists elimination* rule produces a proof\nof a proposition $q$ if it is given a proof of\n$\\exists (x : X), P(x)$ and a proof of\n$\\forall (y : X), (P(y) \\to q)$.\n", "q\n", "We prove the result above using exists elimination. Recall we \nare given $h : \\exists (m : \\mathbb Z),\\ 32m ^ 5 + 160 m ^ 4 = 5184$\nand we are to prove $\\exists (n : \\mathbb Z),\\ n^5 + 10n^4 = 5184$.\n\n**Proof**: We have $h_2 : \\forall (y : \\mathbb Z),\\\n  ( 32 y ^ 5 + 160 y ^ 4 = 5184  \\to\n    \\exists (n : \\mathbb Z), n ^ 5 + 10 n ^ 4 = 5184 )$ as follows:\n> Assume $y : \\mathbb Z$.\n> Assume $h : 32 y ^ 5 + 160 y ^ 4 = 5184$.\n> We must show $\\exists (n : \\mathbb Z), n ^ 5 + 10 n ^ 4 = 5184$. \n> Take $n$ to be $2y$.\n> We must show $(2y)^5 + 10(2y)^4 = 5184$. This follows by\n> arithmetic.\n\nThe result follows by exists elimination on $h$ and $h_2$. \u220e\n\n", "In the proof below, `exists.elim` is the Lean version of the\nexists elimination rule.\n", "example (h : \u2203 (m : \u2124), 32 * m ^ 5 + 160 * m ^ 4 = 5184) :\n\u2203 (n : \u2124), n ^ 5 + 10 * n ^ 4 = 5184  :=\nbegin\n  have h\u2082 : \u2200 (y : \u2124),\n  (32 * y ^ 5 + 160 * y ^ 4 = 5184 \u2192 \u2203 (n : \u2124), n ^ 5 + 10 * n ^ 4 = 5184),\n  { assume y : \u2124,\n    assume h\u2083 : 32 * y ^ 5 + 160 * y ^ 4 = 5184,\n    show \u2203 (n : \u2124), n ^ 5 + 10 * n ^ 4 = 5184,\n    use 2 * y,\n    show (2 * y) ^ 5 + 10 * (2 * y) ^ 4 = 5184, linarith, },\n  from exists.elim h h\u2082,\nend\n", "namespace exlean -- hide\n", "## Tasks\n\nProve the result below in Lean using `exists.elim`.\n", "Let $f : \\mathbb N \\to \\mathbb N$ be a function.\nGiven $h : \\exists (x : \\mathbb N),\\ f(5x) = 10x$, prove\n$\\exists (m : \\mathbb N),\\ f(m) = 2m$.\n", "end exlean -- hide", "import predicate_logic.exists_elim1 -- hide\n", "# Predicate logic\n## Level 7: Exists elimination 2\n\nThe exists elimination rule can be tricky to use. In this level,\nwe introduce a Lean tactic that simulates the informal style\nof proof we showed at the beginning of the previous level.\n\nHere is a theorem statement and an informal proof.\n\n**Theorem**: Let $P$ and $Q$ be predicates on a type $X$.\nSuppose $h : \\exists (x : X), P(x) \\land Q(x)$.\nThen $\\exists (z : X),\\ Q(z)$.\n\n**Proof**: From $h$, we have a term $y : X$ such that\n$h_2 : P(y) \\land Q(y)$.\n\nTake $z$ to be $y$. We must show $Q(y)$. But this follows by\nright and elimination on $h_2$. \u220e\n\n", "In Lean, we decompose a given `\u2203` statement using the `cases`\ntactic (much as we do for `\u2228` statements).\n\nIn the proof below `cases h with x h\u2082` introduces a new\nvariable `x : \u2124` together with a proof\n`h\u2082 : P(y) \u2227 Q(y)`. The optional `given`\nstatement is there to indicate to the reader what `h\u2082` asserts.\n", "variable (X : Type) -- hide\n", "example (P Q : X \u2192 Prop) (h : \u2203 (x : X), P(x) \u2227 Q(x)) :\n\u2203 (z : X), Q(z) :=\nbegin\n  cases h with y h\u2082,\n  given h\u2082 : P(y) \u2227 Q(y),\n  use y,\n  show Q(y), from h\u2082.right,\nend\n", "namespace exlean -- hide\n", "## Tasks\n\nProve the result below in Lean, via the `cases` tactic.\n", "Let $P$ and $Q$ be predicates on a type $X$.\nSuppose $h : \\exists (x : X), P(x) \\land Q(x)$.\nThen $\\exists (z : X),\\ P(z) \\lor Q(z)$.\n", "end exlean -- hide", "import predicate_logic.exists_elim2 -- hide\n", "# Predicate logic\n## Level 8: Extensionality of predicates\n\nConsider the predicates $P$ and $Q$ on the type of natural numbers\ngiven by $P(x) := x < 5$ and $Q(y) := 2y < 10$.\n\nOn the one hand, $P$ and $Q$ are clearly different. They\nhave different meanings. The proposition\n$Q(y)$ involves a multiplication by $2$. The definition of $Q$\nseems to involve a variables $y$ whereas that of $P$ seems to\ninvolve a variable $x$.\n\nBut, on the other hand, $P$ and $Q$ are clearly the same predicate.\nIndeed, for every integer $m$, $P(m)$ holds if and only if\n$Q(m)$ holds.\n\nThe principle of extensionality of predicates asserts that\ntwo predicates $P$ and $Q$ on a type $X$ are equal given that\n$\\forall (x : X),\\ P(x) \\leftrightarrow Q(x)$.\n\nThis principle cannot be *proved*. It is something we accept as\nan axiom.\n", "\nThe `ext` (short for 'extensionality') tactic is used to prove\ntwo mathematical objects are extensionally equal. This is typically\nused for sets, functions, and predicates.\n\n## Example\nSuppose `P` and `Q` are predicates on a type `B`. If the target is\nto prove `P = Q`, then using `ext b` changes the target to one of proving\n`P(b) \u2194 Q(b)`.\n", "Below, we give a Lean proof of the statement above. Initially,\nthe target is to show equality of the predicates `P` and `Q`\n(defined as above).\n\nBy using the `ext` tactic, the target is changed to one of proving\n`(x < 5) \u2194 (2 * x < 10)`, for a newly introduced variable `x : \u2115`.\n", "namespace exlean -- hide\n", "namespace pred_ext1 -- hide\n", "def P(m : \u2115) := m < 5\ndef Q(n : \u2115) := 2 * n < 10\n", "\n", "example :\nP = Q :=\nbegin\n  ext x,\n  show (x < 5) \u2194 (2 * x < 10),\n  split,\n  { assume h : x < 5,\n    show 2 * x < 10, linarith, },\n  { assume h : 2 * x < 10,\n    show x < 5, linarith,  },\nend\n", "end pred_ext1 -- hide\n", "For a more interesting example, let $f : \\mathbb Z \u2192 \\mathbb Z$ be \na function and let $P$ and $Q$ be predicates on $\\mathbb Z$ defined\nby $P(m) := f(m) = 5$ and $Q(n) := 2 = f(n) - 3$. We'll show $P = Q$.\n", "namespace pred_ext2 -- hide\n", "constant f : \u2124 \u2192 \u2124\ndef P(m : \u2124) := f(m) = 5\ndef Q(n : \u2124) := 2 = f(n) - 3\n", "\n", "example : P = Q :=\nbegin\n  ext x,\n  show (f(x) = 5) \u2194 (2 = f(x) - 3),\n  split,\n  { assume h : f(x) = 5,\n    show 2 = f(x) - 3, linarith, },\n  { assume h : 2 = f(x) - 3,\n    show f(x) = 5, linarith,  },\nend\n", "end pred_ext2 -- hide\n", "Extensionality of predicates will feature heavily later in this\ngame when we explore equality of sets.\n\n", "## Tasks\n\nHere, you are given a function $f : \\mathbb N \\to \\mathbb N$ and\nthree predicates on $\\mathbb N$,\n* $P(m) := f(m) = 6$,\n* $Q(n) := f(3n) = 18$, and\n* $R(k) := 3f(k) 18$.\n\nYou are asked to prove $(P = Q) \\lor (P = R)$.\n", "You should first determine whether you think `P = Q` is true of\n`P = R` is true. Then either use the `left` tactic or the\n`right` tactic, respectively.\n", "Starting the proof", "namespace pred_ext3 -- hide\n", "constant f : \u2115 \u2192 \u2115\ndef P(m : \u2115) := f(m) = 6\ndef Q(n : \u2115) := f(3 * n) = 18\ndef R(k : \u2115) := 3 * f(k) = 18\n", "$(P = Q) \\lor (P = R)$.\n", "end pred_ext3 -- hide\n", "end exlean -- hide", "import tactic.modded predicate_logic.pred_extensionality -- hide\n", "# Predicate logic\n## Level 9: Even integers\n\nAs a practical example, define the predicate\n$\\mathsf{even}$ on $\\mathbb Z$ by\n$\\mathsf{even}(n) := \\exists (m : \\mathbb Z),\\ n = 2m$.\n\nTo prove $\\mathsf{even}(10)$ is to prove $\\exists (m : \\mathbb Z),\\ 10 = 2m$.\n\n**Proof**: take $m$ to be $5$. Then indeed $10 = 2 \\times 5$.\n", "Here is a Lean definition of the `even` predicate.\n", "namespace exlean -- hide\n", "def even (n : \u2124) := \u2203 (m : \u2124), n = 2 * m\n", "In the Lean proof below, I use the slightly odd construction\n`(10 : \u2124) = 2 * 5` rather than `10 = 2 * 5`. This is to ensure\nLean inteprets the quantities as integers rather than as\nnatural numbers.\n", "example : even(10) :=\nbegin\n  use 5,\n  show (10 : \u2124) = 2 * 5, linarith,\nend\n", "**Theorem**: for all integers $n$, if $n$ is even, then $4n$ is even.\n\nMore formally, we are to prove\n$\\forall (n : \\mathbb Z),\\ \\mathsf{even}(n) \\to \\mathsf{even}(4n)$.\n\n**Proof**: Assume $n : \\mathbb Z$. Assume $h : \\mathsf{even}(n)$.\nThat is, $h : \\exists (m : \\mathbb Z),\\ n = 2m$.\nDecomposing this we have $x : \\mathbb Z$ for which $h_2 : n = 2x$.\nWe must show $\\mathsf{even}(4n)$. That is, $\\exists (m : \\mathbb Z),\\ 4n = 2m$.\nTake $m$ to be $4x$. We must show $4n = 2(4x)$.\nBy $h_2$, we must show $4(2x) = 2(4x)$. This holds by arithmetic.\n", "example : \u2200 (n : \u2124), even(n) \u2192 even(4 * n) :=\nbegin\n  assume n : \u2124,\n  assume h : even(n),\n  given h : \u2203 (m : \u2124), n = 2 * m,\n  cases h with x h\u2082,\n  given h\u2082 : n = 2 * x,\n  show \u2203 (m : \u2124), 4 * n = 2 * m, \n  use 4 * x,\n  rw h\u2082,\n  show 4 * (2 * x) = 2 * (4 * x), linarith,\nend\n", "## Task\n\nProve the result below in Lean, adapting the proof above.\n", "$\\forall (n : \\mathbb Z),\\ \\mathsf{even}(n) \\to \\mathsf{even}(n ^ 2)$.\n", "end exlean -- hide", "import predicate_logic.even1 -- hide\n", "# Predicate logic\n## Level 10: Multiple quantifiers 1\n\nMany statements in mathematics involve more than one quantifier.\nThe commutitivity of addition of natural numbers can be stated\nas\n$\\forall (m : \\mathbb N),\\ \\forall (n : \\mathbb N),\\ m + n = n + m$.\n", "Statements such as this are to be read from left-to-right.\nIf we let $P$ be the predicate on $\\mathbb N$ given by\n$P(m) := \\forall (n : \\mathbb N),\\ m + n = n + m$, then\nthe above statement can be shortened to\n$\\forall (m : \\mathbb N),\\ P(m)$.\n\n", "**Theorem**: Let $P$ and $Q$ be predicates on a type $X$. Suppose\n$h : \\forall (x : X), \\forall (y : X),\\ P(x) \\land Q(y)$.\nThen $\\forall (m : X), \\forall (n : X),\\ Q(n) \\land P(m)$.\n\n**Proof**: Assume $m : X$ and $n : X$.\nWe have $h_2 : P(m) \\land Q(n)$ by $h$ specialised at $m$ and $n$.\nWe must show $Q(n) \\land P(m)$. By commutativity of $\\land$, this\nis the same as proving $P(m) \\land Q(n)$, which follows from $h_2$. \u220e\n\n", "variable (X : Type)\nexample (P Q : X \u2192 Prop)\n(h : \u2200 (x : X), \u2200 (y : X), P(x) \u2227 Q(y)) :\n\u2200 (m : X), \u2200 (n : X), Q(n) \u2227 P(m) :=\nbegin\n  assume (m n : X),\n  have h\u2082 : (P m) \u2227 (Q n), from h m n,\n  show Q(n) \u2227 P(m),\n  rw and_comm,\n  show P(m) \u2227 Q(n), from h\u2082,\nend\n", "The proof above uses for all introduction and for all elimination.\nA more natural proof uses propositional extensionality to rewrite\nthe commutativity of $\\land$ through the universal quantifier.\n\nAgain, we'll prove that\n$\\forall (m : X), \\forall (n : X),\\ Q(n) \\land P(m)$ follows from\n$h : \\forall (x : X), \\forall (y : X),\\ P(x) \\land Q(y)$.\n\n**Proof**: By commutativity of $\\land$, it suffices to prove\n$\\forall (m : X), \\forall (n : X),\\ P(m) \\land Q(m)$. This follows\nfrom $h$. \u220e\n\nIn Lean, we use the `simp` tactic to rewrite through\nquantifiers, as below.\n", "example (P Q : X \u2192 Prop)\n(h : \u2200 (x : X), \u2200 (y : X), P(x) \u2227 Q(y)) :\n\u2200 (m : X), \u2200 (n : X), Q(n) \u2227 P(m) :=\nbegin\n  simp [and_comm],\n  show \u2200 (m : X), \u2200 (n : X), P(m) \u2227 Q(n), from h,\nend\n", "namespace exlean -- hide\n", "## Tasks\n1. Prove the result below in the style of the first proof above.\n2. Prove the result below using `simp` to rewrite through\nthe quantifiers.\n\n", "Suppose $P$ and $Q$ are predicates on a type $X$. \nSuppose $h : \\forall (x : X),\\ \\forall (y : X),\\ P(x) \\land Q(y)$.\nThen $\\forall (m : X),\\ \\forall (n : X),\\ Q(n) \\lor P(m)$.\n", "end exlean -- hide", "import predicate_logic.multiple_quantifiers1 -- hide\n", "# Predicate logic\n## Level 11: Multiple quantifiers 2\n\n", "**Theorem**: $\\forall (x : \\mathbb Z), \\exists (y : \\mathbb Z),\\ x = y + 5$.\n\n**Proof**: Assume $x : \\mathbb Z$. Take $y$ to be $x - 5$.\nIt remains to show $x = (x - 5) + 5$, but this holds by arithmetic. \u220e\n\nThe handwritten proof above translates easily to a Lean proof.\n", "example : \u2200 (x : \u2124), \u2203 (y : \u2124), x = y + 5 :=\nbegin\n  assume x : \u2124,\n  use (x - 5),\n  show x = (x - 5) + 5, linarith,\nend\n", "namespace exlean -- hide\n", "## Tasks\nProve the result below.\n\n", "Show that\n$\n\\forall (m : \\mathbb Z),\\ \\exists (n : \\mathbb Z),\\ m n + n - 1 = m (m + 2)\n$\n", "end exlean -- hide", "import predicate_logic.multiple_quantifiers2 -- hide\n", "# Predicate logic\n## Level 12: Multiple quantifiers 3\n\n", "**Theorem**: $\\exists (x : \\mathbb N),\\ \\exists (y : \\mathbb N),\\\n x^2 + 3xy + 66 = 4 y ^2$.\n\nFor the proof below, it isn't relevant *how* you find $x$ and $y$\nsuch that the above equation is satisfied. \n", "\nThough it's not relevant at this stage of your mathematical journey,\none way to find solutions to this equation is to treat the\nequation as a quadratic in $x$ and to solve for $x$ in terms of $y$.\nAs we are looking for natural number solutions, we require the\ndiscriminant of the equation to be a perfect square. In this case,\nthat means you need $25y^2 - 264 = m^2$, for some integer $m$.\nThere are only finitely many solutions to this equation amongst\nthe integers.\n", "But how do I find the solutions?", "\n**Proof**: Take $x$ to be $2$. Take $y$ to be $5$. We must\nshow $2^2 + 3 \\times 2 \\times 4 + 66 = 4 \\times 5 ^2 $.\nBut this holds by arithmetic. \u220e\n\nBelow is a Lean proof of this result.\n", "example :\n\u2203 (x : \u2115), \u2203 (y : \u2115), x ^ 2 + 3 * x * y + 66 = 4 * y ^ 2 :=\nbegin\n  use 2,\n  use 5,\n  show 2 ^ 2 + 3 * 2 * 5 + 66 = 4 * 5 ^ 2, linarith,\nend\n", "namespace exlean -- hide\n", "## Tasks\nProve the result below. In this case, there are infinitely many\nsolutions for $x$ and $y$. You just need to find one solution.\n\n", "Show that\n$\\exists (x : \\mathbb N),\\ \\exists (y : \\mathbb N),\\\n x  y + 21 = 7  x + 3  y$.\n", "end exlean -- hide", "import predicate_logic.multiple_quantifiers3 -- hide\n", "# Predicate logic\n## Level 13: Multiple quantifiers 4\n\n", "**Theorem**: $\\exists (x : \\mathbb Z),\\ \\forall (y : \\mathbb Z),\\\n x + y = y$.\n\n**Proof**: Take $x$ to be $0$. We must show\n$\\forall (y : \\mathbb Z),\\ 0 + y = y$.\nAssume $y : \\mathbb Z$. We must show $0 + y = y$.\nBut this holds by arithmetic. \u220e\n\nBelow is a Lean proof of this result.\n", "example : \u2203 (x : \u2124), \u2200 (y : \u2124), x + y = y :=\nbegin\n  use 0,\n  assume y : \u2124,\n  show 0 + y = y, linarith,\nend\n", "namespace exlean -- hide\n", "## Tasks\nProve the result below.\n\n", "Show that\n$\\exists (x : \\mathbb Z),\\ \\forall (y : \\mathbb Z),\\\n (y - 1)^2 = y^2 - xy + 1$.\n", "end exlean -- hide", "import tactic.modded predicate_logic.multiple_quantifiers4 -- hide\n", "# Predicate logic\n## Level 14: Even integers 2\n\n", "## Task\n\nProve the result below in Lean.\n", "namespace exlean -- hide\n", "$\\exists (a : \\mathbb Z),\\ \\forall (b : \\mathbb Z),\\ \\mathsf{even}(ab)$.\n", "end exlean -- hide", "import predicate_logic.multiple_quantifiers4 -- hide\n", "# Predicate logic\n## Level 15: Negating quantifiers 1\n\n", "As we'll soon see, the proposition $\\neg (\\forall (x : X),\\ P(x))$\nis equal (materially equivalent to) the proposition\n$\\exists (x : X),\\ \\neg P(x)$.\n\nLikewise, the proposition $\\neg (\\exists (x : X),\\ P(x))$ is equal\nto the proposition $\\forall (x : X),\\ \\neg P(x)$.\n\n**Theorem**: Prove that $\\neg (\\forall (x : \\mathbb N),\\ x + 2 = 5)$.\n\nIn words, we'll prove it's not the case that for every natural\nnumber $x$, $x + 2 = 5$.\n\n**Proof**: We must show $\\exists (x : \\mathbb N),\\ \\neg(x + 2 = 5)$.\nThat is, to show $\\exists (x : \\mathbb N),\\ x + 2 \\ne 5$.\n\nTake $x$ to be $0$. We must show $0 + 2 \\ne 5$. This holds by\narithmetic. \u220e\n", "In the Lean proof below, `push_neg` is the tactic that converts the\nnegation of a universally quantified statement into an \nexistentially quantified statement.\n\nThe symbol `\u2260` is typed `\\ne`.\n", "\nThe `push_neg` tactic 'pushes' negations inside\nquantifiers. For example, it changes a target `\u2200 (x : X), P(x)`\ninto `\u2203 (x : X), \u00acP(x)`. If `P(x)` is itself a quantified\nstatement, then `push_neg` will recursively push the negation\ninto `P(x)`.\n\nThus, `push_neg` converts `\u00ac(\u2200 (x : X), \u2203 (y : Y), P x y)` into\n`\u2203 (x : X), \u2200 (y : Y), \u00ac(P x y)`.\n", "example : \u00ac(\u2200 (x : \u2115), x + 2 = 5) :=\nbegin\n  push_neg,\n  show \u2203 (x : \u2115), x + 2 \u2260 5,\n  use 0,\n  show 0 + 2 \u2260 5, linarith,\nend\n", "namespace exlean -- hide\n", "## Tasks\nProve the result below. Remember that `\u2260` is typed as `\\ne`.\n\n", "$\\neg(\\forall (x : \\mathbb N),\\ x ^ 2 + 2  x = 3  x)$.\n", "end exlean -- hide", "import predicate_logic.negating_quantifiers -- hide\n", "# Predicate logic\n## Level 16: Negating quantifiers 2\n\n", "\n**Theorem**: Prove that $\\neg (\\exists (x : \\mathbb N),\\ x + 2 = 0)$.\n\nIn words, we'll prove it's not the case that there exists a natural\nnumber $x$ such that $x + 2 = 0$.\n\n**Proof**: We must show $\\forall (x : \\mathbb N),\\ x + 2 \\ne 0$.\nAssume $x : \\mathbb N$. We must show $x + 2 \\ne 0$. \nThis holds by arithmetic. \u220e\n", "example : \u00ac(\u2203 (x : \u2115), x + 2 = 0) :=\nbegin\n  push_neg,\n  show \u2200 (x : \u2115), x + 2 \u2260 0,\n  assume x : \u2115,\n  show x + 2 \u2260 0, linarith,\nend\n", "namespace exlean -- hide\n", "## Tasks\nProve the result below. Remember that `\u2260` is typed as `\\ne`.\n\n", "$\\neg (\\exists (x : \\mathbb N),\\ 2x = 4x + 1)$.\n", "end exlean -- hide", "import predicate_logic.negating_quantifiers2 -- hide\n", "# Predicate logic\n## Level 17: Negating quantifiers 3\n\n", "\n**Theorem**: Prove that\n$\\neg (\\exists (x : \\mathbb N),\\ \\forall (y : \\mathbb N),\\ xy = x + y)$.\n\nIn proving this theorem, we need to push the negation through two\nquantifiers. After pushing the negation through the existential quantifier,\nthe target is to prove\n$\n\\forall (x : \\mathbb N),\\ \\neg(\\forall (y : \\mathbb N),\\ xy = x + y).\n$\n\nWe then push the negation through the inner quantifier, making the\ntarget\n$\n\\forall (x : \\mathbb N),\\ \\exists (y : \\mathbb N),\\ xy \\ne x + y).\n$\n\n**Proof**: We must show\n$\\forall (x : \\mathbb N),\\ \\exists (y : \\mathbb N),\\ xy \\ne x + y$.\nAssume $x : \\mathbb N$. We must show\n$\\exists (y : \\mathbb N),\\ xy \\ne x + y$. Take $y$ to be $1$. We\nmust show $x\\times 1 \u2260 x + 1$. This holds by arithmetic. \u220e\n", "example : \u00ac(\u2203 (x : \u2115), \u2200 (y : \u2115), x * y = x + y) :=\nbegin\n  push_neg,\n  show \u2200 (x : \u2115), \u2203 (y : \u2115), x * y \u2260 x + y,\n  assume x : \u2115,\n  show \u2203 (y : \u2115), x * y \u2260 x + y,\n  use 1,\n  show x * 1 \u2260 x + 1, linarith,\nend\n", "namespace exlean -- hide\n", "## Tasks\nProve the result below.\n\n", "example : \u00ac(\u2203 (x : \u2115), \u2200 (y : \u2115), 3 * x * y = x * (y^2) + y) :=\nbegin\n  push_neg,\n  assume x : \u2115,\n  use 3,\n  linarith,\nend\n", "$\\neg (\\exists (x : \\mathbb N),\\ \\forall (y : \\mathbb N),\\ 3xy = xy^2 + y)$.\n", "end exlean -- hide", "import tactic.no_push_neg --hide\n", "# Predicate logic\n## Level 18: Negating quantifiers theorem 1\n\nThe next few levels are for the experts. We'll prove the equivalences\n* $\\neg (\\forall (x : X),\\ P(x)) \\leftrightarrow \\exists (x : X),\\ \\neg P(x)$ and\n* $\\neg (\\exists (x : X),\\ P(x)) \\leftrightarrow \\forall (x : X),\\ \\neg P(x)$.\n\n", "namespace exlean -- hide\n", "## Tasks\nProve the result below. You cannot use `push_neg` for this level.\n\n", "Recall that if `h\u2081 : p` and `h\u2082 : \u00acp`, then `h\u2082 h\u2081` is a proof of\n`false`.\n\nAlternatively, remember that `absurd h\u2081 h\u2082` gives a proof of anything.\n", "Proving `false`", "variable (X : Type) -- hide\n", "$(\\forall (x : X),\\ \\neg P(x)) \\to \\neg(\\exists (x : X),\\ P(x))$.\n", "end exlean -- hide", "import predicate_logic.negating_quantifiers_thm1 --hide\n", "# Predicate logic\n## Level 19: Negating quantifiers theorem 2\n\n", "namespace exlean -- hide\n", "## Tasks\nProve the result below. You cannot use `push_neg` for this level.\n\n", "\nSuppose the context contains `h : \u00acp`, for some proposition `p`.\nSuppose also that the target is to prove `false`.\nAs `h : p \u2192 false`, it suffice to prove `p` and then use\nimplication elimination.\n\nRecall that Lean permits an (easier?) backward version of\nimplication elimination. By typing `apply h`, you change the\ntarget to one of proving `p`.\n", "Using negated hypotheses", "variable (X : Type) -- hide\n", "$\\neg(\\exists (x : X),\\ P(x)) \\to (\\forall (x : X),\\ \\neg P(x))$.\n", "end exlean -- hide", "import predicate_logic.negating_quantifiers_thm2 -- hide\n", "# Predicate logic\n## Level 20: Negating quantifiers theorem 3\n", "namespace exlean -- hide\n", "## Tasks\nProve the result below. You cannot use `push_neg` in this level.\n\n", "\nAt some point in your proof, you will have introduced an\nexistentially-quantified statement into the context.\nRemember that you can decompose such a statement using the `cases`\ntactic.\n", "Dealing with the existentially-quantified statement", "variable (X : Type) -- hide\n", "$\\exists (x : X),\\ \\neg P(x) \\to \\neg(\\forall (x : X),\\ P(x))$.\n", "end exlean -- hide", "import predicate_logic.negating_quantifiers_thm3 tactic.localized --hide\n", "# Predicate logic\n## Level 21: Negating quantifiers theorem 4\n\n", "namespace exlean -- hide\n", "## Tasks\nProve the result below. You cannot use `push_neg` for this level.\nThis level is somewhat challenging!\n\n", "\nAfter doing the natural first step when proving an implication, I\nsuggest doing a proof by contradiction using `by_contra h\u2082`.\nDo the obvious things until you get stuck. At some point, you'll\nneed to use contradiction again.\n", "The structure of the proof.", "variable (X : Type) -- hide\n", "open_locale classical -- hide\n", "$\\neg(\\forall (x : X),\\ P(x)) \\to \\exists (x : X),\\ \\neg P(x)$.\n", "end exlean -- hide", "Sets", "import tactic.modded  tactic.linarith -- hide\n", "# Sets\n## Level 1: Set membership\n\nA set on a type $X$ is simply a predicate on that type.\n\nLet's define predicates $\\mathsf{even}$ and $\\mathsf{even}'$ on\n$\\mathbb Z$ by\n$\\mathsf{even}(n) := \\exists(m : \\mathbb Z),\\ n = 2 m$ and\n$\\mathsf{even}'(n) := \\exists(m : \\mathbb Z),\\ n + 4 = 2 m$.\n\nThen $\\mathsf{even}$ and $\\mathsf{even}'$ can be seen as sets\nof elements of type $\\mathbb Z$.\n\nWe write $10 \\in \\mathsf{even}$ (for instance) as a synonym for\n$\\mathsf{even}(10)$. More generally, $x \\in P$ is a synonym for\n$P(x)$ (given that $P$ is a predicate on a type $X$ and that $x : X$).\n\nHere's a proof of $10 \\in \\mathsf{even}$.\n\n**Proof**: We must show $\\mathsf{even}(10)$, namely that\n$\\exists(m : \\mathbb Z),\\ 10 = 2m$. Take $m$ to be $5$. Then\n$10 = 2 \\times 5$ follows by arithmetic.\n", "In Lean, we define sets much as we define predicates. The only\ndifference between the following defintion and the definition of\na predicate is the use of `set \u2124` in place of `\u2124 \u2192 Prop`.\n", "namespace exlean -- hide\n", "namespace even_sets -- hide\n", "def even : set \u2124 := \u03bb n, \u2203 (m : \u2124), n = 2 * m\n", "-- hide\n", "def even' : set \u2124 := \u03bb n, \u2203 (m : \u2124), n + 4 = 2 * m\n", "In Lean, `\u2208` is typed `\\in`. Here is a Lean proof that `10 \u2208 even`.\nNote that I have to type `(10 : \u2124)` so Lean knows I'm working with the\ninteger `10` rather than the natural number `10`.\n", "example : (10 : \u2124) \u2208 even :=\nbegin\n  show \u2203 (m : \u2124), 10 = 2 * m,\n  use 5,\n  show (10 : \u2124) = 2 * 5, linarith,\nend\n", "## Task\nProve that $10 \\in \\mathsf{even}'$, with $\\mathsf{even}'$ defined\nas above.\n", "$10 \\in \\mathsf{even}'$.\n", "end even_sets -- hide\n", "end exlean -- hide", "import sets.set_membership -- hide\n", "# Sets\n## Level 2: Equality of sets\n\nFrom the previous level, recall the definitions of the \nsets $\\mathsf{even}$ and $\\mathsf{even}'$ on\n$\\mathbb Z$ by\n$\\mathsf{even}(n) := \\exists(m : \\mathbb Z),\\ n = 2 m$ and\n$\\mathsf{even}'(n) := \\exists(m : \\mathbb Z),\\ n + 4 = 2 m$.\n\nRecall that for two predicates $P$ and $Q$ on a type $X$ to be\nequal means that $\\forall(x : X),\\ P(x) \\leftrightarrow Q(x)$.\nThis is the principle of extensionality of predicates.\n\nViewed as sets, $P = Q$ means\n$\\forall(x : X),\\ x \\in P \\leftrightarrow x \\in Q$.\n\nI claim that $\\mathsf{even} = \\mathsf{even}'$.\n\nHere's a sketch proof of the result.\n\n**Proof**:\nBy extensionality, we must show\n$\n\\forall (x : \\mathbb Z),\\ x \\in \\mathsf{even} \\leftrightarrow x \\in \\mathsf{even}'.$\n\nAssume $x : \\mathbb Z$. It suffices to show\n$x \\in \\mathsf{even} \\to x \\in \\mathsf{even}'$ and\n$x \\in \\mathsf{even}' \\to x \\in \\mathsf{even}$.\n\nFor the first of these, assume $h : x \\in \\mathsf{even}$.\nThen we have $k : \\mathbb Z$ such that $h_2 : x = 2 k$.\nWe must show $x \\in \\mathsf{even}'$. That is, that\n$\\exists(m : \\mathbb Z),\\ x + 4 = 2m$. Takes $m$ to be $k + 2$.\nWe must show $x + 4 = 2(k + 2)$. This holds by arithmetic.\n\nThe remaining part of the proof is left to the reader.\n", "namespace exlean -- hide\n", "namespace even_sets -- hide\n", "## Task\nBelow, I have given one direction of the proof that `even = even'`.\nIn particular, I have proved `even x \u2192 even' x` (for a given `x : \u2124`).\nYour task is to replace `sorry` with a proof that `even' x \u2192 even x`.\n", "$\\mathsf{even} = \\mathsf{even}'$.\n", "end even_sets -- hide\n", "end exlean -- hide", "import sets.even_even -- hide\n", "# Sets\n## Level 3: Set constructor notation\n\nLet $S$ be a predicate on a type $X$. Thus $S$ can be viewed\nas a set of elements of type $X$. It is common to represent the\nset $S$ via the 'set constructor' notation as\n$\\\\{x : X \\mid S(x)\\\\}$. \n\nHere, for example, is an definition, using set constructor notation,\nof the set of even integers.\n$T := \\\\{n : \\mathbb Z \\mid \\exists(m : \\mathbb Z),\\ n = 2m \\\\}$.\n", "namespace exlean -- hide\n", "Let's show that $6 \\in T$.\n\n**Proof**: by definition, we must show $\\exists (m : \\mathbb Z),\\\n6 = 2m$. Take $m$ to be $3$. We show $2 = 2 \\times 3$ by \narithmetic. \u220e\n", "Below is the proof of this result in Lean. Note the use\nof `(6 : \u2124)` to let Lean know we're working with the integer `6`\nand not the natural number `6`.\n", "example : (6 : \u2124) \u2208 {n : \u2124 | \u2203 (m : \u2124), n = 2 * m} :=\nbegin\n  show \u2203 (m : \u2124), 6 = 2 * m,\n  use 3,\n  show (6 : \u2124) = 2 * 3, linarith,\nend\n", "## Task\nAdapt the proof above to show that the integer $7$ belongs to the set\n$\\\\{n : \\mathbb Z \\mid \\exists(m : \\mathbb Z),\\ n + 1 = 2m + 4\\\\}$.\n", "$7\\in\\\\{n : \\mathbb Z \\mid \\exists(m : \\mathbb Z),\\ n + 1 = 2m + 4\\\\}$.\n", "end exlean -- hide", "import sets.set_constructor  -- hide\n", "# Sets\n## Level 4: Finite sets\n\nThe set of natural numbers represented by $\\\\{1, 3, 7\\\\}$\nis the predicate $S$ on $\\mathbb N$ given by\n$S(x) := (x = 1) \\lor (x = 3) \\lor (x = 7)$.\n\nLikewise, the set $\\\\{3, 7, 3, 1\\\\}$ is the predicate $T$ on\n$\\mathbb N$ given by\n$T(x) := (x = 3) \\lor (x = 7) \\lor (x = 3) \\lor (x = 1)$.\n\nClearly, $\\forall(x : X),\\ x \\in S \\leftrightarrow x \\in T$. Thus,\n$S$ and $T$ are equal. \n", "namespace exlean -- hide\n", "In Lean, we use `finset` to define finite sets.\n", "namespace finset_test1 -- hide\n", "def S : finset \u2115 := {1, 3, 7}\n", "-- hide\n", "def T : finset \u2115 := {3, 7, 3, 1}\n", "Results that can be proved trivially by applying an algorithm (decidability) are proved in Lean\nusing `dec_trivial`. We can prove `S = T` using `dec_trivial`.\n", "If Lean knows that a given statement is 'decidable' (that is, it is given an algorithm for\ndetermining whether the statement is true or false), then `dec_trivial` can be used to prove the\ntheorem.\n", "example : S = T :=\nbegin\n  dec_trivial,\nend\n", "end finset_test1  -- hide\n", "## Task\nProve that two of the sets below are equal.\n", "namespace finset_test2 -- hide\n", "def S : finset \u2115 := {3, 2, 3, 5}\n", "-- hide\n", "def T : finset \u2115 := {2, 5, 1, 3}\n", "-- hide\n", "def U : finset \u2115 := {2, 5, 3, 5}\n", "$((S = T) \\lor (S = U)) \\lor (T = U)$.\n", "end finset_test2 -- hide\n", "end exlean -- hide", "import sets.finite_sets  -- hide\n", "# Sets\n## Level 5: The size of finite sets\n\nLet $S$ be a set on a type $X$. For a natural number $n$ to be the *size* of\n$S$ means that $n$ is the smallest natural number for which $S$ can be\nexpressed as $\\\\{a_1, \\dots, a_n\\\\}$. We write $|S|$ for the size of $S$. \n\nFor example, the size of the set $\\\\{1, 3, 4, 3, 1\\\\}$ of integers is $3$\nas the set can be expressed as $\\\\{1, 3, 4\\\\}$ but as no smaller set.#check\n\nIn Lean, the size (more formally called the *cardinality*) of a finite set `S`\nis denoted by `card S`.\n", "namespace exlean -- hide\n", "Equations involving cardinalities of sets can be proved trivially by\ndecidability, as below.\n", "namespace finset_test3 -- hide\n", "def S : finset \u2115 := {1, 3, 7}\n", "-- hide\n", "open finset -- hide\n", "example : \u2203 (m : \u2115), card S = m :=\nbegin\n  use 3,\n  dec_trivial,\nend\n", "end finset_test3  -- hide\n", "## Task\nFind the cardinality of the given set.\n", "namespace finset_test4 -- hide\n", "open finset -- hide\n", "def S : finset \u2115 := {3, 2, 3, 5, 1, 2, 7, 5}\n", "Given $S = \\\\{3, 2, 3, 5, 1, 2, 7, 5\\\\}$,\n$\\exists (m : \\mathbb N),\\ |S| = m$.\n", "end finset_test4 -- hide\n", "end exlean -- hide", "import sets.finite_sets_cardinality  -- hide\n", "# Sets\n## Level 6: The empty set\n\nGiven a type $X$, the empty set on $X$, denoted $\\varnothing$, is the set\ndefined so that $x \\in \\varnothing$ means $\\bot$.\n\nEqually, $\\varnothing$ can be viewed as the predicate $\\varnothing : X \\to \\mathsf{Prop}$\ndefined by $\\varnothing(x) := \\bot$.\n", "namespace exlean -- hide\n", "This definition gives rise to the interesting fact that, for any predicate $P$, the proposition\n$P(x)$ is *always* true on the assumption that $x \\in \\varnothing$.\n\n**Theorem**: Let $X$ be a type and let $P$ be a predicate on $X$. Then\n$\\forall (x : X),\\ x \\in \\varnothing \\to P(x)$.\n\n**Proof**: Assume $x : X$. Assume $h : x \\in \\varnothing$. But this just means\n$h : \\bot$. From false elimination on $h$, we show $P(x)$. \u220e\n", "Below is a Lean proof of the result. In Lean, we must specify the type of the empty set.\nHere, we are concerned with `\u2205 : set X`, the empty set of elements of type `X`.\n\nThe symbol `\u2205` is typed `\\empty`.\n", "variables {X : Type*} {P : X \u2192 Prop} -- hide\n", "\u2200 (x : X), x \u2208 (\u2205 : set X) \u2192 P(x)\n", "lemma vacuous_truth : \u2200 (x : X), x \u2208 (\u2205 : set X) \u2192 P(x) :=\nbegin\n  assume x : X,\n  assume h : x \u2208 \u2205,\n  given h : false,\n  from false.elim h,\nend\nnamespace empty_set1\n", "As another example, let $S$ be the set of natural numbers defined by\n$S := \\\\{ n : \\mathbb N \\mid n < 0 \\\\}$. We'll show that $S = \\varnothing$.\n\n**Proof**: We must show (by extensionality), that given $n : \\mathbb N$,\n$n \\in S \\leftrightarrow n \\in \\varnothing$.\n\nThat is, we must show both $n \\in S \\to n \\in \\varnothing$ and\n$n \\in \\varnothing \\to n\\in S$.\n\n1. Assume $h : n \\in S$. That is, $h : n < 0$. This gives false, by arithmetic.\n2. Assume $h : n \\in \\varnothing$. That is, $h : \\bot$.\nWe show $n \\in S$ by false elimination on $h$. \u220e\n", "This can be proved in Lean as follows.\n", "def S : set \u2115 := {n : \u2115 | n < 0}   \n", "-- hide\n", "lemma empty_S : S = \u2205 :=\nbegin\n  ext n,\n  show n \u2208 S \u2194 n \u2208 \u2205, \n  split,\n  { show n \u2208 S \u2192 n \u2208 \u2205,\n    assume h : n \u2208 S,\n    given h : n < 0,\n    show false, linarith, },\n  { show n \u2208 \u2205 \u2192 n \u2208 S,\n    assume h : n \u2208 \u2205,\n    given h : false,\n    show n \u2208 S, from false.elim h, },\nend\n", "## Task\nSuppose $S$ is the set of natural numbers given by $S := \\\\{ n : \\mathbb N \\mid n < 0 \\\\}$.\nUsing the two theorems given above, prove \n$\\forall (x : \\mathbb N),\\ x \\in S \\to x = 5$.\n", "\nA good starting point is to rewrite the theorem statement using one of the results given\nin this level.\n\nYou should be able to complete the proof using one more line.\n", "Starting the proof", "$\\forall (x : \\mathbb N)\\, x \\in S \\to x = 5$.\n", "end empty_set1\n", "end exlean -- hide", "import sets.empty_set  -- hide\n", "# Sets\n## Level 7 : Subsets\n\nLet $S$ and $T$ be sets on a type $X$. For $S$ to be a subset of $T$,\nwritten $S \\subseteq T$, means\n$\\forall (x : X), x \\in S \\to x \\in T$.\n\nThis is abbreviated to $\\forall x \\in S, x \\in T$.\n", "namespace exlean -- hide\n", "**Theorem** [Reflexivity of subset]:\nLet $X$ be a type and let $S$ be a set on $X$. Then $S \\subseteq S$.\n\n**Proof**: We must show $\\forall (x : X), x \\in S \\to x \\in S$.\nAssume $x : X$. Assume $h : x \\in S$. We show $x \\in S$, from $h$. \u220e\n", "In Lean, we write `\u2286` as `\\sub`. Below, we prove reflexivity of `\u2286` in Lean.\n", "variable {X : Type*} -- hide\n", "S \u2286 S\n", "lemma subset_rfl {S : set X} : S \u2286 S :=\nbegin\n  show \u2200 x \u2208 S, x \u2208 S,\n  assume x : X,\n  assume h : x \u2208 S,\n  show x \u2208 S, from h,\nend\n", "Above we *proved* a subset result. Let's now *use* subset assumptions to prove\nanother result. The result we're interested in is 'antisymmetry' of the subset relation.\nThat is, on the assumptions that $h_1 : S \\subseteq T$ and $h_2 : T \\subseteq S$, we'll prove $S = T$.\n\n**Proof**: We must show $S = T$. That is, we must show $x \\in S \\leftrightarrow x \\in T$\n(given $x : X$). This requires proving each direction of the double implication.\n\n1. We'll show $x \\in S \\to x \\in T$. Assume $h : x \\in S$. We show $x \\in T$ from $h_1$ and $h$.\n2. We'll show $x \\in T \\to x \\in S$. Assume $h : x \\in T$. We show $x \\in S$ from $h_2$ and $h$.\n\u220e\n\nIn the proof above, our 'from $h_1 : S \\subseteq T$ and $h : x \\in S$ is a combination of\nfor all elimination and implication elimination. The same idiom is accessible in the Lean proof below.\n", "S = T \n", "theorem subset_antisymm {S T : set X} (h\u2081 : S \u2286 T) (h\u2082 : T \u2286 S) : S = T :=\nbegin\n  ext x,\n  show x \u2208 S \u2194 x \u2208 T,\n  split,\n  { show x \u2208 S \u2192 x \u2208 T,\n    assume h : x \u2208 S,\n    show x \u2208 T, from h\u2081 h, },\n  { show x \u2208 T \u2192 x \u2208 S,\n    assume h : x \u2208 T,\n    show x \u2208 S, from h\u2082 h, }\nend\n", "## Task\nProve the transitivity of $\\subseteq$. That is, given sets $S$, $T$, and $U$\non a type $X$, prove that if $S \\subseteq T$ and $T \\subseteq U$, then $S \\subseteq U$.\n\nYou may draw inspiration from parts of the proof of antisymmetry.\n", "Given sets $S$, $T$, and $U$\non a type $X$, one has $S \\subseteq T$ and $T \\subseteq U$, then $S \\subseteq U$.\n", "end exlean -- hide", "import sets.subset -- hide\n", "# Sets\n## Level 8 : Intersection and Union\n\n### Intersection\n\nLet $S$ and $T$ be sets on a type $X$. The *intersection* of $S$ and $T$, written $S \\cap T$, is the set\n$\\\\{x : X \\mid (x \\in S) \\land (x \\in T) \\\\}$.\n", "namespace exlean -- hide\n", "**Theorem** [Commutativity of intersection]:\nLet $X$ be a type and let $S$ and $T$ be sets on $X$. Then $S \\cap T = T \\cap S$.\n\n**Proof**: We must show $x \\in S \\cap T \\leftrightarrow x \\in T \\cap S$, given $x : X$.\nWe prove this by calculation.\n\\begin{align}\nx \\in S \\cap T  &\\leftrightarrow (x \\in S) \\land  (x \\in T) & & \\text{[by definition]} \\\\\\\\\n&\\leftrightarrow (x \\in T) \\land  (x \\in S)& &\\text{[by logic]} \\\\\\\\\n&\\leftrightarrow  x \\in S \\cap T.  & &\\text{[by definition]}\n\\end{align} \u220e\n", "In Lean, we write `\u2229` as `\\i`. Below, we prove commutativity of `\u2229`. \nWe use the Lean tactic `tauto!`, which proves any result in propositional logic.\n", "Proves any result in propositional logic.\n", "variable {X : Type*} -- hide\n", "lemma inter_comm (S T : set X) : S \u2229 T = T \u2229 S :=\nbegin\n  ext x,\n  show x \u2208 S \u2229 T \u2194 x \u2208 T \u2229 S,\n  calc x \u2208 S \u2229 T \u2194 (x \u2208 S) \u2227 (x \u2208 T)    : by refl\n    ... \u2194  (x \u2208 T) \u2227 (x \u2208 S)  : by tauto!\n    ... \u2194 x \u2208 T \u2229 S           : by refl\nend\n", "### Union\n\nLet $S$ and $T$ be sets on a type $X$. The *union* of $S$ and $T$, written $S \\cup T$, is the set\n$\\\\{x : X \\mid (x \\in S) \\lor (x \\in T) \\\\}$.\n", "In Lean, we write `\u222a` as `\\un`. Below is a Lean proof of the commutativity of union.\n", "lemma union_comm (S T : set X) : S \u222a T = T \u222a S :=\nbegin\n  ext x,\n  show x \u2208 S \u222a T \u2194 x \u2208 T \u222a S,\n  calc\n  x \u2208 S \u222a T \u2194 (x \u2208 S) \u2228 (x \u2208 T)    : by refl\n    ... \u2194  (x \u2208 T) \u2228 (x \u2208 S)  : by tauto!\n    ... \u2194 x \u2208 T \u222a S           : by refl\nend\n", "## Task\nProve the left distributivity of intersection over union. That is, given sets $S$, $T$, $U$\nof a type $X$, prove $S \\cap (T \\cup U) = (S \\cap T) \\cup (S \\cap U)$.\n\nTry a 'proof by calculation', as above. You should need only three calculation lines.\n", "Given sets $S$, $T$, and $U$\non a type $X$, one has  $S \\cap (T \\cup U) = (S \\cap T) \\cup (S \\cap U)$.\n", "end exlean -- hide", "import sets.intersection_union -- hide\n", "# Sets\n## Level 9 : Intersections and subsets\n", "namespace exlean -- hide\n", "**Theorem**:\nLet $X$ be a type and let $S$, $T$, and $U$ be sets on $X$. \nThen $U \\subseteq (S \\cap T) \\leftrightarrow (U \\subseteq S) \\land (U \\subseteq T)$.\n\n**Sketch proof**: We must show both directions of the double implication.\n\n1. We'll show $U \\subseteq (S \\cap T) \\to (U \\subseteq S) \\land (U \\subseteq T)$\nAssume $h : U \\subseteq (S \\cap T)$. We'll show $(U \\subseteq S) \\land (U \\subseteq T)$.\nTo prove this is to prove two statements.\n\n  1.1. We'll show $U \\subseteq S$. Assume $x : X$. Assume $h_2 : x \\in U$. We must show\n    $x \\in S$.  We have $h_3 : x \\in S \\cap T$, from $h$ and $h_2$. The remainder of this\n    subproof is left for the reader.\n\n\n  1.2. We'll show $U \\subseteq T$. Do this yourself.\n\n\n2. We'll show $(U \\subseteq S) \\land (U \\subseteq T) \\to U \\subseteq (S \\cap T)$. Or rather,\nyou'll show this!  \u220e\n", "variable {X : Type*} -- hide\n", "## Task\nComplete the Lean proof below of the theorem above.\n", "Let $X$ be a type and let $S$, $T$, and $U$ be sets on $X$. \nThen $U \\subseteq (S \\cap T) \\leftrightarrow (U \\subseteq S) \\land (U \\subseteq T)$\n", "end exlean -- hide", "import sets.subset_inter -- hide\n", "# Sets\n## Level 10: Set difference\n\nLet $S$ and $T$ be sets on a type $X$. The *set difference* of $S$ and $T$, written $S \\setminus T$, is the set\n$\\\\{x : X \\mid (x \\in S) \\land (x \\notin T) \\\\}$.\n\n\n", "variable {X : Type*}\n", "namespace exlean -- hide\n", "## Task\nComplete the proof below.\n", "Let $S$, $T$, and $U$ be sets on a type $X$, then\n$(S \\setminus T)  \\cap (S \\setminus U) = S \\setminus (T \\cup U)$.\n", "end exlean -- hide", "import sets.intersection_union -- hide\n", "# Sets\n## Level 11: Cartesian product\n\nLet $X$ and $Y$ be types. The *Cartesian product* of $X$ and $Y$, written $X \\times Y$, is the set of pairs\n$(x, y)$, where $x : X$ and $y : Y$. Given a term $z : X \\times Y$, we write $z = (z_1, z_2)$.\n\n\nLet $S$ be a set on $X$ and let $T$ be a set on $Y$. The *Cartesian product*\nof $S$ and $T$ is the set $\\\\{z : X \\times Y \\mid (z_1 \\in S) \\land (z_2 \\in T) \\\\}$.\n", "In Lean, we write `X \u00d7 Y` for the Cartesian product of types `X` and `Y`, where `\u00d7` is typed `\\x`.\n\nLikewise, we write `S \u00d7\u02e2 T` for the Cartesian product of two sets `S` and `T`. Here, `\u00d7\u02e2` is typed `\\x\\^s`.\n\nGiven `z : X \u00d7 Y`, we write `z.fst` and `z.snd` for the first and second elements of the pair `z`. Thus,\n`z = (z.fst, z.snd)`.\n", "Below is a Lean proof of the mathematical result $(A \\cup B) \\times S = (A \\times S) \\cup (B \\times S)$.\n", "namespace exlean -- hide\n", "variables {X Y : Type*} -- hide\n", "(A \u222a B) \u00d7\u02e2 S = (A \u00d7\u02e2 S) \u222a (B \u00d7\u02e2 S)\n", "lemma union_prod {A B : set X} {S : set Y} :\n(A \u222a B) \u00d7\u02e2 S = (A \u00d7\u02e2 S) \u222a (B \u00d7\u02e2 S) :=\nbegin\n  ext x,\n  show x \u2208 (A \u222a B) \u00d7\u02e2 S \u2194 x \u2208 A \u00d7\u02e2 S \u222a B \u00d7\u02e2 S,\n  calc\n  x \u2208 (A \u222a B) \u00d7\u02e2 S  \u2194 (x.fst \u2208 A \u2228 x.fst \u2208 B) \u2227 x.snd \u2208 S : by refl\n    ... \u2194 (x.fst \u2208 A \u2227 x.snd \u2208 S) \u2228 (x.fst \u2208 B \u2227 x.snd \u2208 S) : by tauto!\n    ... \u2194 x \u2208 A \u00d7\u02e2 S \u222a B \u00d7\u02e2 S                               : by refl\nend\n", "## Task\nProve that $(A \\cap B) \\times S = (A \\times S) \\cap (B \\times S)$.\n", "$(A \\cap B) \\times S = (A \\times S) \\cap (B \\times S)$.\n", "end exlean -- hide", "import sets.union_prod -- hide\n", "# Sets\n## Level 12: Power set\n\nLet $S$ be a set on a type $X$. The *power set* of $S$, denoted $\\mathcal P(S)$, is the set of\nall subsets of $S$.\n\nThat is, $A \\in \\mathcal P(S)$ means $A \\subseteq S$.\n\nIn set constructor notation, the definition of $\\mathcal P(S)$ is\n$\n\\mathcal P(S) := \\\\{A : \\text{set} X \\mid A \\subseteq S\\\u2984.\n$\n\nThis illustrates that the members $A$ of the set $\\mathcal P(S)$ are terms of\ntype $\\text{set} X$. That is, each $A$ is itself a set of elements of type $X$.\n", "In Lean, the power set of `S` is written `\ud835\udcab(S)`, where `\ud835\udcab` is typed `\\power`.\n", "variables {X : Type*} -- hide\n", "namespace exlean -- hide\n", "Here is a Lean proof that $S \\in \\mathcal P(S)$, for every set $S$.\n", "example (S : set X) : S \u2208 \ud835\udcab(S) :=\nbegin\n  show S \u2286 S,\n  from subset_refl S,\nend\n", "## Task\nProve that for all sets $S$ and $T$ on a type $X$, if $S \\subseteq T$, then\n$\\mathcal P(S) \\subseteq \\mathcal P(T)$.\n", "For all sets $S$ and $T$ on a type $X$, if $S \\subseteq T$, then\n$\\mathcal P(S) \\subseteq \\mathcal P(T)$.\n", "end exlean -- hide", "import sets.power_set -- hide\n", "# Sets\n## Level 13: Power sets and intersections\n", "variables {X : Type*} -- hide\n", "namespace exlean -- hide\n", "## Task\nProve, by calculation, that for all sets $S$ and $T$ on a type $X$, \n$\\mathcal P(S \\cap T) = \\mathcal P(S) \\cap \\mathcal P(T)$.\n", "Check the sidebar for a useful theorem you proved in a previous level\nof this world.\n", "A useful result", "For all sets $S$ and $T$ on a type $X$,\n$\\mathcal P(S \\cap T) = \\mathcal P(S) \\cap \\mathcal P(T)$.\n", "end exlean -- hide"]]}